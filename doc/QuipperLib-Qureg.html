<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>QuipperLib.Qureg</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_QuipperLib-Qureg.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/QuipperLib/Qureg.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">QuipperLib.Qureg</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Quantum registers
</a></li><li><a href="#g:2">Bit registers
</a></li><li><a href="#g:3">Boolean registers
</a></li><li><a href="#g:4">General registers
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides a data type of quantum registers, as well as
 associated types of classical and boolean registers.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="#t:Qureg">Qureg</a> = <a href="QuipperLib-Qureg.html#t:Register">Register</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:qureg_of_qulist_te">qureg_of_qulist_te</a> :: <a href="Quipper-Monad.html#t:Qulist">Qulist</a> -&gt; <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a></li><li class="src short"><a href="#v:qulist_of_qureg_te">qulist_of_qureg_te</a> :: <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a> -&gt; <a href="Quipper-Monad.html#t:Qulist">Qulist</a></li><li class="src short"><a href="#v:qureg_length">qureg_length</a> :: <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:qinit_register">qinit_register</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a></li><li class="src short"><a href="#v:qterm_register">qterm_register</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:qmeasure_register">qmeasure_register</a> :: <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Bit">Bit</a>&#93;</li><li class="src short"><a href="#v:with_ancilla_reg">with_ancilla_reg</a> ::  <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a</li><li class="src short"><a href="#v:with_ancilla_reg_init">with_ancilla_reg_init</a> ::  <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a</li><li class="src short"><a href="#v:qureg_shape">qureg_shape</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Bitreg">Bitreg</a> = <a href="QuipperLib-Qureg.html#t:Register">Register</a> <a href="Quipper-Monad.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:bitreg_of_bitlist_te">bitreg_of_bitlist_te</a> :: <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a> -&gt; <a href="QuipperLib-Qureg.html#t:Bitreg">Bitreg</a></li><li class="src short"><a href="#v:bitlist_of_bitreg_te">bitlist_of_bitreg_te</a> :: <a href="QuipperLib-Qureg.html#t:Bitreg">Bitreg</a> -&gt; <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a></li><li class="src short"><a href="#v:bitreg_length">bitreg_length</a> :: <a href="QuipperLib-Qureg.html#t:Bitreg">Bitreg</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Boolreg">Boolreg</a> = <a href="QuipperLib-Qureg.html#t:Register">Register</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:boolreg_of_boollist_te">boolreg_of_boollist_te</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a></li><li class="src short"><a href="#v:boollist_of_boolreg_te">boollist_of_boolreg_te</a> :: <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a></li><li class="src short"><a href="#v:boolreg_length">boolreg_length</a> :: <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:boolreg_of_int_le">boolreg_of_int_le</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> a =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; a -&gt; <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a></li><li class="src short"><a href="#v:int_of_boolreg_unsigned_le">int_of_boolreg_unsigned_le</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> a =&gt; <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a> -&gt; a</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Register">Register</a> x</li><li class="src short"><a href="#v:.-33-">(.!)</a> ::  <a href="QuipperLib-Qureg.html#t:Register">Register</a> x -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; x</li></ul></div><div id="interface"><h1 id="g:1">Quantum registers
</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Qureg" class="def">Qureg</a> = <a href="QuipperLib-Qureg.html#t:Register">Register</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a><a href="src/QuipperLib/Qureg.html#line-96" class="link">Source</a></p><div class="doc"><p>The type of quantum registers. A quantum register is an array of
 qubits, indexed by natural numbers in the range from 0 to <em>n</em>-1,
 where <em>n</em> is the length of the register. The syntax <em>a</em> .!(<em>i</em>) is
 used to access the <em>i</em>th element of the register <em>a</em>. 
</p><p>The main advantage of a register over a list is constant-time
 access. The main disadvantage is that registers don't allow easy
 appending, pattern matching, or recursion.
</p></div></div><div class="top"><p class="src"><a name="v:qureg_of_qulist_te" class="def">qureg_of_qulist_te</a> :: <a href="Quipper-Monad.html#t:Qulist">Qulist</a> -&gt; <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a><a href="src/QuipperLib/Qureg.html#line-100" class="link">Source</a></p><div class="doc"><p>Convert a <code><a href="Quipper-Monad.html#t:Qulist">Qulist</a></code> to a <code><a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a></code>. The conversion is tail-endian,
 i.e., <em>r</em>.!(0) holds the tail of the list.
</p></div></div><div class="top"><p class="src"><a name="v:qulist_of_qureg_te" class="def">qulist_of_qureg_te</a> :: <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a> -&gt; <a href="Quipper-Monad.html#t:Qulist">Qulist</a><a href="src/QuipperLib/Qureg.html#line-105" class="link">Source</a></p><div class="doc"><p>Convert a <code><a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a></code> to a <code><a href="Quipper-Monad.html#t:Qulist">Qulist</a></code>. The conversion is tail-endian,
 i.e., <em>r</em>.!(0) holds the tail of the list.
</p></div></div><div class="top"><p class="src"><a name="v:qureg_length" class="def">qureg_length</a> :: <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a><a href="src/QuipperLib/Qureg.html#line-109" class="link">Source</a></p><div class="doc"><p>Return the length of a <code><a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a></code>. 
</p></div></div><div class="top"><p class="src"><a name="v:qinit_register" class="def">qinit_register</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a><a href="src/QuipperLib/Qureg.html#line-165" class="link">Source</a></p><div class="doc"><p>Creates a new quantum register, initialized from a list of
 booleans. The conversion is tail-endian, i.e., <em>r</em>.!(0) holds the
 tail of the list.
</p></div></div><div class="top"><p class="src"><a name="v:qterm_register" class="def">qterm_register</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/QuipperLib/Qureg.html#line-173" class="link">Source</a></p><div class="doc"><p>Terminates a quantum register, and assert that its state is as
 specified by the list of booleans. The conversion is tail-endian,
 i.e., <em>r</em>.!(0) holds the tail of the list.
</p></div></div><div class="top"><p class="src"><a name="v:qmeasure_register" class="def">qmeasure_register</a> :: <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Bit">Bit</a>&#93;<a href="src/QuipperLib/Qureg.html#line-179" class="link">Source</a></p><div class="doc"><p>Measure a quantum register, yielding a list of <code><a href="Quipper-Monad.html#t:Bit">Bit</a></code>s. 
</p></div></div><div class="top"><p class="src"><a name="v:with_ancilla_reg" class="def">with_ancilla_reg</a> ::  <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a<a href="src/QuipperLib/Qureg.html#line-189" class="link">Source</a></p><div class="doc"><p>Temporarily create a quantum register of size <em>n</em> for use as an
 ancilla. This can be used to introduce an ancilla with a local scope, like this: 
</p><pre> with_ancilla_reg n $ \r -&gt; do {
   &lt;&lt;&lt;code block using ancilla register r&gt;&gt;&gt;
 }
</pre></div></div><div class="top"><p class="src"><a name="v:with_ancilla_reg_init" class="def">with_ancilla_reg_init</a> ::  <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; (<a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a<a href="src/QuipperLib/Qureg.html#line-202" class="link">Source</a></p><div class="doc"><p>Like <code><a href="QuipperLib-Qureg.html#v:with_ancilla_reg">with_ancilla_reg</a></code>, except also initialize the register as
 specified by a bit vector. In this case, the argument <em>n</em> is not
 required, because it equals the length of the bit vector. When the
 ancilla is terminated at the end of its scope, it is asserted to be
 in the same state it was prepared in.
</p></div></div><div class="top"><p class="src"><a name="v:qureg_shape" class="def">qureg_shape</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a><a href="src/QuipperLib/Qureg.html#line-115" class="link">Source</a></p><div class="doc"><p>Return a piece of shape data to represent an <em>m</em>-qubit quantum
 register. Please note that the data can only be used as shape; it
 will be undefined at the leaves.
</p></div></div><h1 id="g:2">Bit registers
</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Bitreg" class="def">Bitreg</a> = <a href="QuipperLib-Qureg.html#t:Register">Register</a> <a href="Quipper-Monad.html#t:Bit">Bit</a><a href="src/QuipperLib/Qureg.html#line-123" class="link">Source</a></p><div class="doc"><p>The type of <code><a href="Quipper-Monad.html#t:Bit">Bit</a></code> registers. The syntax <em>a</em> .!(<em>i</em>) is used to
 access the <em>i</em>th element of the register <em>a</em>.
</p></div></div><div class="top"><p class="src"><a name="v:bitreg_of_bitlist_te" class="def">bitreg_of_bitlist_te</a> :: <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a> -&gt; <a href="QuipperLib-Qureg.html#t:Bitreg">Bitreg</a><a href="src/QuipperLib/Qureg.html#line-127" class="link">Source</a></p><div class="doc"><p>Turn a bit vector into a bit register. The conversion is tail-endian,
 i.e., <em>r</em>.!(0) holds the tail of the list.
</p></div></div><div class="top"><p class="src"><a name="v:bitlist_of_bitreg_te" class="def">bitlist_of_bitreg_te</a> :: <a href="QuipperLib-Qureg.html#t:Bitreg">Bitreg</a> -&gt; <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a><a href="src/QuipperLib/Qureg.html#line-132" class="link">Source</a></p><div class="doc"><p>Turn a bit register into a bit vector. The conversion is tail-endian,
 i.e., <em>r</em>.!(0) holds the tail of the list.
</p></div></div><div class="top"><p class="src"><a name="v:bitreg_length" class="def">bitreg_length</a> :: <a href="QuipperLib-Qureg.html#t:Bitreg">Bitreg</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a><a href="src/QuipperLib/Qureg.html#line-136" class="link">Source</a></p><div class="doc"><p>Return the length of a <code><a href="QuipperLib-Qureg.html#t:Bitreg">Bitreg</a></code>.
</p></div></div><h1 id="g:3">Boolean registers
</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Boolreg" class="def">Boolreg</a> = <a href="QuipperLib-Qureg.html#t:Register">Register</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/QuipperLib/Qureg.html#line-143" class="link">Source</a></p><div class="doc"><p>The type of boolean registers.
</p></div></div><div class="top"><p class="src"><a name="v:boolreg_of_boollist_te" class="def">boolreg_of_boollist_te</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a><a href="src/QuipperLib/Qureg.html#line-147" class="link">Source</a></p><div class="doc"><p>Turn a bool vector into a bool register. The conversion is tail-endian,
 i.e., <em>r</em>.!(0) holds the tail of the list.
</p></div></div><div class="top"><p class="src"><a name="v:boollist_of_boolreg_te" class="def">boollist_of_boolreg_te</a> :: <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a><a href="src/QuipperLib/Qureg.html#line-152" class="link">Source</a></p><div class="doc"><p>Turn a bool register into a bool vector. The conversion is tail-endian,
 i.e., <em>r</em>.!(0) holds the tail of the list.
</p></div></div><div class="top"><p class="src"><a name="v:boolreg_length" class="def">boolreg_length</a> :: <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a><a href="src/QuipperLib/Qureg.html#line-156" class="link">Source</a></p><div class="doc"><p>Return the length of a <code><a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:boolreg_of_int_le" class="def">boolreg_of_int_le</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> a =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; a -&gt; <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a><a href="src/QuipperLib/Qureg.html#line-216" class="link">Source</a></p><div class="doc"><p><code>boolreg_of_int m x</code>: Initialize a bool register directly from an
 integer <em>x</em>, regarded as a binary string of length <em>m</em>. The
 conversion is little-endian, i.e., the register holds the least
 significant digit at index 0.
</p></div></div><div class="top"><p class="src"><a name="v:int_of_boolreg_unsigned_le" class="def">int_of_boolreg_unsigned_le</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> a =&gt; <a href="QuipperLib-Qureg.html#t:Boolreg">Boolreg</a> -&gt; a<a href="src/QuipperLib/Qureg.html#line-223" class="link">Source</a></p><div class="doc"><p><code>int_of_boolreg_unsigned_le m r</code>: Turn a bool register into an
 integer, regarded as a binary string. The conversion is
 little-endian, i.e., the register holds the least significant digit
 at index 0. The integer is unsigned.
</p></div></div><h1 id="g:4">General registers
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Register" class="def">Register</a> x <a href="src/QuipperLib/Qureg.html#line-60" class="link">Source</a></p><div class="doc"><p>A register is an array of elements of some type <em>x</em>, indexed by
 natural numbers in the range from 0 to <em>n</em>-1, where <em>n</em> is the
 length of the register.
</p></div><div class="subs instances"><p id="control.i:Register" class="caption collapser" onclick="toggleSection('i:Register')">Instances</p><div id="section.i:Register" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Typeable-Internal.html#t:Typeable1">Typeable1</a> <a href="QuipperLib-Qureg.html#t:Register">Register</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-QData.html#t:QCData">QCData</a> <a href="QuipperLib-Qureg.html#t:Bitreg">Bitreg</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-QData.html#t:QCData">QCData</a> <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-Labels.html#t:Labelable">Labelable</a> <a href="QuipperLib-Qureg.html#t:Bitreg">Bitreg</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-Labels.html#t:Labelable">Labelable</a> <a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Show.html#t:Show">Show</a> x =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Show.html#t:Show">Show</a> (<a href="QuipperLib-Qureg.html#t:Register">Register</a> x)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:.-33-" class="def">(.!)</a> ::  <a href="QuipperLib-Qureg.html#t:Register">Register</a> x -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; x<a href="src/QuipperLib/Qureg.html#line-64" class="link">Source</a></p><div class="doc"><p><code><em>r</em> !.(<em>i</em>)</code>: Return the <em>i</em>th element of a register <em>r</em>.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>
