<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Algorithms.BWT.Template</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Algorithms-BWT-Template.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Algorithms/BWT/Template.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Algorithms.BWT.Template</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Circuit building functions
</a><ul><li><a href="#g:2">General operations on booleans
</a></li><li><a href="#g:3">Encoding the BWT oracle on booleans and lists of booleans
</a></li></ul></li><li><a href="#g:4">Wrapping it into the Oracle data type
</a><ul><li><a href="#g:5">Colors
</a></li><li><a href="#g:6">Functions for using the generated oracle
</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>The BWT Oracle, written in a classical, functional manner and
 automatically transformed to a quantum circuit using Quipper's
 &quot;build_circuit&quot; mechanism.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:boollist_xor">boollist_xor</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93;</li><li class="src short"><a href="#v:bit_adder">bit_adder</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>)</li><li class="src short"><a href="#v:parent">parent</a> :: <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a></li><li class="src short"><a href="#v:childintree">childintree</a> :: <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a></li><li class="src short"><a href="#v:doweld1">doweld1</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93;</li><li class="src short"><a href="#v:doweld0">doweld0</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93;</li><li class="src short"><a href="#v:weld">weld</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a></li><li class="src short"><a href="#v:child">child</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a></li><li class="src short"><a href="#v:level_parity">level_parity</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:is_zero">is_zero</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:is_root">is_root</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:v_function">v_function</a> :: <a href="Quipper-CircLifting.html#t:BoolParam">BoolParam</a> -&gt; <a href="Quipper-CircLifting.html#t:BoolParam">BoolParam</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>, <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a>)</li><li class="src short"><span class="keyword">type</span> <a href="#t:Color">Color</a> = <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:colorToBoolParam">colorToBoolParam</a> :: <a href="Algorithms-BWT-Template.html#t:Color">Color</a> -&gt; (<a href="Quipper-CircLifting.html#t:BoolParam">BoolParam</a>, <a href="Quipper-CircLifting.html#t:BoolParam">BoolParam</a>)</li><li class="src short"><a href="#v:classical_BWT_oracle">classical_BWT_oracle</a> :: <a href="Algorithms-BWT-Template.html#t:Color">Color</a> -&gt; (&#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;, &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;, <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a>)</li><li class="src short"><a href="#v:reversible_BWT_oracle">reversible_BWT_oracle</a> :: <a href="Algorithms-BWT-Template.html#t:Color">Color</a> -&gt; ((&#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;, &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;, <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a>), (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a>)) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ((&#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;, &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;, <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a>), (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a>))</li><li class="src short"><a href="#v:reversible_BWT_oracle_optim">reversible_BWT_oracle_optim</a> :: <a href="Algorithms-BWT-Template.html#t:Color">Color</a> -&gt; ((&#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;, &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;, <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a>), (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a>)) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ((&#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;, &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;, <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a>), (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a>))</li><li class="src short"><a href="#v:oracle_template">oracle_template</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="Algorithms-BWT-Alternative.html#t:Oracle">Oracle</a></li><li class="src short"><a href="#v:oracle_template_optim">oracle_template_optim</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="Algorithms-BWT-Alternative.html#t:Oracle">Oracle</a></li></ul></div><div id="interface"><h1 id="g:1">Circuit building functions
</h1><div class="doc"><p>This section contains an implementation of the oracle as a
 collection of ordinary functional programs. Each function in this
 section is decorated with the <code>build_circuit</code> keyword (see
 <a href="Quipper-CircLifting.html#build_circuit">Quipper.CircLifting</a>). Therefore, circuits are
 automatically generated; for example, the circuit corresponding to
 the function <code>bwt_oracle</code> is automatically built and given the name
 <code>template_bwt_oracle</code>.
</p></div><h2 id="g:2">General operations on booleans
</h2><div class="top"><p class="src"><a name="v:boollist_xor" class="def">boollist_xor</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93;<a href="src/Algorithms/BWT/Template.html#line-35" class="link">Source</a></p><div class="doc"><p>Exclusive <em>or</em> operation on bit vectors. 
</p></div></div><div class="top"><p class="src"><a name="v:bit_adder" class="def">bit_adder</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>)<a href="src/Algorithms/BWT/Template.html#line-42" class="link">Source</a></p><div class="doc"><p><code><a href="Algorithms-BWT-Template.html#v:bit_adder">bit_adder</a></code> <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:False">False</a></code> is a one-bit adder, and <code><a href="Algorithms-BWT-Template.html#v:bit_adder">bit_adder</a></code> <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:True">True</a></code> is a
 one-bit subtracter (i.e., add the 2's complement of <em>y</em>).
</p></div></div><h2 id="g:3">Encoding the BWT oracle on booleans and lists of booleans
</h2><div class="top"><p class="src"><a name="v:parent" class="def">parent</a> :: <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a><a href="src/Algorithms/BWT/Template.html#line-58" class="link">Source</a></p><div class="doc"><p>Input a node <em>a</em> and return the parent of <em>a</em>. We assume that <em>a</em>
 is not a root or invalid.
</p></div></div><div class="top"><p class="src"><a name="v:childintree" class="def">childintree</a> :: <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a><a href="src/Algorithms/BWT/Template.html#line-65" class="link">Source</a></p><div class="doc"><p>Input a node <em>a</em> and return the left or right child of <em>a</em>
 (depending on whether the <em>childbit</em> is <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:False">False</a></code> or <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:True">True</a></code>,
 respectively). Assumes that <em>a</em> is not a leaf.
</p></div></div><div class="top"><p class="src"><a name="v:doweld1" class="def">doweld1</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93;<a href="src/Algorithms/BWT/Template.html#line-79" class="link">Source</a></p><div class="doc"><p>Input an <em>n</em>+1-bit leaf node <em>a</em>:<em>aa</em> (without the tree bit; <em>a</em>
 is the highest bit and <em>aa</em> is the remaining <em>n</em> bits) and a sign
 <em>s</em> (where <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:True">True</a></code> = negative, <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:False">False</a></code> = positive).  Return
 <em>a</em>:(<em>aa</em> + <em>s</em> * <em>f</em>). The first input is the <em>n</em>-bit welding
 vector <em>f</em> (a parameter to the oracle). Note that <em>f</em> is a
 parameter and <em>s</em>, <em>aa</em> are inputs.
</p></div></div><div class="top"><p class="src"><a name="v:doweld0" class="def">doweld0</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93;<a href="src/Algorithms/BWT/Template.html#line-90" class="link">Source</a></p><div class="doc"><p>Input an <em>n</em>+1-bit leaf node <em>a</em>:<em>aa</em> (without the tree bit), and
 return <em>a</em>:(<em>aa</em> &#8853; <em>g</em>). The first input is the <em>n</em>-bit welding
 vector <em>g</em> (a parameter to the oracle).
</p></div></div><div class="top"><p class="src"><a name="v:weld" class="def">weld</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a><a href="src/Algorithms/BWT/Template.html#line-101" class="link">Source</a></p><div class="doc"><p>Input a leaf node <em>a</em> and return the left or right weld of <em>a</em> in
 the other tree (depending on whether the <em>weldbit</em> is <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:False">False</a></code> or
 <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:True">True</a></code>).  Assumes that <em>a</em> is a leaf.
</p></div></div><div class="top"><p class="src"><a name="v:child" class="def">child</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a><a href="src/Algorithms/BWT/Template.html#line-111" class="link">Source</a></p><div class="doc"><p>Input a node <em>a</em> and return the left or right child of <em>a</em>
 (depending on whether the <em>childbit</em> is <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:False">False</a></code> or <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:True">True</a></code>. This
 works for leaf and non-leaf nodes.
</p></div></div><div class="top"><p class="src"><a name="v:level_parity" class="def">level_parity</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/Algorithms/BWT/Template.html#line-125" class="link">Source</a></p><div class="doc"><p>Input a node address (without the tree bit) and return the parity
 of the node level expressed as a boolean either <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:False">False</a></code> or
 <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:True">True</a></code>. Leaves have parity <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:False">False</a></code>, and other levels have
 alternating parities. In other words: count the number of leading
 zeros modulo 2.
</p></div></div><div class="top"><p class="src"><a name="v:is_zero" class="def">is_zero</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/Algorithms/BWT/Template.html#line-133" class="link">Source</a></p><div class="doc"><p>Input a node address (without the tree bit) and return <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:True">True</a></code> iff
 the node address is invalid. In other words, return <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:True">True</a></code> iff the
 list consists of all 0's.
</p></div></div><div class="top"><p class="src"><a name="v:is_root" class="def">is_root</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/Algorithms/BWT/Template.html#line-141" class="link">Source</a></p><div class="doc"><p>Input a node address (without the tree bit) and return <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:True">True</a></code> iff
 the node is a root or invalid. In other words, check whether all
 digits but the last are 0's.
</p></div></div><div class="top"><p class="src"><a name="v:v_function" class="def">v_function</a><a href="src/Algorithms/BWT/Template.html#line-154" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Quipper-CircLifting.html#t:BoolParam">BoolParam</a></td><td class="doc"><p>First color bit.
</p></td></tr><tr><td class="src">-&gt; <a href="Quipper-CircLifting.html#t:BoolParam">BoolParam</a></td><td class="doc"><p>Second color bit.
</p></td></tr><tr><td class="src">-&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a></td><td class="doc"><p>Vector <em>f</em> from Equation (26).
</p></td></tr><tr><td class="src">-&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a></td><td class="doc"><p>Vector <em>g</em> from Equation (27).
</p></td></tr><tr><td class="src">-&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a></td><td class="doc"><p>Entry node <em>a</em>.
</p></td></tr><tr><td class="src">-&gt; (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>, <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a>)</td><td class="doc"><p>(<code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:True">True</a></code>, exit node) or (<code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:False">False</a></code>, garbage).
</p></td></tr></table></div><div class="doc"><p><code><code><a href="Algorithms-BWT-Template.html#v:v_function">v_function</a></code> f g c a</code>: returns <em>v</em><sub><em>c</em></sub>(<em>a</em>), the label of the
 node connected to <em>a</em> by an edge of color <em>c</em>, or <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#v:Nothing">Nothing</a></code> if
 there is no such node. The parameters <em>f</em> and <em>g</em> encode the
 welding functions, and are lists of length <em>n</em>. <em>c</em> is a color in
 the range 0..3, and <em>a</em> is an (<em>n</em>+2)-bit node label.
</p></div></div><h1 id="g:4">Wrapping it into the Oracle data type
</h1><div class="doc"><p>The following functions package the circuit generated by
 <code><a href="Algorithms-BWT-Template.html#v:v_function">v_function</a></code> into a data structure of type <code><a href="Algorithms-BWT-Alternative.html#t:Oracle">Oracle</a></code>.
</p></div><h2 id="g:5">Colors
</h2><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Color" class="def">Color</a> = <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a><a href="src/Algorithms/BWT/Template.html#line-180" class="link">Source</a></p><div class="doc"><p>A color is a number between 0 and 3.
</p></div></div><div class="top"><p class="src"><a name="v:colorToBoolParam" class="def">colorToBoolParam</a> :: <a href="Algorithms-BWT-Template.html#t:Color">Color</a> -&gt; (<a href="Quipper-CircLifting.html#t:BoolParam">BoolParam</a>, <a href="Quipper-CircLifting.html#t:BoolParam">BoolParam</a>)<a href="src/Algorithms/BWT/Template.html#line-183" class="link">Source</a></p><div class="doc"><p>Convert an integer representation of a color into the two-bit representation.
</p></div></div><h2 id="g:6">Functions for using the generated oracle
</h2><div class="top"><p class="src"><a name="v:classical_BWT_oracle" class="def">classical_BWT_oracle</a><a href="src/Algorithms/BWT/Template.html#line-197" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Algorithms-BWT-Template.html#t:Color">Color</a></td><td class="doc"><p>The color.
</p></td></tr><tr><td class="src">-&gt; (&#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;, &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;, <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a>)</td><td class="doc"><p>The two welding vectors and a node <em>a</em>.
</p></td></tr><tr><td class="src">-&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a>)</td><td class="doc"><p>Output <em>(r,b)</em>.
</p></td></tr></table></div><div class="doc"><p>This is the <em>irreversible</em> classical circuit generated from
 <code><a href="Algorithms-BWT-Template.html#v:v_function">v_function</a></code>. This is basically the same as <code>template_v_function</code>,
 except that excessive uses of <code><a href="Quipper-Monad.html#t:Circ">Circ</a></code> are removed from the type, and
 the inputs and outputs have been reorganized.
</p></div></div><div class="top"><p class="src"><a name="v:reversible_BWT_oracle" class="def">reversible_BWT_oracle</a><a href="src/Algorithms/BWT/Template.html#line-206" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Algorithms-BWT-Template.html#t:Color">Color</a></td><td class="doc"><p>Color.
</p></td></tr><tr><td class="src">-&gt; ((&#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;, &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;, <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a>), (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a>))</td><td class="doc"><p><em>(f, g, a, r, b)</em>.
</p></td></tr><tr><td class="src">-&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ((&#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;, &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;, <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a>), (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a>))</td><td class="doc"><p>Output <em>(f, g, a, r, b)</em>.
</p></td></tr></table></div><div class="doc"><p>This is the <em>reversible</em> circuit automatically generated from <code><a href="Algorithms-BWT-Template.html#v:classical_BWT_oracle">classical_BWT_oracle</a></code>. 
</p></div></div><div class="top"><p class="src"><a name="v:reversible_BWT_oracle_optim" class="def">reversible_BWT_oracle_optim</a><a href="src/Algorithms/BWT/Template.html#line-217" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Algorithms-BWT-Template.html#t:Color">Color</a></td><td class="doc"><p>Color.
</p></td></tr><tr><td class="src">-&gt; ((&#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;, &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;, <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a>), (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a>))</td><td class="doc"><p><em>(f, g, a, r, b)</em>.
</p></td></tr><tr><td class="src">-&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ((&#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;, &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;, <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a>), (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a>))</td><td class="doc"><p>Output <em>(f, g, a, r, b)</em>.
</p></td></tr></table></div><div class="doc"><p>This is the <em>reversible</em> circuit automatically generated from <code><a href="Algorithms-BWT-Template.html#v:classical_BWT_oracle">classical_BWT_oracle</a></code>, and optimized with peep-hole optimization.
</p></div></div><div class="top"><p class="src"><a name="v:oracle_template" class="def">oracle_template</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="Algorithms-BWT-Alternative.html#t:Oracle">Oracle</a><a href="src/Algorithms/BWT/Template.html#line-232" class="link">Source</a></p><div class="doc"><p>The template oracle, packaged into the <code><a href="Algorithms-BWT-Alternative.html#t:Oracle">Oracle</a></code> abstraction. Note
 that this circuit is automatically generated from the classical
 functions above, but is completely unoptimized. This oracle has two
 parameters, namely the welding vectors <em>f</em> and <em>g</em>.
</p></div></div><div class="top"><p class="src"><a name="v:oracle_template_optim" class="def">oracle_template_optim</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="Algorithms-BWT-Alternative.html#t:Oracle">Oracle</a><a href="src/Algorithms/BWT/Template.html#line-252" class="link">Source</a></p><div class="doc"><p>The template oracle, optimized.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>
