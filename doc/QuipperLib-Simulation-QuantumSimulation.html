<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>QuipperLib.Simulation.QuantumSimulation</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_QuipperLib-Simulation-QuantumSimulation.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/QuipperLib/Simulation/QuantumSimulation.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">QuipperLib.Simulation.QuantumSimulation</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Simulation as a Transformer
</a></li><li><a href="#g:2">Generic functions
</a><ul><li><a href="#g:3">Generic run function
</a></li><li><a href="#g:4">Generic sim function
</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides functions for simulating circuits, 
 for testing and debugging purposes. 
 It borrows ideas from the implementation of the Quantum IO Monad.
</p><p>This module provides the internal implementation of the library,
 and can be imported by other libraries. The public interface to
 simulation is <a href="QuipperLib-Simulation.html">QuipperLib.Simulation</a>.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:trace">trace</a> ::  <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; a -&gt; a</li><li class="src short"><span class="keyword">type</span> <a href="#t:GateR">GateR</a> r = (Cplx r, Cplx r, Cplx r, Cplx r)</li><li class="src short"><a href="#v:scale">scale</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; Cplx r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r</li><li class="src short"><a href="#v:reverseR">reverseR</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r</li><li class="src short"><a href="#v:gateQ">gateQ</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r</li><li class="src short"><a href="#v:gateQinv">gateQinv</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; <a href="Quipper-Circuit.html#t:InverseFlag">InverseFlag</a> -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r</li><li class="src short"><a href="#v:expC">expC</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; Cplx r -&gt; Cplx r</li><li class="src short"><a href="#v:piC">piC</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; Cplx r</li><li class="src short"><a href="#v:rotQ">rotQ</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; <a href="Quipper-Circuit.html#t:Timestep">Timestep</a> -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r</li><li class="src short"><a href="#v:rotQinv">rotQinv</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; <a href="Quipper-Circuit.html#t:InverseFlag">InverseFlag</a> -&gt; <a href="Quipper-Circuit.html#t:Timestep">Timestep</a> -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r</li><li class="src short"><a href="#v:expZtR">expZtR</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r</li><li class="src short"><a href="#v:gPhase">gPhase</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r</li><li class="src short"><a href="#v:gateC">gateC</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:Vector">Vector</a> n a = <a href="#v:Vector">Vector</a> &#91;(a, n)&#93;</li><li class="src short"><span class="keyword">type</span> <a href="#t:Amplitudes">Amplitudes</a> r = <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Vector">Vector</a> (Cplx r) (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>)</li><li class="src short"><span class="keyword">type</span> <a href="#t:ProbabilityDistribution">ProbabilityDistribution</a> r a = <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Vector">Vector</a> r a</li><li class="src short"><span class="keyword">type</span> <a href="#t:QuantumTrace">QuantumTrace</a> r = <a href="QuipperLib-Simulation-QuantumSimulation.html#t:ProbabilityDistribution">ProbabilityDistribution</a> r &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93;</li><li class="src short"><a href="#v:normalize">normalize</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumTrace">QuantumTrace</a> r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumTrace">QuantumTrace</a> r</li><li class="src short"><span class="keyword">data</span>  <a href="#t:QuantumState">QuantumState</a> r = <a href="#v:QState">QState</a> {<ul class="subs"><li><a href="#v:next_wire">next_wire</a> :: <a href="Quipper-Circuit.html#t:Wire">Wire</a></li><li><a href="#v:quantum_state">quantum_state</a> :: <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r</li><li><a href="#v:traces">traces</a> :: &#91;<a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumTrace">QuantumTrace</a> r&#93;</li><li><a href="#v:namespace">namespace</a> :: <a href="Quipper-Circuit.html#t:Namespace">Namespace</a></li><li><a href="#v:trace_flag">trace_flag</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li></ul>}</li><li class="src short"><a href="#v:empty_quantum_state">empty_quantum_state</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumState">QuantumState</a> r</li><li class="src short"><a href="#v:classical_control">classical_control</a> :: <a href="Quipper-Circuit.html#t:Signed">Signed</a> (<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:classical_controls">classical_controls</a> :: <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:qc_control">qc_control</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Quipper-Circuit.html#t:Signed">Signed</a> (<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:qc_controls">qc_controls</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:magnitude">magnitude</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; Cplx r -&gt; r</li><li class="src short"><a href="#v:split">split</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r) =&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; (r, <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r, <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r)</li><li class="src short"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:Monad">Monad</a> m) =&gt; <a href="#t:PMonad">PMonad</a> r m  <span class="keyword">where</span><ul class="subs"><li><a href="#v:merge">merge</a> ::  r -&gt; a -&gt; a -&gt; m a</li></ul></li><li class="src short"><a href="#v:merge_with_result">merge_with_result</a> :: <a href="QuipperLib-Simulation-QuantumSimulation.html#t:PMonad">PMonad</a> r m =&gt; r -&gt; a -&gt; a -&gt; m (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>, a)</li><li class="src short"><a href="#v:get_trace">get_trace</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumTrace">QuantumTrace</a> r</li><li class="src short"><a href="#v:add">add</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>, Cplx r) -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r</li><li class="src short"><a href="#v:apply">apply</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> r) =&gt; (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r) -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r</li><li class="src short"><a href="#v:vector">vector</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r</li><li class="src short"><a href="#v:if_controls">if_controls</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r) -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r</li><li class="src short"><a href="#v:performGateQ">performGateQ</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r</li><li class="src short"><a href="#v:simulation_transformer">simulation_transformer</a> :: (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:PMonad">PMonad</a> r m, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r) =&gt; <a href="Quipper-Transformer.html#t:Transformer">Transformer</a> (StateT (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumState">QuantumState</a> r) m) <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:simulation_dynamic_transformer">simulation_dynamic_transformer</a> :: (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:PMonad">PMonad</a> r m, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r) =&gt; <a href="Quipper-Transformer.html#t:DynamicTransformer">DynamicTransformer</a> (StateT (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumState">QuantumState</a> r) m) <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:simulate_transform_unary">simulate_transform_unary</a> :: (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:PMonad">PMonad</a> r m, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r) =&gt; (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-QData.html#t:QCData">QCData</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb), <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qb ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)) =&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa -&gt; StateT (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumState">QuantumState</a> r) m (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb))</li><li class="src short"><a href="#v:qdata_concrete_shape">qdata_concrete_shape</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa -&gt; qa</li><li class="src short"><a href="#v:qdata_concrete_bindings">qdata_concrete_bindings</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:qdata_to_basis">qdata_to_basis</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:qdata_vector_to_amplitudes">qdata_vector_to_amplitudes</a> :: (<a href="Quipper-QData.html#t:QData">QData</a> qa, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r) =&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Vector">Vector</a> (Cplx r) (<a href="Quipper-QData.html#t:BType">BType</a> qa) -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r</li><li class="src short"><a href="#v:basis_to_qdata">basis_to_qdata</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; qa -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa</li><li class="src short"><a href="#v:amplitudes_to_qdata_vector">amplitudes_to_qdata_vector</a> :: (<a href="Quipper-QData.html#t:QData">QData</a> qa, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r) =&gt; qa -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Vector">Vector</a> (Cplx r) (<a href="Quipper-QData.html#t:BType">BType</a> qa)</li><li class="src short"><a href="#v:simulate_amplitudes_unary">simulate_amplitudes_unary</a> :: (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:PMonad">PMonad</a> r m, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QData">QData</a> qa, <a href="Quipper-QData.html#t:QData">QData</a> qb, qb ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qb) =&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Vector">Vector</a> (Cplx r) (<a href="Quipper-QData.html#t:BType">BType</a> qa) -&gt; m (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:Vector">Vector</a> (Cplx r) (<a href="Quipper-QData.html#t:BType">BType</a> qb))</li><li class="src short"><a href="#v:sim_amps">sim_amps</a> :: (<a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QData">QData</a> qa, <a href="Quipper-QData.html#t:QData">QData</a> qb, qb ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qb, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> (<a href="Quipper-QData.html#t:BType">BType</a> qb)) =&gt; g -&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> (<a href="Quipper-QData.html#t:BType">BType</a> qa) (Cplx r) -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> (<a href="Quipper-QData.html#t:BType">BType</a> qb) (Cplx r)</li><li class="src short"><a href="#v:run_unary">run_unary</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-QData.html#t:QCData">QCData</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb), <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qb ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)) =&gt; g -&gt; r -&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa -&gt; <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)</li><li class="src short"><a href="#v:run_unary_trace">run_unary_trace</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-QData.html#t:QCData">QCData</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb), <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qb ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)) =&gt; g -&gt; r -&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa -&gt; &#91;<a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumTrace">QuantumTrace</a> r&#93;</li><li class="src short"><a href="#v:run_unary_io">run_unary_io</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-QData.html#t:QCData">QCData</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb), <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qb ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)) =&gt; r -&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb))</li><li class="src short"><a href="#v:run_unary_trace_io">run_unary_trace_io</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-QData.html#t:QCData">QCData</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb), <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qb ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)) =&gt; r -&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a> &#91;<a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumTrace">QuantumTrace</a> r&#93;</li><li class="src short"><a href="#v:sim_unary">sim_unary</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-QData.html#t:QCData">QCData</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb), <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qb ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)) =&gt; r -&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:ProbabilityDistribution">ProbabilityDistribution</a> r (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb))</li><li class="src short"><a href="#v:run_generic">run_generic</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qa) (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb))) =&gt; g -&gt; r -&gt; qfun -&gt; qfun'</li><li class="src short"><a href="#v:run_generic_trace">run_generic_trace</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qa) &#91;<a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumTrace">QuantumTrace</a> r&#93;) =&gt; g -&gt; r -&gt; qfun -&gt; qfun'</li><li class="src short"><a href="#v:run_generic_io">run_generic_io</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qa) (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)))) =&gt; r -&gt; qfun -&gt; qfun'</li><li class="src short"><a href="#v:run_generic_trace_io">run_generic_trace_io</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qa) (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a> &#91;<a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumTrace">QuantumTrace</a> r&#93;)) =&gt; r -&gt; qfun -&gt; qfun'</li><li class="src short"><a href="#v:sim_generic">sim_generic</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qa) (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:ProbabilityDistribution">ProbabilityDistribution</a> r (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)))) =&gt; r -&gt; qfun -&gt; qfun'</li></ul></div><div id="interface"><h1>Documentation</h1><div class="top"><p class="src"><a name="v:trace" class="def">trace</a> ::  <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; a -&gt; a<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-54" class="link">Source</a></p><div class="doc"><p>We define our own trace function that only calls trace if the boolean
 argument is true.
</p></div></div><h1 id="g:1">Simulation as a Transformer
</h1><div class="doc"><p>The quantum simulator takes a Quipper circuit producing function,
 and uses a transformer to simulate the resulting circuit, one gate at a time.
 This allows the simulation to progress in a lazy manner, allowing dynamic
 lifting results to be passed back to the circuit producing function as
 and when they are required (to generate further gates in the circuit).
</p></div><div class="doc"><p>The implementation of the quantum simulator makes use of a <em>State</em> monad
 to carry an underlying quantum state throughout the computation. This <em>State</em>
 is updated by each quantum operation within the circuit. A quantum
 state is a vector of <code>basis</code> states, along with complex amplitudes.
</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:GateR" class="def">GateR</a> r = (Cplx r, Cplx r, Cplx r, Cplx r)<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-78" class="link">Source</a></p><div class="doc"><p>Gates that act on a single qubit can be defined by essentially a 2-by-2 matrix.
 A GateR is written by rows, such that a matrix:
</p><p><img src="images/GateR.png"> 
</p><p>would be written as (m00,m01,m10,m11).
</p></div></div><div class="top"><p class="src"><a name="v:scale" class="def">scale</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; Cplx r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-81" class="link">Source</a></p><div class="doc"><p>Scalar multiplication of a 2-by-2 matrix by a given scalar.
</p></div></div><div class="top"><p class="src"><a name="v:reverseR" class="def">reverseR</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-85" class="link">Source</a></p><div class="doc"><p>The inverse of a <code><a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a></code> is its conjugate transpose.
</p></div></div><div class="top"><p class="src"><a name="v:gateQ" class="def">gateQ</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-102" class="link">Source</a></p><div class="doc"><p>A simple pattern matching function that gives each &quot;gate name&quot;
 a <em>GateR</em> representation.  Adding (single qubit) quantum gates to
 this function will give them an implementation in the
 simulator. Any single qubit named quantum gate that needs to be
 simulated must have a clause in this function, along with a given
 <em>GateR</em> that is its matrix representation. Note that unitarity is
 not enforced, so defined gates must be checked manually to be
 unitary operators.
</p><pre> Example Gates:
 gateQ &quot;x&quot; = (0,1,1,0)
 gateQ &quot;hadamard&quot; = (h, h, h,-h) where h = (1/sqrt 2)
</pre></div></div><div class="top"><p class="src"><a name="v:gateQinv" class="def">gateQinv</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; <a href="Quipper-Circuit.html#t:InverseFlag">InverseFlag</a> -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-120" class="link">Source</a></p><div class="doc"><p>Like <code><a href="QuipperLib-Simulation-QuantumSimulation.html#v:gateQ">gateQ</a></code>, but also conditionally invert the gate depending
 on InverseFlag.
</p></div></div><div class="top"><p class="src"><a name="v:expC" class="def">expC</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; Cplx r -&gt; Cplx r<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-125" class="link">Source</a></p><div class="doc"><p>The exponential function for <code>Cplx</code> numbers.
</p></div></div><div class="top"><p class="src"><a name="v:piC" class="def">piC</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; Cplx r<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-129" class="link">Source</a></p><div class="doc"><p>The constant &#960;, as a complex number.
</p></div></div><div class="top"><p class="src"><a name="v:rotQ" class="def">rotQ</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; <a href="Quipper-Circuit.html#t:Timestep">Timestep</a> -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-133" class="link">Source</a></p><div class="doc"><p>Like <code><a href="QuipperLib-Simulation-QuantumSimulation.html#v:gateQ">gateQ</a></code>, but takes the name of a rotation and a real parameter. 
</p></div></div><div class="top"><p class="src"><a name="v:rotQinv" class="def">rotQinv</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; <a href="Quipper-Circuit.html#t:InverseFlag">InverseFlag</a> -&gt; <a href="Quipper-Circuit.html#t:Timestep">Timestep</a> -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-150" class="link">Source</a></p><div class="doc"><p>Like <code><a href="QuipperLib-Simulation-QuantumSimulation.html#v:rotQ">rotQ</a></code>, but also conditionally invert the gate depending on
 InverseFlag.
</p></div></div><div class="top"><p class="src"><a name="v:expZtR" class="def">expZtR</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-155" class="link">Source</a></p><div class="doc"><p>Return the matrix for the <code>QexpZt</code> gate.
</p></div></div><div class="top"><p class="src"><a name="v:gPhase" class="def">gPhase</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-159" class="link">Source</a></p><div class="doc"><p>Return the matrix for the <code><a href="Quipper-Circuit.html#v:GPhase">GPhase</a></code> gate.
</p></div></div><div class="top"><p class="src"><a name="v:gateC" class="def">gateC</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-168" class="link">Source</a></p><div class="doc"><p>Translate a classical gate name into a boolean function.
 Adding classical gates to this function will give them an implementation in
 the simulator.
</p><pre> Example Gate:
 gateC &quot;if&quot; &#91;a,b,c&#93; = if a then b else c 
</pre></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Vector" class="def">Vector</a> n a <a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-174" class="link">Source</a></p><div class="doc"><p>The type of vectors with scalars in <em>n</em> over the basis <em>a</em>. A
 vector is simply a list of pairs. 
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Vector" class="def">Vector</a> &#91;(a, n)&#93;</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Vector" class="caption collapser" onclick="toggleSection('i:Vector')">Instances</p><div id="section.i:Vector" class="show"><table><tr><td class="src">(<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> r) =&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:PMonad">PMonad</a> r (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:Vector">Vector</a> r)</td><td class="doc"><p><code><a href="QuipperLib-Simulation-QuantumSimulation.html#t:ProbabilityDistribution">ProbabilityDistribution</a></code> forms a <code><a href="QuipperLib-Simulation-QuantumSimulation.html#t:PMonad">PMonad</a></code> such that probabilistic results are 
 &quot;merged&quot; by extending the probability distribution by the possible results.
</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a> n =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:Monad">Monad</a> (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:Vector">Vector</a> n)</td><td class="doc"><p>Any numeric indexed vector forms a <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:Monad">Monad</a></code>.
</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a> n =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:Functor">Functor</a> (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:Vector">Vector</a> n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a> n =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html#t:Applicative">Applicative</a> (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:Vector">Vector</a> n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Show.html#t:Show">Show</a> a, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> a, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a> n, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> n, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Show.html#t:Show">Show</a> n) =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Show.html#t:Show">Show</a> (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:Vector">Vector</a> n a)</td><td class="doc"><p>We can show certain vectors, ignoring any 0 probabilities, and
 combining equal terms.
</p></td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Amplitudes" class="def">Amplitudes</a> r = <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Vector">Vector</a> (Cplx r) (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>)<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-177" class="link">Source</a></p><div class="doc"><p>An amplitude distribution gives each classical basis state an amplitude.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:ProbabilityDistribution" class="def">ProbabilityDistribution</a> r a = <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Vector">Vector</a> r a<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-180" class="link">Source</a></p><div class="doc"><p>A probability distribution gives each element a probability.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:QuantumTrace" class="def">QuantumTrace</a> r = <a href="QuipperLib-Simulation-QuantumSimulation.html#t:ProbabilityDistribution">ProbabilityDistribution</a> r &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93;<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-186" class="link">Source</a></p><div class="doc"><p>A QuantumTrace is essentially a probability distribution for the current state
 of the qubits that have been traced. We can represent this using a Vector. The
 list of Booleans is in the same order as the list of Qubits that was being 
 traced.
</p></div></div><div class="top"><p class="src"><a name="v:normalize" class="def">normalize</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumTrace">QuantumTrace</a> r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumTrace">QuantumTrace</a> r<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-189" class="link">Source</a></p><div class="doc"><p>Normalizing is used to make sure the probabilities add up to 1.
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:QuantumState" class="def">QuantumState</a> r <a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-200" class="link">Source</a></p><div class="doc"><p>A <code><a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumState">QuantumState</a></code> is the data structure containing the state that we update
 throughout the simulation. We need to keep track of the next available wire,
 and a quantum state in the form of a distribution of basis states. We also
 track a list of quantum traces, so that we have a &quot;tracing&quot; mechanism during
 the execution of quantum circuits.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:QState" class="def">QState</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:next_wire" class="def">next_wire</a> :: <a href="Quipper-Circuit.html#t:Wire">Wire</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:quantum_state" class="def">quantum_state</a> :: <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:traces" class="def">traces</a> :: &#91;<a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumTrace">QuantumTrace</a> r&#93;</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:namespace" class="def">namespace</a> :: <a href="Quipper-Circuit.html#t:Namespace">Namespace</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:trace_flag" class="def">trace_flag</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><a name="v:empty_quantum_state" class="def">empty_quantum_state</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumState">QuantumState</a> r<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-210" class="link">Source</a></p><div class="doc"><p>When we start a simulation, we need an empty starting state.
</p></div></div><div class="top"><p class="src"><a name="v:classical_control" class="def">classical_control</a> :: <a href="Quipper-Circuit.html#t:Signed">Signed</a> (<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-216" class="link">Source</a></p><div class="doc"><p>It doesn't make sense having a quantum control on a classical gate, so
 we can throw an error if that is the case, and just collect the boolean
 result otherwise.
</p></div></div><div class="top"><p class="src"><a name="v:classical_controls" class="def">classical_controls</a> :: <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-223" class="link">Source</a></p><div class="doc"><p>Map the <code><a href="QuipperLib-Simulation-QuantumSimulation.html#v:classical_control">classical_control</a></code> function to all the controls, and take the
 <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-List.html#v:and">and</a></code> of the result
</p></div></div><div class="top"><p class="src"><a name="v:qc_control" class="def">qc_control</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Quipper-Circuit.html#t:Signed">Signed</a> (<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-229" class="link">Source</a></p><div class="doc"><p>When we want a quantum control, we will be working with one &quot;basis state&quot; at
 a time, and can look up the qubit's value in that basis state to see whether
 the control firs.
</p></div></div><div class="top"><p class="src"><a name="v:qc_controls" class="def">qc_controls</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-236" class="link">Source</a></p><div class="doc"><p>Map the <code><a href="QuipperLib-Simulation-QuantumSimulation.html#v:qc_control">qc_control</a></code> function to all the controls (under the given basis 
 state), and take the <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-List.html#v:and">and</a></code> of the result.
</p></div></div><div class="top"><p class="src"><a name="v:magnitude" class="def">magnitude</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; Cplx r -&gt; r<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-240" class="link">Source</a></p><div class="doc"><p>We can calculate the magnitude of a complex number
</p></div></div><div class="top"><p class="src"><a name="v:split" class="def">split</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r) =&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; (r, <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r, <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r)<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-247" class="link">Source</a></p><div class="doc"><p>The <code><a href="QuipperLib-Simulation-QuantumSimulation.html#v:split">split</a></code> function splits a Amplitude distribution, by
 partitioning it around the state of the given qubit within each basis state. It
 also returns the probability of the qubit being True within the given 
 Amplitudes. This function is used when we want to measure a qubit.
</p></div></div><div class="top"><p class="src"><span class="keyword">class</span> (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:Monad">Monad</a> m) =&gt; <a name="t:PMonad" class="def">PMonad</a> r m  <span class="keyword">where</span><a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-260" class="link">Source</a></p><div class="doc"><p>A PMonad is a Monad enriched with a <code><a href="QuipperLib-Simulation-QuantumSimulation.html#v:merge">merge</a></code> function that takes a probability,
 and two results, and returns a merged version of these results under the given 
 monad. This idea is taken directly from QIO.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:merge" class="def">merge</a> ::  r -&gt; a -&gt; a -&gt; m a<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-260" class="link">Source</a></p></div><div class="subs instances"><p id="control.i:PMonad" class="caption collapser" onclick="toggleSection('i:PMonad')">Instances</p><div id="section.i:PMonad" class="show"><table><tr><td class="src">(<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r) =&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:PMonad">PMonad</a> r <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a></td><td class="doc"><p>IO forms a PMonad, where results are merged by choosing one probabilistically
 using a random number.
</p></td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> r) =&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:PMonad">PMonad</a> r (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:Vector">Vector</a> r)</td><td class="doc"><p><code><a href="QuipperLib-Simulation-QuantumSimulation.html#t:ProbabilityDistribution">ProbabilityDistribution</a></code> forms a <code><a href="QuipperLib-Simulation-QuantumSimulation.html#t:PMonad">PMonad</a></code> such that probabilistic results are 
 &quot;merged&quot; by extending the probability distribution by the possible results.
</p></td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g) =&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:PMonad">PMonad</a> r (State g)</td><td class="doc"><p>A State Monad holding a <code><a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a></code> forms a <code><a href="QuipperLib-Simulation-QuantumSimulation.html#t:PMonad">PMonad</a></code>, where results are 
 merged by choosing one probabilistically using a random number from the 
 <code><a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a></code>.
</p></td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:merge_with_result" class="def">merge_with_result</a> :: <a href="QuipperLib-Simulation-QuantumSimulation.html#t:PMonad">PMonad</a> r m =&gt; r -&gt; a -&gt; a -&gt; m (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>, a)<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-265" class="link">Source</a></p><div class="doc"><p>We can merge two measurement outcomes, and explicitly keep the first outcome 
 as the True result, and the second as the False result.
</p></div></div><div class="top"><p class="src"><a name="v:get_trace" class="def">get_trace</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumTrace">QuantumTrace</a> r<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-318" class="link">Source</a></p><div class="doc"><p>The <code>get_trace'</code> function returns a probability distribution of the state of
 a list of qubits within a given amplitude distribution.
</p></div></div><div class="top"><p class="src"><a name="v:add" class="def">add</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>, Cplx r) -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-325" class="link">Source</a></p><div class="doc"><p>Add an amplitude to an amplitude distribution, combining (adding) the amplitudes for equal states in the distribution.
</p></div></div><div class="top"><p class="src"><a name="v:apply" class="def">apply</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> r) =&gt; (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r) -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-333" class="link">Source</a></p><div class="doc"><p>The apply' function is used to apply a function on &quot;basis states&quot; to an 
 entire amplitude distribution. 
</p></div></div><div class="top"><p class="src"><a name="v:vector" class="def">vector</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-342" class="link">Source</a></p><div class="doc"><p>Lift a function that returns a single basis state, to a function that
 returns an amplitude distribution (containing a singleton).
</p></div></div><div class="top"><p class="src"><a name="v:if_controls" class="def">if_controls</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r) -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-346" class="link">Source</a></p><div class="doc"><p>apply the given function only if the controls fire.
</p></div></div><div class="top"><p class="src"><a name="v:performGateQ" class="def">performGateQ</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r =&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:GateR">GateR</a> r -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-352" class="link">Source</a></p><div class="doc"><p><code><a href="QuipperLib-Simulation-QuantumSimulation.html#v:performGateQ">performGateQ</a></code> defines how a single qubit gate is applied to a quantum state.
 The application of a <em>GateR</em> to a qubit in a single <code>basis</code> state can split
 the state into a pair of <code>basis</code> states with corresponding amplitudes.
</p></div></div><div class="top"><p class="src"><a name="v:simulation_transformer" class="def">simulation_transformer</a> :: (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:PMonad">PMonad</a> r m, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r) =&gt; <a href="Quipper-Transformer.html#t:Transformer">Transformer</a> (StateT (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumState">QuantumState</a> r) m) <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-363" class="link">Source</a></p><div class="doc"><p>The <code><a href="QuipperLib-Simulation-QuantumSimulation.html#v:simulation_transformer">simulation_transformer</a></code> is the actual transformer that does the
 simulation. The type of the <code><a href="QuipperLib-Simulation-QuantumSimulation.html#v:simulation_transformer">simulation_transformer</a></code>shows that Qubits are 
 kept as qubits, but Bits are turned into Boolean values, i.e., the results of 
 the computation. We use a StateT Monad, acting over the IO Monad, to store a 
 QuantumState throughout the simulation. This means we carry a state, but also 
 have access to the IO Monad's random number generator (for probabilistic 
 measurement).
</p></div></div><div class="top"><p class="src"><a name="v:simulation_dynamic_transformer" class="def">simulation_dynamic_transformer</a> :: (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:PMonad">PMonad</a> r m, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r) =&gt; <a href="Quipper-Transformer.html#t:DynamicTransformer">DynamicTransformer</a> (StateT (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumState">QuantumState</a> r) m) <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-554" class="link">Source</a></p><div class="doc"><p>The simulation_transformer is also Dynamic, as the simulated wire states
 can simply be used to perform dynamic liftings.
</p></div></div><div class="top"><p class="src"><a name="v:simulate_transform_unary" class="def">simulate_transform_unary</a> :: (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:PMonad">PMonad</a> r m, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r) =&gt; (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-QData.html#t:QCData">QCData</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb), <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qb ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)) =&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa -&gt; StateT (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumState">QuantumState</a> r) m (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb))<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-563" class="link">Source</a></p><div class="doc"><p>Apply the <code>dynamic_simulation_transformer</code> to a (unary) circuit generating 
 function. 
</p></div></div><div class="top"><p class="src"><a name="v:qdata_concrete_shape" class="def">qdata_concrete_shape</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa -&gt; qa<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-574" class="link">Source</a></p><div class="doc"><p>In order to simulate a circuit using an input basis vector, we need to supply
 each quantum leaf, with a concrete (i.e., not a dummy) qubit.
</p></div></div><div class="top"><p class="src"><a name="v:qdata_concrete_bindings" class="def">qdata_concrete_bindings</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-587" class="link">Source</a></p><div class="doc"><p>In order to simulate a circuit using an input basis vector, we need to supply
 the transformer with a concrete set of qubit bindings.
</p></div></div><div class="top"><p class="src"><a name="v:qdata_to_basis" class="def">qdata_to_basis</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-601" class="link">Source</a></p><div class="doc"><p>As a helper function, in order to simulate a circuit using an input basis vector, 
 we need to be able to convert each basis into a map from concrete qubits to their
 value in the given basis.
</p></div></div><div class="top"><p class="src"><a name="v:qdata_vector_to_amplitudes" class="def">qdata_vector_to_amplitudes</a> :: (<a href="Quipper-QData.html#t:QData">QData</a> qa, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r) =&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Vector">Vector</a> (Cplx r) (<a href="Quipper-QData.html#t:BType">BType</a> qa) -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-615" class="link">Source</a></p><div class="doc"><p>In order to simulate a circuit using an input basis vector, we need to be able
 to convert the basis vector into a quantum state suitable for use by the simulator
 i.e. of type Amplitudes.
</p></div></div><div class="top"><p class="src"><a name="v:basis_to_qdata" class="def">basis_to_qdata</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; qa -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-621" class="link">Source</a></p><div class="doc"><p>As a helper function, in order to simulate a circuit using an input basis vector, 
 we need to be able to convert a map from concrete qubits to their value into a basis
 of the given concrete shape.
</p></div></div><div class="top"><p class="src"><a name="v:amplitudes_to_qdata_vector" class="def">amplitudes_to_qdata_vector</a> :: (<a href="Quipper-QData.html#t:QData">QData</a> qa, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r) =&gt; qa -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Amplitudes">Amplitudes</a> r -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Vector">Vector</a> (Cplx r) (<a href="Quipper-QData.html#t:BType">BType</a> qa)<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-631" class="link">Source</a></p><div class="doc"><p>In order to simulate a circuit using an input basis vector, we need to be able
 to convert the quantum state (i.e. of type Amplitudes) into a basis vector.
</p></div></div><div class="top"><p class="src"><a name="v:simulate_amplitudes_unary" class="def">simulate_amplitudes_unary</a> :: (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:PMonad">PMonad</a> r m, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QData">QData</a> qa, <a href="Quipper-QData.html#t:QData">QData</a> qb, qb ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qb) =&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:Vector">Vector</a> (Cplx r) (<a href="Quipper-QData.html#t:BType">BType</a> qa) -&gt; m (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:Vector">Vector</a> (Cplx r) (<a href="Quipper-QData.html#t:BType">BType</a> qb))<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-637" class="link">Source</a></p><div class="doc"><p>Apply the <code>dynamic_simulation_transformer</code> to a (unary) circuit generating
 function, starting with the quantum state set to the given vector of base states 
 and returning the resulting vector of base states.
</p></div></div><div class="top"><p class="src"><a name="v:sim_amps" class="def">sim_amps</a> :: (<a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QData">QData</a> qa, <a href="Quipper-QData.html#t:QData">QData</a> qb, qb ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qb, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> (<a href="Quipper-QData.html#t:BType">BType</a> qb)) =&gt; g -&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> (<a href="Quipper-QData.html#t:BType">BType</a> qa) (Cplx r) -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> (<a href="Quipper-QData.html#t:BType">BType</a> qb) (Cplx r)<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-672" class="link">Source</a></p><div class="doc"><p>Input a source of randomness, a quantum circuit, and an initial
 state (represented as a map from basis vectors to amplitudes).
 Simulate the circuit and return the final state. If the circuit
 includes measurements, the simulation will be probabilistic.
</p><p>The type of this heavily overloaded function is difficult to
 read. It has, for example, the following types:
</p><pre> sim_amps :: StdGen -&gt; (Qubit -&gt; Circ Qubit) -&gt; Map Bool (Cplx Double) -&gt; Map Bool (Cplx Double)
 sim_amps :: StdGen -&gt; ((Qubit,Qubit) -&gt; Circ Qubit) -&gt; Map (Bool,Bool) (Cplx Double) -&gt; Map Bool (Cplx Double)
</pre><p>and so forth. Note that instead of <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a></code>, another real number
 type, such as <code>FixedPrec</code> <em>e</em>, can be used.
</p></div></div><div class="top"><p class="src"><a name="v:run_unary" class="def">run_unary</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-QData.html#t:QCData">QCData</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb), <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qb ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)) =&gt; g -&gt; r -&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa -&gt; <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-687" class="link">Source</a></p><div class="doc"><p>Input a source of randomness, a real number, a circuit, and a
 basis state. Then simulate the circuit probabilistically. Measure
 the final state and return the resulting basis vector.
</p><p>The real number argument is a dummy and is never evaluated; its
 only purpose is to specify the <em>type</em> of real numbers that will be
 used during the simulation.
</p></div></div><div class="top"><p class="src"><a name="v:run_unary_trace" class="def">run_unary_trace</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-QData.html#t:QCData">QCData</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb), <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qb ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)) =&gt; g -&gt; r -&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa -&gt; &#91;<a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumTrace">QuantumTrace</a> r&#93;<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-698" class="link">Source</a></p><div class="doc"><p>Like <code><a href="QuipperLib-Simulation-QuantumSimulation.html#v:run_unary">run_unary</a></code>, but return the list of <code><a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumTrace">QuantumTrace</a></code> elements
 that were generated during the computation. This is useful for
 checking the intermediary state of qubits within a computation.
</p></div></div><div class="top"><p class="src"><a name="v:run_unary_io" class="def">run_unary_io</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-QData.html#t:QCData">QCData</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb), <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qb ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)) =&gt; r -&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb))<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-711" class="link">Source</a></p><div class="doc"><p>Like <code><a href="QuipperLib-Simulation-QuantumSimulation.html#v:run_unary">run_unary</a></code>, but run in the <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a></code> monad instead of passing an
 explicit source of randomness.
</p></div></div><div class="top"><p class="src"><a name="v:run_unary_trace_io" class="def">run_unary_trace_io</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-QData.html#t:QCData">QCData</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb), <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qb ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)) =&gt; r -&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a> &#91;<a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumTrace">QuantumTrace</a> r&#93;<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-721" class="link">Source</a></p><div class="doc"><p>Like <code><a href="QuipperLib-Simulation-QuantumSimulation.html#v:run_unary_trace">run_unary_trace</a></code>, but run in the <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a></code> monad instead of
 passing an explicit source of randomness.
</p></div></div><div class="top"><p class="src"><a name="v:sim_unary" class="def">sim_unary</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-QData.html#t:QCData">QCData</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb), <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qb ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)) =&gt; r -&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa -&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:ProbabilityDistribution">ProbabilityDistribution</a> r (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb))<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-732" class="link">Source</a></p><div class="doc"><p>Apply the <code><a href="QuipperLib-Simulation-QuantumSimulation.html#v:simulation_transformer">simulation_transformer</a></code> to a (unary) circuit, and then evaluate
 the resulting stateful computation to get a probability distribution of possible
 results
</p></div></div><h1 id="g:2">Generic functions
</h1><h2 id="g:3">Generic run function
</h2><div class="doc"><p>Generic functions to run Quipper circuits, via a conversion to a
 <code>SimCircuit</code> using <a href="Random.html">Random</a> to simulate quantum states.
</p></div><div class="top"><p class="src"><a name="v:run_generic" class="def">run_generic</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qa) (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb))) =&gt; g -&gt; r -&gt; qfun -&gt; qfun'<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-770" class="link">Source</a></p><div class="doc"><p>Quantum simulation of a circuit, for testing and debugging
 purposes. Input a source of randomness, a real number, and a
 quantum circuit. Output a corresponding probabilistic boolean
 function.
</p><p>The inputs to the quantum circuit are initialized according to the
 given boolean arguments. The outputs of the quantum circuit are
 measured, and the boolean measurement outcomes are
 returned. 
</p><p>The real number argument is a dummy and is never evaluated; its
 only purpose is to specify the <em>type</em> of real numbers that will be
 used during the simulation.
</p><p>The type of this heavily overloaded function is difficult to
 read. In more readable form, it has all of the following types (for
 example):
</p><pre> run_generic :: (Floating r, Random r, Ord r, RandomGen g, QCData qa) =&gt; g -&gt; r -&gt; Circ qa -&gt; BType qa
 run_generic :: (Floating r, Random r, Ord r, RandomGen g, QCData qa, QCData qb) =&gt; g -&gt; r -&gt; (qa -&gt; Circ qb) -&gt; BType qa -&gt; BType qb
 run_generic :: (Floating r, Random r, Ord r, RandomGen g, QCData qa, QCData qb, QCData qc) =&gt; g -&gt; r -&gt; (qa -&gt; qb -&gt; Circ qc) -&gt; BType qa -&gt; BType qb -&gt; BType qc
</pre><p>and so forth.
</p></div></div><div class="top"><p class="src"><a name="v:run_generic_trace" class="def">run_generic_trace</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qa) &#91;<a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumTrace">QuantumTrace</a> r&#93;) =&gt; g -&gt; r -&gt; qfun -&gt; qfun'<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-780" class="link">Source</a></p><div class="doc"><p>Like <code><a href="QuipperLib-Simulation-QuantumSimulation.html#v:run_generic">run_generic</a></code>, but also output a trace of the states of the
 given list of qubits at each step during the evaluation.
</p></div></div><div class="top"><p class="src"><a name="v:run_generic_io" class="def">run_generic_io</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qa) (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)))) =&gt; r -&gt; qfun -&gt; qfun'<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-790" class="link">Source</a></p><div class="doc"><p>Like <code><a href="QuipperLib-Simulation-QuantumSimulation.html#v:run_generic">run_generic</a></code>, but run in the <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a></code> monad instead of passing
 an explicit source of randomness.
</p></div></div><div class="top"><p class="src"><a name="v:run_generic_trace_io" class="def">run_generic_trace_io</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qa) (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a> &#91;<a href="QuipperLib-Simulation-QuantumSimulation.html#t:QuantumTrace">QuantumTrace</a> r&#93;)) =&gt; r -&gt; qfun -&gt; qfun'<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-800" class="link">Source</a></p><div class="doc"><p>Like <code><a href="QuipperLib-Simulation-QuantumSimulation.html#v:run_generic_trace">run_generic_trace</a></code>, but run in the <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a></code> monad instead of
 passing an explicit source of randomness.
</p></div></div><h2 id="g:4">Generic sim function
</h2><div class="doc"><p>A generic function to simulate Quipper circuits, via a conversion
 to a <code>SimCircuit</code> returning a probability distribution of the
 possible results.
</p></div><div class="top"><p class="src"><a name="v:sim_generic" class="def">sim_generic</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qa) (<a href="QuipperLib-Simulation-QuantumSimulation.html#t:ProbabilityDistribution">ProbabilityDistribution</a> r (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)))) =&gt; r -&gt; qfun -&gt; qfun'<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-828" class="link">Source</a></p><div class="doc"><p>A generic function to simulate Quipper circuits, via a conversion
 to a <code>SimCircuit</code> returning a probability distribution of the
 possible results.
</p><p>The type of this heavily overloaded function is difficult to
 read. In more readable form, it has all of the following types (for
 example):
</p><pre> sim_generic :: (Floating r, Ord r, QCData qa) =&gt; r -&gt; Circ qa -&gt; ProbabilityDistribution r (BType qa)
 sim_generic :: (Floating r, Ord r, QCData qa, QCData qb) =&gt; r -&gt; (qa -&gt; Circ qb) -&gt; BType qa -&gt; ProbabilityDistribution r (BType qb)
 sim_generic :: (Floating r, Ord r, QCData qa, QCData qb, QCData qc) =&gt; r -&gt; (qa -&gt; qb -&gt; Circ qc) -&gt; BType qa -&gt; BType qb -&gt; ProbabilityDistribution r (BType qc)
</pre><p>and so forth.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>
