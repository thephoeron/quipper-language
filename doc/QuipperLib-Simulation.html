<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>QuipperLib.Simulation</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_QuipperLib-Simulation.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/QuipperLib/Simulation.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">QuipperLib.Simulation</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Classical simulation
</a></li><li><a href="#g:2">Stabilizer simulation
</a></li><li><a href="#g:3">Quantum simulation
</a></li><li><a href="#g:4">Special purpose functions
</a><ul><li><a href="#g:5">Simulation with trace
</a></li><li><a href="#g:6">Probability distributions
</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This library provides functions for simulating certain classes of
 circuits, for testing and debugging purposes. 
</p><p>We can efficiently simulate classical (boolean) circuits and
 Clifford (stabilizer) circuits. We also provide functions for
 simulating arbitrary quantum circuits; however, the latter is
 (necessarily) very inefficient.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:run_classical_generic">run_classical_generic</a> :: (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> fun (<a href="Quipper-QData.html#t:BType">BType</a> qa) (<a href="Quipper-QData.html#t:BType">BType</a> qb)) =&gt; qfun -&gt; fun</li><li class="src short"><a href="#v:run_clifford_generic">run_clifford_generic</a> :: (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:BType">BType</a> qa) (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a> (<a href="Quipper-QData.html#t:BType">BType</a> qb))) =&gt; qfun -&gt; qfun'</li><li class="src short"><a href="#v:run_generic">run_generic</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qa) (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb))) =&gt; g -&gt; r -&gt; qfun -&gt; qfun'</li><li class="src short"><a href="#v:run_generic_io">run_generic_io</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qa) (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)))) =&gt; r -&gt; qfun -&gt; qfun'</li><li class="src short"><a href="#v:sim_amps">sim_amps</a> :: (<a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QData">QData</a> qa, <a href="Quipper-QData.html#t:QData">QData</a> qb, qb ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qb, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> (<a href="Quipper-QData.html#t:BType">BType</a> qb)) =&gt; g -&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> (<a href="Quipper-QData.html#t:BType">BType</a> qa) (Cplx r) -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> (<a href="Quipper-QData.html#t:BType">BType</a> qb) (Cplx r)</li><li class="src short"><span class="keyword">type</span> <a href="#t:QuantumTrace">QuantumTrace</a> r = <a href="QuipperLib-Simulation.html#t:ProbabilityDistribution">ProbabilityDistribution</a> r &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93;</li><li class="src short"><a href="#v:run_generic_trace">run_generic_trace</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qa) &#91;<a href="QuipperLib-Simulation.html#t:QuantumTrace">QuantumTrace</a> r&#93;) =&gt; g -&gt; r -&gt; qfun -&gt; qfun'</li><li class="src short"><a href="#v:run_generic_trace_io">run_generic_trace_io</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qa) (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a> &#91;<a href="QuipperLib-Simulation.html#t:QuantumTrace">QuantumTrace</a> r&#93;)) =&gt; r -&gt; qfun -&gt; qfun'</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Vector">Vector</a> n a = <a href="#v:Vector">Vector</a> &#91;(a, n)&#93;</li><li class="src short"><span class="keyword">type</span> <a href="#t:ProbabilityDistribution">ProbabilityDistribution</a> r a = <a href="QuipperLib-Simulation.html#t:Vector">Vector</a> r a</li><li class="src short"><a href="#v:sim_generic">sim_generic</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qa) (<a href="QuipperLib-Simulation.html#t:ProbabilityDistribution">ProbabilityDistribution</a> r (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)))) =&gt; r -&gt; qfun -&gt; qfun'</li></ul></div><div id="interface"><h1 id="g:1">Classical simulation
</h1><div class="top"><p class="src"><a name="v:run_classical_generic" class="def">run_classical_generic</a> :: (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> fun (<a href="Quipper-QData.html#t:BType">BType</a> qa) (<a href="Quipper-QData.html#t:BType">BType</a> qb)) =&gt; qfun -&gt; fun<a href="src/QuipperLib/Simulation/ClassicalSimulation.html#line-205" class="link">Source</a></p><div class="doc"><p>Boolean simulation of a circuit, for testing and debugging
 purposes. Input a classical circuit, and output the corresponding
 boolean function. This will fail with an error if the circuit
 contains a gate not acting within the computational basis, or if
 some assertion is not met.
</p><p>Unlike <code><a href="QuipperLib-Simulation-ClassicalSimulation.html#v:run_classical_unary">run_classical_unary</a></code>, this can be applied to a
 circuit-generating function in curried form with <em>n</em> arguments, for
 any <em>n</em> &#8805; 0. The resulting boolean function then will also have <em>n</em> arguments. 
</p><p>The type of this heavily overloaded function is difficult to
 read. In more readable form, it has all of the following types:
</p><pre> run_classical_generic :: (QCData qa) =&gt; Circ qa -&gt; BType qa
 run_classical_generic :: (QCData qa, QCData qb) =&gt; (qa -&gt; Circ qb) -&gt; BType qa -&gt; BType qb
 run_classical_generic :: (QCData qa, QCData qb, QCData qc) =&gt; (qa -&gt; qb -&gt; Circ qc) -&gt; BType qa -&gt; BType qb -&gt; BType qc
</pre><p>and so forth.
</p></div></div><h1 id="g:2">Stabilizer simulation
</h1><div class="top"><p class="src"><a name="v:run_clifford_generic" class="def">run_clifford_generic</a> :: (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:BType">BType</a> qa) (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a> (<a href="Quipper-QData.html#t:BType">BType</a> qb))) =&gt; qfun -&gt; qfun'<a href="src/QuipperLib/Simulation/CliffordSimulation.html#line-251" class="link">Source</a></p><div class="doc"><p>Efficiently simulate a Quipper circuit that consists entirely of
 Clifford group operators, using the stabilizer formalism.  
</p><p>Inputs a quantum circuit, and outputs a corresponding probabilistic
 boolean function. The inputs to the quantum circuit are initialized
 according to the given boolean arguments. The outputs of the
 quantum circuit are measured, and the boolean measurement outcomes
 are returned. Because the measurement outcomes are probabilistic,
 this function takes place in the <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a></code> monad.
</p><p>The type of this heavily overloaded function is difficult to
 read. In more readable form, it has all of the following types (for
 example):
</p><pre> run_clifford_generic :: (QCData qa) =&gt; Circ qa -&gt; IO (BType qa)
 run_clifford_generic :: (QCData qa, QCData qb) =&gt; (qa -&gt; Circ qb) -&gt; BType qa -&gt; IO (BType qb)
 run_clifford_generic :: (QCData qa, QCData qb, QCData qc) =&gt; (qa -&gt; qb -&gt; Circ qc) -&gt; BType qa -&gt; BType qb -&gt; IO (BType qc)
</pre><p>and so forth.
</p></div></div><h1 id="g:3">Quantum simulation
</h1><div class="top"><p class="src"><a name="v:run_generic" class="def">run_generic</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qa) (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb))) =&gt; g -&gt; r -&gt; qfun -&gt; qfun'<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-770" class="link">Source</a></p><div class="doc"><p>Quantum simulation of a circuit, for testing and debugging
 purposes. Input a source of randomness, a real number, and a
 quantum circuit. Output a corresponding probabilistic boolean
 function.
</p><p>The inputs to the quantum circuit are initialized according to the
 given boolean arguments. The outputs of the quantum circuit are
 measured, and the boolean measurement outcomes are
 returned. 
</p><p>The real number argument is a dummy and is never evaluated; its
 only purpose is to specify the <em>type</em> of real numbers that will be
 used during the simulation.
</p><p>The type of this heavily overloaded function is difficult to
 read. In more readable form, it has all of the following types (for
 example):
</p><pre> run_generic :: (Floating r, Random r, Ord r, RandomGen g, QCData qa) =&gt; g -&gt; r -&gt; Circ qa -&gt; BType qa
 run_generic :: (Floating r, Random r, Ord r, RandomGen g, QCData qa, QCData qb) =&gt; g -&gt; r -&gt; (qa -&gt; Circ qb) -&gt; BType qa -&gt; BType qb
 run_generic :: (Floating r, Random r, Ord r, RandomGen g, QCData qa, QCData qb, QCData qc) =&gt; g -&gt; r -&gt; (qa -&gt; qb -&gt; Circ qc) -&gt; BType qa -&gt; BType qb -&gt; BType qc
</pre><p>and so forth.
</p></div></div><div class="top"><p class="src"><a name="v:run_generic_io" class="def">run_generic_io</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qa) (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)))) =&gt; r -&gt; qfun -&gt; qfun'<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-790" class="link">Source</a></p><div class="doc"><p>Like <code><a href="QuipperLib-Simulation.html#v:run_generic">run_generic</a></code>, but run in the <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a></code> monad instead of passing
 an explicit source of randomness.
</p></div></div><div class="top"><p class="src"><a name="v:sim_amps" class="def">sim_amps</a> :: (<a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QData">QData</a> qa, <a href="Quipper-QData.html#t:QData">QData</a> qb, qb ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qb, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> (<a href="Quipper-QData.html#t:BType">BType</a> qb)) =&gt; g -&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> (<a href="Quipper-QData.html#t:BType">BType</a> qa) (Cplx r) -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> (<a href="Quipper-QData.html#t:BType">BType</a> qb) (Cplx r)<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-672" class="link">Source</a></p><div class="doc"><p>Input a source of randomness, a quantum circuit, and an initial
 state (represented as a map from basis vectors to amplitudes).
 Simulate the circuit and return the final state. If the circuit
 includes measurements, the simulation will be probabilistic.
</p><p>The type of this heavily overloaded function is difficult to
 read. It has, for example, the following types:
</p><pre> sim_amps :: StdGen -&gt; (Qubit -&gt; Circ Qubit) -&gt; Map Bool (Cplx Double) -&gt; Map Bool (Cplx Double)
 sim_amps :: StdGen -&gt; ((Qubit,Qubit) -&gt; Circ Qubit) -&gt; Map (Bool,Bool) (Cplx Double) -&gt; Map Bool (Cplx Double)
</pre><p>and so forth. Note that instead of <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a></code>, another real number
 type, such as <code>FixedPrec</code> <em>e</em>, can be used.
</p></div></div><h1 id="g:4">Special purpose functions
</h1><h2 id="g:5">Simulation with trace
</h2><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:QuantumTrace" class="def">QuantumTrace</a> r = <a href="QuipperLib-Simulation.html#t:ProbabilityDistribution">ProbabilityDistribution</a> r &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>&#93;<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-186" class="link">Source</a></p><div class="doc"><p>A QuantumTrace is essentially a probability distribution for the current state
 of the qubits that have been traced. We can represent this using a Vector. The
 list of Booleans is in the same order as the list of Qubits that was being 
 traced.
</p></div></div><div class="top"><p class="src"><a name="v:run_generic_trace" class="def">run_generic_trace</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qa) &#91;<a href="QuipperLib-Simulation.html#t:QuantumTrace">QuantumTrace</a> r&#93;) =&gt; g -&gt; r -&gt; qfun -&gt; qfun'<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-780" class="link">Source</a></p><div class="doc"><p>Like <code><a href="QuipperLib-Simulation.html#v:run_generic">run_generic</a></code>, but also output a trace of the states of the
 given list of qubits at each step during the evaluation.
</p></div></div><div class="top"><p class="src"><a name="v:run_generic_trace_io" class="def">run_generic_trace_io</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:Random">Random</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qa) (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a> &#91;<a href="QuipperLib-Simulation.html#t:QuantumTrace">QuantumTrace</a> r&#93;)) =&gt; r -&gt; qfun -&gt; qfun'<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-800" class="link">Source</a></p><div class="doc"><p>Like <code><a href="QuipperLib-Simulation.html#v:run_generic_trace">run_generic_trace</a></code>, but run in the <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/System-IO.html#t:IO">IO</a></code> monad instead of
 passing an explicit source of randomness.
</p></div></div><h2 id="g:6">Probability distributions
</h2><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Vector" class="def">Vector</a> n a <a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-174" class="link">Source</a></p><div class="doc"><p>The type of vectors with scalars in <em>n</em> over the basis <em>a</em>. A
 vector is simply a list of pairs. 
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Vector" class="def">Vector</a> &#91;(a, n)&#93;</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Vector" class="caption collapser" onclick="toggleSection('i:Vector')">Instances</p><div id="section.i:Vector" class="show"><table><tr><td class="src">(<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> r) =&gt; <a href="QuipperLib-Simulation-QuantumSimulation.html#t:PMonad">PMonad</a> r (<a href="QuipperLib-Simulation.html#t:Vector">Vector</a> r)</td><td class="doc"><p><code><a href="QuipperLib-Simulation.html#t:ProbabilityDistribution">ProbabilityDistribution</a></code> forms a <code><a href="QuipperLib-Simulation-QuantumSimulation.html#t:PMonad">PMonad</a></code> such that probabilistic results are 
 &quot;merged&quot; by extending the probability distribution by the possible results.
</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a> n =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:Monad">Monad</a> (<a href="QuipperLib-Simulation.html#t:Vector">Vector</a> n)</td><td class="doc"><p>Any numeric indexed vector forms a <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:Monad">Monad</a></code>.
</p></td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a> n =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:Functor">Functor</a> (<a href="QuipperLib-Simulation.html#t:Vector">Vector</a> n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a> n =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html#t:Applicative">Applicative</a> (<a href="QuipperLib-Simulation.html#t:Vector">Vector</a> n)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Show.html#t:Show">Show</a> a, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> a, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a> n, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> n, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Show.html#t:Show">Show</a> n) =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Show.html#t:Show">Show</a> (<a href="QuipperLib-Simulation.html#t:Vector">Vector</a> n a)</td><td class="doc"><p>We can show certain vectors, ignoring any 0 probabilities, and
 combining equal terms.
</p></td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:ProbabilityDistribution" class="def">ProbabilityDistribution</a> r a = <a href="QuipperLib-Simulation.html#t:Vector">Vector</a> r a<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-180" class="link">Source</a></p><div class="doc"><p>A probability distribution gives each element a probability.
</p></div></div><div class="top"><p class="src"><a name="v:sim_generic" class="def">sim_generic</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> r, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> r, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCDataPlus">QCDataPlus</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> qa) (<a href="QuipperLib-Simulation.html#t:ProbabilityDistribution">ProbabilityDistribution</a> r (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a> qb)))) =&gt; r -&gt; qfun -&gt; qfun'<a href="src/QuipperLib/Simulation/QuantumSimulation.html#line-828" class="link">Source</a></p><div class="doc"><p>A generic function to simulate Quipper circuits, via a conversion
 to a <code>SimCircuit</code> returning a probability distribution of the
 possible results.
</p><p>The type of this heavily overloaded function is difficult to
 read. In more readable form, it has all of the following types (for
 example):
</p><pre> sim_generic :: (Floating r, Ord r, QCData qa) =&gt; r -&gt; Circ qa -&gt; ProbabilityDistribution r (BType qa)
 sim_generic :: (Floating r, Ord r, QCData qa, QCData qb) =&gt; r -&gt; (qa -&gt; Circ qb) -&gt; BType qa -&gt; ProbabilityDistribution r (BType qb)
 sim_generic :: (Floating r, Ord r, QCData qa, QCData qb, QCData qc) =&gt; r -&gt; (qa -&gt; qb -&gt; Circ qc) -&gt; BType qa -&gt; BType qb -&gt; ProbabilityDistribution r (BType qc)
</pre><p>and so forth.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>
