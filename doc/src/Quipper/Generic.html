<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>Haskell code</title>
</head>
<body>
<pre><a name="line-1"></a><font color=Blue><i>{-# LANGUAGE TypeSynonymInstances #-}</i></font>
<a name="line-2"></a><font color=Blue><i>{-# LANGUAGE MultiParamTypeClasses #-}</i></font>
<a name="line-3"></a><font color=Blue><i>{-# LANGUAGE FunctionalDependencies #-}</i></font>
<a name="line-4"></a><font color=Blue><i>{-# LANGUAGE UndecidableInstances #-}</i></font>
<a name="line-5"></a><font color=Blue><i>{-# LANGUAGE FlexibleInstances #-}</i></font>
<a name="line-6"></a><font color=Blue><i>{-# LANGUAGE FlexibleContexts #-}</i></font>
<a name="line-7"></a><font color=Blue><i>{-# LANGUAGE ScopedTypeVariables #-}</i></font>
<a name="line-8"></a><font color=Blue><i>{-# LANGUAGE TypeFamilies #-}</i></font>
<a name="line-9"></a><font color=Blue><i>{-# LANGUAGE Rank2Types #-}</i></font> 
<a name="line-10"></a>
<a name="line-11"></a><font color=Blue><i>-- | This module provides functions and operators that are \"generic\"</i></font>
<a name="line-12"></a><font color=Blue><i>-- on quantum data. We say that a function is generic if it works at</i></font>
<a name="line-13"></a><font color=Blue><i>-- any quantum data type, rather than just a specific type such as</i></font>
<a name="line-14"></a><font color=Blue><i>-- 'Qubit'. For example, the generic function 'qinit' can be used to</i></font>
<a name="line-15"></a><font color=Blue><i>-- initialize a qubit from a boolean, or a pair of qubits from a pair</i></font>
<a name="line-16"></a><font color=Blue><i>-- of booleans, or a list of qubits from a list of booleans, and so</i></font>
<a name="line-17"></a><font color=Blue><i>-- forth.</i></font>
<a name="line-18"></a><font color=Blue><i>-- </i></font>
<a name="line-19"></a><font color=Blue><i>-- Some functions are also generic in the /number/ of arguments they</i></font>
<a name="line-20"></a><font color=Blue><i>-- take, in addition to the type of the arguments. </i></font>
<a name="line-21"></a>
<a name="line-22"></a><font color=Green><u>module</u></font> Quipper<font color=Cyan>.</font>Generic <font color=Cyan>(</font>
<a name="line-23"></a>  <font color=Blue><i>-- * Generic gates</i></font>
<a name="line-24"></a>  <font color=Blue><i>-- ** Initialization and termination</i></font>
<a name="line-25"></a>  qinit<font color=Cyan>,</font>
<a name="line-26"></a>  qterm<font color=Cyan>,</font>
<a name="line-27"></a>  qdiscard<font color=Cyan>,</font>
<a name="line-28"></a>  cinit<font color=Cyan>,</font>
<a name="line-29"></a>  cterm<font color=Cyan>,</font>
<a name="line-30"></a>  cdiscard<font color=Cyan>,</font>
<a name="line-31"></a>  qc_init<font color=Cyan>,</font>
<a name="line-32"></a>  qc_init_with_shape<font color=Cyan>,</font>
<a name="line-33"></a>  qc_term<font color=Cyan>,</font>
<a name="line-34"></a>  qc_discard<font color=Cyan>,</font>
<a name="line-35"></a>  <font color=Blue><i>-- ** Measurement and preparation</i></font>
<a name="line-36"></a>  measure<font color=Cyan>,</font>
<a name="line-37"></a>  prepare<font color=Cyan>,</font>
<a name="line-38"></a>  qc_measure<font color=Cyan>,</font>
<a name="line-39"></a>  qc_prepare<font color=Cyan>,</font>
<a name="line-40"></a>  <font color=Blue><i>-- ** Global phase gate</i></font>
<a name="line-41"></a>  global_phase_anchored<font color=Cyan>,</font>
<a name="line-42"></a>  <font color=Blue><i>-- ** Mapped gates</i></font>
<a name="line-43"></a>  map_hadamard<font color=Cyan>,</font>
<a name="line-44"></a>  map_hadamard_at<font color=Cyan>,</font>
<a name="line-45"></a>  swap<font color=Cyan>,</font>
<a name="line-46"></a>  swap_at<font color=Cyan>,</font>
<a name="line-47"></a>  controlled_not<font color=Cyan>,</font>  
<a name="line-48"></a>  controlled_not_at<font color=Cyan>,</font>
<a name="line-49"></a>  bool_controlled_not<font color=Cyan>,</font>
<a name="line-50"></a>  bool_controlled_not_at<font color=Cyan>,</font>
<a name="line-51"></a>  qmultinot<font color=Cyan>,</font>
<a name="line-52"></a>  qmultinot_at<font color=Cyan>,</font>
<a name="line-53"></a>  <font color=Blue><i>-- ** Copying and uncopying</i></font>
<a name="line-54"></a>  qc_copy_fun<font color=Cyan>,</font>
<a name="line-55"></a>  qc_uncopy_fun<font color=Cyan>,</font>
<a name="line-56"></a>  qc_copy<font color=Cyan>,</font>
<a name="line-57"></a>  qc_uncopy<font color=Cyan>,</font>
<a name="line-58"></a>  <font color=Blue><i>-- ** Classical gates</i></font>
<a name="line-59"></a>  cgate_if<font color=Cyan>,</font>
<a name="line-60"></a>  circ_if<font color=Cyan>,</font>
<a name="line-61"></a>  <font color=Blue><i>-- ** Named gates</i></font>
<a name="line-62"></a>  named_gate<font color=Cyan>,</font>
<a name="line-63"></a>  named_gate_at<font color=Cyan>,</font>
<a name="line-64"></a>  named_rotation<font color=Cyan>,</font>
<a name="line-65"></a>  named_rotation_at<font color=Cyan>,</font>
<a name="line-66"></a>  extended_named_gate<font color=Cyan>,</font>
<a name="line-67"></a>  extended_named_gate_at<font color=Cyan>,</font>
<a name="line-68"></a>  <font color=Blue><i>-- ** Dynamic lifting</i></font>
<a name="line-69"></a>  dynamic_lift<font color=Cyan>,</font>
<a name="line-70"></a>  
<a name="line-71"></a>  <font color=Blue><i>-- * Mapping</i></font>
<a name="line-72"></a>  mapUnary<font color=Cyan>,</font>
<a name="line-73"></a>  mapBinary<font color=Cyan>,</font>
<a name="line-74"></a>  mapBinary_c<font color=Cyan>,</font>
<a name="line-75"></a>  map2Q<font color=Cyan>,</font>
<a name="line-76"></a>  qc_mapBinary<font color=Cyan>,</font>
<a name="line-77"></a>
<a name="line-78"></a>  <font color=Blue><i>-- * Conversion to lists</i></font>
<a name="line-79"></a>  <font color=Blue><i>-- $CONVERSION</i></font>
<a name="line-80"></a>  qubits_of_qdata<font color=Cyan>,</font>
<a name="line-81"></a>  qdata_of_qubits<font color=Cyan>,</font>
<a name="line-82"></a>  endpoints_of_qcdata<font color=Cyan>,</font>
<a name="line-83"></a>  qcdata_of_endpoints<font color=Cyan>,</font>
<a name="line-84"></a>  
<a name="line-85"></a>  <font color=Blue><i>-- * Shape related operations</i></font>
<a name="line-86"></a>  qc_false<font color=Cyan>,</font>
<a name="line-87"></a>  qshape<font color=Cyan>,</font>
<a name="line-88"></a>  
<a name="line-89"></a>  <font color=Blue><i>-- * Bindings</i></font>
<a name="line-90"></a>  qc_bind<font color=Cyan>,</font>
<a name="line-91"></a>  qc_unbind<font color=Cyan>,</font>
<a name="line-92"></a>  
<a name="line-93"></a>  <font color=Blue><i>-- * Generic controls</i></font>
<a name="line-94"></a>  <font color=Blue><i>-- $CONTROL</i></font>
<a name="line-95"></a>  <font color=Cyan>(</font><font color=Cyan>.&amp;&amp;.</font><font color=Cyan>)</font><font color=Cyan>,</font>
<a name="line-96"></a>  <font color=Cyan>(</font><font color=Cyan>.==.</font><font color=Cyan>)</font><font color=Cyan>,</font>
<a name="line-97"></a>  <font color=Cyan>(</font><font color=Cyan>./=.</font><font color=Cyan>)</font><font color=Cyan>,</font>
<a name="line-98"></a>  <font color=Blue><i>-- * Generic encapsulation</i></font>
<a name="line-99"></a>  <font color=Blue><i>-- $encapsulate</i></font>
<a name="line-100"></a>  encapsulate_generic<font color=Cyan>,</font>
<a name="line-101"></a>  encapsulate_generic_in_namespace<font color=Cyan>,</font>
<a name="line-102"></a>  unencapsulate_generic<font color=Cyan>,</font>
<a name="line-103"></a>  <font color=Blue><i>-- $dynamic_encapsulate</i></font>
<a name="line-104"></a>  encapsulate_dynamic<font color=Cyan>,</font>
<a name="line-105"></a>  unencapsulate_dynamic<font color=Cyan>,</font>
<a name="line-106"></a>  <font color=Blue><i>-- * Generic reversing</i></font>
<a name="line-107"></a>  reverse_generic<font color=Cyan>,</font>
<a name="line-108"></a>  reverse_generic_curried<font color=Cyan>,</font>
<a name="line-109"></a>  reverse_simple<font color=Cyan>,</font>
<a name="line-110"></a>  reverse_simple_curried<font color=Cyan>,</font>
<a name="line-111"></a>  reverse_generic_endo<font color=Cyan>,</font>
<a name="line-112"></a>  reverse_generic_imp<font color=Cyan>,</font>
<a name="line-113"></a>  reverse_endo_if<font color=Cyan>,</font>
<a name="line-114"></a>  reverse_imp_if<font color=Cyan>,</font>
<a name="line-115"></a>  <font color=Blue><i>-- * The QCurry type class</i></font>
<a name="line-116"></a>  QCurry <font color=Cyan>(</font><font color=Red>..</font><font color=Cyan>)</font><font color=Cyan>,</font>
<a name="line-117"></a>  <font color=Blue><i>-- * Generic circuit transformations</i></font>
<a name="line-118"></a>  transform_unary_dynamic_shape<font color=Cyan>,</font>
<a name="line-119"></a>  transform_unary_dynamic<font color=Cyan>,</font>
<a name="line-120"></a>  transform_unary<font color=Cyan>,</font>
<a name="line-121"></a>  transform_generic<font color=Cyan>,</font>
<a name="line-122"></a>  transform_unary_shape<font color=Cyan>,</font>
<a name="line-123"></a>  transform_generic_shape<font color=Cyan>,</font>
<a name="line-124"></a>  <font color=Blue><i>-- * Generic block structure</i></font>
<a name="line-125"></a>  with_ancilla_init<font color=Cyan>,</font>
<a name="line-126"></a>  with_ancilla_list<font color=Cyan>,</font>
<a name="line-127"></a>  with_computed_fun<font color=Cyan>,</font>
<a name="line-128"></a>  with_computed<font color=Cyan>,</font>
<a name="line-129"></a>  with_basis_change<font color=Cyan>,</font>
<a name="line-130"></a>  with_classical_control<font color=Cyan>,</font>
<a name="line-131"></a>  <font color=Blue><i>-- * Boxed subcircuits</i></font>
<a name="line-132"></a>  provide_subroutine_generic<font color=Cyan>,</font>
<a name="line-133"></a>  box<font color=Cyan>,</font>
<a name="line-134"></a>  nbox<font color=Cyan>,</font>
<a name="line-135"></a>  box_loopM<font color=Cyan>,</font>
<a name="line-136"></a>  loopM_boxed_if<font color=Cyan>,</font>
<a name="line-137"></a>  inline_subroutine
<a name="line-138"></a>  <font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-139"></a>
<a name="line-140"></a><font color=Blue><i>-- import other Quipper stuff</i></font>
<a name="line-141"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>Circuit
<a name="line-142"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>Monad
<a name="line-143"></a><font color=Green><u>import</u></font> Libraries<font color=Cyan>.</font>Auxiliary
<a name="line-144"></a><font color=Green><u>import</u></font> Libraries<font color=Cyan>.</font>Tuple
<a name="line-145"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>Transformer
<a name="line-146"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>Control
<a name="line-147"></a><font color=Green><u>import</u></font> Quipper<font color=Cyan>.</font>QData
<a name="line-148"></a>
<a name="line-149"></a><font color=Blue><i>-- import other stuff</i></font>
<a name="line-150"></a><font color=Green><u>import</u></font> Control<font color=Cyan>.</font>Monad
<a name="line-151"></a><font color=Green><u>import</u></font> Prelude
<a name="line-152"></a><font color=Green><u>import</u></font> Data<font color=Cyan>.</font>Typeable
<a name="line-153"></a><font color=Green><u>import</u></font> <font color=Green><u>qualified</u></font> Control<font color=Cyan>.</font>Monad<font color=Cyan>.</font>State <font color=Green><u>as</u></font> State
<a name="line-154"></a>
<a name="line-155"></a><font color=Green><u>import</u></font> Data<font color=Cyan>.</font>Map <font color=Cyan>(</font>Map<font color=Cyan>)</font>
<a name="line-156"></a><font color=Green><u>import</u></font> <font color=Green><u>qualified</u></font> Data<font color=Cyan>.</font>Map <font color=Green><u>as</u></font> Map
<a name="line-157"></a><font color=Green><u>import</u></font> Data<font color=Cyan>.</font>IntMap <font color=Cyan>(</font>IntMap<font color=Cyan>)</font>
<a name="line-158"></a><font color=Green><u>import</u></font> <font color=Green><u>qualified</u></font> Data<font color=Cyan>.</font>IntMap <font color=Green><u>as</u></font> IntMap
<a name="line-159"></a>
<a name="line-160"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-161"></a><font color=Blue><i>-- * Generic gates</i></font>
<a name="line-162"></a>
<a name="line-163"></a><font color=Blue><i>-- ** Initialization and termination</i></font>
<a name="line-164"></a>
<a name="line-165"></a><a name="qinit"></a><font color=Blue><i>-- | Initialize a qubit from a boolean parameter. More generally,</i></font>
<a name="line-166"></a><font color=Blue><i>-- initialize a data structure of qubits from a corresponding data</i></font>
<a name="line-167"></a><font color=Blue><i>-- structure of boolean parameters. Examples:</i></font>
<a name="line-168"></a><font color=Blue><i>-- </i></font>
<a name="line-169"></a><font color=Blue><i>-- &gt; q &lt;- qinit False</i></font>
<a name="line-170"></a><font color=Blue><i>-- &gt; (q0, q1) &lt;- qinit (True, False)</i></font>
<a name="line-171"></a><font color=Blue><i>-- &gt; [q0, q1, q2] &lt;- qinit [True, False, True]</i></font>
<a name="line-172"></a><font color=Blue>qinit</font> <font color=Red>::</font> <font color=Cyan>(</font>QShape ba qa ca<font color=Cyan>)</font> <font color=Red>=&gt;</font> ba <font color=Red>-&gt;</font> Circ qa
<a name="line-173"></a><font color=Blue>qinit</font> ba <font color=Red>=</font> qdata_mapM <font color=Cyan>(</font>shapetype_b ba<font color=Cyan>)</font> qinit_qubit ba
<a name="line-174"></a>
<a name="line-175"></a><a name="qterm"></a><font color=Blue><i>-- | Terminate a qubit, asserting its state to equal the boolean</i></font>
<a name="line-176"></a><font color=Blue><i>-- parameter. More generally, terminate a data structure of qubits,</i></font>
<a name="line-177"></a><font color=Blue><i>-- asserting that their state is as given by a data structure of</i></font>
<a name="line-178"></a><font color=Blue><i>-- booleans parameters. Examples:</i></font>
<a name="line-179"></a><font color=Blue><i>-- </i></font>
<a name="line-180"></a><font color=Blue><i>-- &gt; qterm False q</i></font>
<a name="line-181"></a><font color=Blue><i>-- &gt; qterm (False, False) (q0, q1)</i></font>
<a name="line-182"></a><font color=Blue><i>-- &gt; qterm [False, False, False] [q0, q1, q2]</i></font>
<a name="line-183"></a><font color=Blue><i>-- </i></font>
<a name="line-184"></a><font color=Blue><i>-- In some cases, it is permissible for some aspect of the parameter's</i></font>
<a name="line-185"></a><font color=Blue><i>-- shape to be underspecified, e.g., a longer than necessary list, or</i></font>
<a name="line-186"></a><font color=Blue><i>-- an integer of indeterminate length. It is therefore possible, for</i></font>
<a name="line-187"></a><font color=Blue><i>-- example, to write:</i></font>
<a name="line-188"></a><font color=Blue><i>-- </i></font>
<a name="line-189"></a><font color=Blue><i>-- &gt; qterm 17 qa          -- when qa :: QDInt,</i></font>
<a name="line-190"></a><font color=Blue><i>-- &gt; qterm [False..] qa   -- when qa :: [Qubit].</i></font>
<a name="line-191"></a><font color=Blue><i>-- </i></font>
<a name="line-192"></a><font color=Blue><i>-- The rules for when a boolean argument can be \"promoted\" in this</i></font>
<a name="line-193"></a><font color=Blue><i>-- way are specific to each individual data type.</i></font>
<a name="line-194"></a><font color=Blue>qterm</font> <font color=Red>::</font> <font color=Cyan>(</font>QShape ba qa ca<font color=Cyan>)</font> <font color=Red>=&gt;</font> ba <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> Circ ()
<a name="line-195"></a><font color=Blue>qterm</font> ba qa <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-196"></a>  <font color=Green><u>let</u></font> shape <font color=Red>=</font> shapetype_b ba                  <font color=Blue><i>-- shape type  </i></font>
<a name="line-197"></a>  <font color=Green><u>let</u></font> ba' <font color=Red>=</font> qdata_promote ba qa errmsg  <font color=Blue><i>-- shape data</i></font>
<a name="line-198"></a>  <font color=Green><u>let</u></font> z <font color=Red>=</font> qdata_zip shape bool qubit ba' qa errmsg
<a name="line-199"></a>  qdata_mapM_op shape <font color=Cyan>(</font><font color=Red>\</font><font color=Cyan>(</font>x<font color=Cyan>,</font>y<font color=Cyan>)</font> <font color=Red>-&gt;</font> qterm_qubit x y<font color=Cyan>)</font> z
<a name="line-200"></a>  return ()
<a name="line-201"></a>  <font color=Green><u>where</u></font>
<a name="line-202"></a>    errmsg s <font color=Red>=</font> <font color=Magenta>"qterm: shape of parameter does not match data: "</font> <font color=Cyan>++</font> s
<a name="line-203"></a>
<a name="line-204"></a><a name="qdiscard"></a><font color=Blue><i>-- | Discard a qubit, ignoring its state. This can leave the quantum</i></font>
<a name="line-205"></a><font color=Blue><i>-- system in a mixed state, so is not a reversible operation. More</i></font>
<a name="line-206"></a><font color=Blue><i>-- generally, discard all the qubits in a quantum data</i></font>
<a name="line-207"></a><font color=Blue><i>-- structure. Examples:</i></font>
<a name="line-208"></a><font color=Blue><i>-- </i></font>
<a name="line-209"></a><font color=Blue><i>-- &gt; qdiscard q</i></font>
<a name="line-210"></a><font color=Blue><i>-- &gt; qdiscard (q0, q1)</i></font>
<a name="line-211"></a><font color=Blue><i>-- &gt; qdiscard [q0, q1, q2]</i></font>
<a name="line-212"></a><font color=Blue>qdiscard</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> qa <font color=Red>-&gt;</font> Circ ()
<a name="line-213"></a><font color=Blue>qdiscard</font> qa <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-214"></a>  qdata_mapM_op <font color=Cyan>(</font>shapetype_q qa<font color=Cyan>)</font> qdiscard_qubit qa
<a name="line-215"></a>  return ()
<a name="line-216"></a>  
<a name="line-217"></a><a name="cinit"></a><font color=Blue><i>-- | Initialize a 'Bit' (boolean input) from a 'Bool' (boolean</i></font>
<a name="line-218"></a><font color=Blue><i>-- parameter). More generally, initialize the a data structure of Bits</i></font>
<a name="line-219"></a><font color=Blue><i>-- from a corresponding data structure of Bools. Examples:</i></font>
<a name="line-220"></a><font color=Blue><i>-- </i></font>
<a name="line-221"></a><font color=Blue><i>-- &gt; b &lt;- cinit False</i></font>
<a name="line-222"></a><font color=Blue><i>-- &gt; (b0, b1) &lt;- cinit (True, False)</i></font>
<a name="line-223"></a><font color=Blue><i>-- &gt; [b0, b1, b2] &lt;- cinit [True, False, True]</i></font>
<a name="line-224"></a><font color=Blue>cinit</font> <font color=Red>::</font> <font color=Cyan>(</font>QShape ba qa ca<font color=Cyan>)</font> <font color=Red>=&gt;</font> ba <font color=Red>-&gt;</font> Circ ca
<a name="line-225"></a><font color=Blue>cinit</font> ba <font color=Red>=</font> qdata_mapM <font color=Cyan>(</font>shapetype_b ba<font color=Cyan>)</font> cinit_bit ba
<a name="line-226"></a>
<a name="line-227"></a><a name="cterm"></a><font color=Blue><i>-- | Terminate a 'Bit', asserting its state to equal the given</i></font>
<a name="line-228"></a><font color=Blue><i>-- 'Bool'. More generally, terminate a data structure of Bits,</i></font>
<a name="line-229"></a><font color=Blue><i>-- asserting that their state is as given by a data structure of</i></font>
<a name="line-230"></a><font color=Blue><i>-- Bools. Examples:</i></font>
<a name="line-231"></a><font color=Blue><i>-- </i></font>
<a name="line-232"></a><font color=Blue><i>-- &gt; cterm False b</i></font>
<a name="line-233"></a><font color=Blue><i>-- &gt; cterm (False, False) (b0, b1)</i></font>
<a name="line-234"></a><font color=Blue><i>-- &gt; cterm [False, False, False] [b0, b1, b2]</i></font>
<a name="line-235"></a><font color=Blue><i>-- </i></font>
<a name="line-236"></a><font color=Blue><i>-- In some cases, it is permissible for some aspect of the parameter's</i></font>
<a name="line-237"></a><font color=Blue><i>-- shape to be underspecified, e.g., a longer than necessary list, or</i></font>
<a name="line-238"></a><font color=Blue><i>-- an integer of indeterminate length. It is therefore possible, for</i></font>
<a name="line-239"></a><font color=Blue><i>-- example, to write:</i></font>
<a name="line-240"></a><font color=Blue><i>-- </i></font>
<a name="line-241"></a><font color=Blue><i>-- &gt; cterm 17 ca          -- when ca :: CInt,</i></font>
<a name="line-242"></a><font color=Blue><i>-- &gt; cterm [False..] ca   -- when ca :: [Bit].</i></font>
<a name="line-243"></a><font color=Blue><i>-- </i></font>
<a name="line-244"></a><font color=Blue><i>-- The rules for when a boolean argument can be \"promoted\" in this</i></font>
<a name="line-245"></a><font color=Blue><i>-- way are specific to each individual data type.</i></font>
<a name="line-246"></a><font color=Blue>cterm</font> <font color=Red>::</font> <font color=Cyan>(</font>QShape ba qa ca<font color=Cyan>)</font> <font color=Red>=&gt;</font> ba <font color=Red>-&gt;</font> ca <font color=Red>-&gt;</font> Circ ()
<a name="line-247"></a><font color=Blue>cterm</font> ba ca <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-248"></a>  <font color=Blue><i>-- shape type</i></font>
<a name="line-249"></a>  <font color=Green><u>let</u></font> shape <font color=Red>=</font> shapetype_b ba
<a name="line-250"></a>  <font color=Blue><i>-- shape data</i></font>
<a name="line-251"></a>  <font color=Green><u>let</u></font> ba' <font color=Red>=</font> qdata_promote_c ba ca errmsg
<a name="line-252"></a>  <font color=Green><u>let</u></font> z <font color=Red>=</font> qdata_zip shape bool bit ba' ca errmsg
<a name="line-253"></a>  qdata_mapM_op shape <font color=Cyan>(</font><font color=Red>\</font><font color=Cyan>(</font>x<font color=Cyan>,</font>y<font color=Cyan>)</font> <font color=Red>-&gt;</font> cterm_bit x y<font color=Cyan>)</font> z
<a name="line-254"></a>  return ()
<a name="line-255"></a>  <font color=Green><u>where</u></font>
<a name="line-256"></a>    errmsg s <font color=Red>=</font> <font color=Magenta>"cterm: shape of parameter does not match data: "</font> <font color=Cyan>++</font> s
<a name="line-257"></a>
<a name="line-258"></a><a name="cdiscard"></a><font color=Blue><i>-- | Discard a 'Bit', ignoring its state. This can leave the system in</i></font>
<a name="line-259"></a><font color=Blue><i>-- a mixed state, so is not a reversible operation. More generally,</i></font>
<a name="line-260"></a><font color=Blue><i>-- discard all the Bits in a data structure. Examples:</i></font>
<a name="line-261"></a><font color=Blue><i>-- </i></font>
<a name="line-262"></a><font color=Blue><i>-- &gt; cdiscard b</i></font>
<a name="line-263"></a><font color=Blue><i>-- &gt; cdiscard (b0, b1)</i></font>
<a name="line-264"></a><font color=Blue><i>-- &gt; cdiscard [b0, b1, b2]</i></font>
<a name="line-265"></a><font color=Blue>cdiscard</font> <font color=Red>::</font> <font color=Cyan>(</font>CData ca<font color=Cyan>)</font> <font color=Red>=&gt;</font> ca <font color=Red>-&gt;</font> Circ ()
<a name="line-266"></a><font color=Blue>cdiscard</font> ca <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-267"></a>  qdata_mapM_op <font color=Cyan>(</font>shapetype_c ca<font color=Cyan>)</font> cdiscard_bit ca
<a name="line-268"></a>  return ()
<a name="line-269"></a>
<a name="line-270"></a><a name="qc_init"></a><font color=Blue><i>-- | Heterogeneous version of 'qinit'. Please note that the type of</i></font>
<a name="line-271"></a><font color=Blue><i>-- the result of this function cannot be inferred from the type of the</i></font>
<a name="line-272"></a><font color=Blue><i>-- argument. For example, </i></font>
<a name="line-273"></a><font color=Blue><i>-- </i></font>
<a name="line-274"></a><font color=Blue><i>-- &gt; x &lt;- qc_init False</i></font>
<a name="line-275"></a><font color=Blue><i>-- </i></font>
<a name="line-276"></a><font color=Blue><i>-- is ambiguous, unless it can be inferred from the context whether</i></font>
<a name="line-277"></a><font color=Blue><i>-- /x/ is a 'Bit' or a 'Qubit'. If the type cannot be inferred from</i></font>
<a name="line-278"></a><font color=Blue><i>-- the context, it needs to be stated explicitly, like this:</i></font>
<a name="line-279"></a><font color=Blue><i>-- </i></font>
<a name="line-280"></a><font color=Blue><i>-- &gt; x &lt;- qc_init False :: Circ Qubit</i></font>
<a name="line-281"></a><font color=Blue><i>--    </i></font>
<a name="line-282"></a><font color=Blue><i>-- Alternatively, 'qc_init_with_shape' can be used to fix a specific</i></font>
<a name="line-283"></a><font color=Blue><i>-- type.</i></font>
<a name="line-284"></a><font color=Blue>qc_init</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> BType qc <font color=Red>-&gt;</font> Circ qc
<a name="line-285"></a><font color=Blue>qc_init</font> bs <font color=Red>=</font> qc_init_with_shape <font color=Cyan>(</font>undefined <font color=Red>::</font> qc<font color=Cyan>)</font> bs
<a name="line-286"></a>
<a name="line-287"></a><a name="qc_init_with_shape"></a><font color=Blue><i>-- | A version of 'qc_init' that uses a shape type parameter. The</i></font>
<a name="line-288"></a><font color=Blue><i>-- first argument is the shape type parameter, and the second argument</i></font>
<a name="line-289"></a><font color=Blue><i>-- is a data structure containing boolean initializers. The shape type</i></font>
<a name="line-290"></a><font color=Blue><i>-- argument determines which booleans are used to initialize qubits,</i></font>
<a name="line-291"></a><font color=Blue><i>-- and which ones are used to initialize classical bits.</i></font>
<a name="line-292"></a><font color=Blue><i>-- </i></font>
<a name="line-293"></a><font color=Blue><i>-- Example:</i></font>
<a name="line-294"></a><font color=Blue><i>-- </i></font>
<a name="line-295"></a><font color=Blue><i>-- &gt; (x,y) &lt;- qc_init_with_shape (bit,[qubit]) (True, [False,True])</i></font>
<a name="line-296"></a><font color=Blue><i>-- </i></font>
<a name="line-297"></a><font color=Blue><i>-- This will assign to /x/ a classical bit initialized to 1, and to</i></font>
<a name="line-298"></a><font color=Blue><i>-- /y/ a list of two qubits initialized to |0&#9002; and |1&#9002;, respectively.</i></font>
<a name="line-299"></a><font color=Blue>qc_init_with_shape</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> BType qc <font color=Red>-&gt;</font> Circ qc
<a name="line-300"></a><font color=Blue>qc_init_with_shape</font> shape bs <font color=Red>=</font> qcdata_mapM shape qinit_qubit cinit_bit bs
<a name="line-301"></a>
<a name="line-302"></a><a name="qc_term"></a><font color=Blue><i>-- | Heterogeneous version of 'qterm'. </i></font>
<a name="line-303"></a><font color=Blue>qc_term</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> BType qc <font color=Red>-&gt;</font> qc <font color=Red>-&gt;</font> Circ ()
<a name="line-304"></a><font color=Blue>qc_term</font> bs qc <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-305"></a>  <font color=Green><u>let</u></font> bs' <font color=Red>=</font> qcdata_promote bs qc errmsg
<a name="line-306"></a>  <font color=Green><u>let</u></font> z <font color=Red>=</font> qcdata_zip qc bool bool qubit bit bs' qc errmsg
<a name="line-307"></a>  qcdata_mapM_op qc map_qubit map_bit z 
<a name="line-308"></a>  return ()
<a name="line-309"></a>  <font color=Green><u>where</u></font>    
<a name="line-310"></a>    
<a name="line-311"></a>    map_qubit <font color=Red>::</font> <font color=Cyan>(</font>Bool<font color=Cyan>,</font> Qubit<font color=Cyan>)</font> <font color=Red>-&gt;</font> Circ ()
<a name="line-312"></a>    map_qubit <font color=Cyan>(</font>b<font color=Cyan>,</font>q<font color=Cyan>)</font> <font color=Red>=</font> qterm_qubit b q
<a name="line-313"></a>
<a name="line-314"></a>    map_bit <font color=Red>::</font> <font color=Cyan>(</font>Bool<font color=Cyan>,</font> Bit<font color=Cyan>)</font> <font color=Red>-&gt;</font> Circ ()
<a name="line-315"></a>    map_bit <font color=Cyan>(</font>b<font color=Cyan>,</font>q<font color=Cyan>)</font> <font color=Red>=</font> cterm_bit b q
<a name="line-316"></a>
<a name="line-317"></a>    errmsg s <font color=Red>=</font> <font color=Magenta>"qc_term: shape of parameter does not match data: "</font> <font color=Cyan>++</font> s
<a name="line-318"></a>
<a name="line-319"></a><a name="qc_discard"></a><font color=Blue><i>-- | Heterogeneous version of 'qdiscard'.</i></font>
<a name="line-320"></a><font color=Blue>qc_discard</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> Circ ()
<a name="line-321"></a><font color=Blue>qc_discard</font> qc <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-322"></a>  qcdata_mapM_op qc qdiscard_qubit cdiscard_bit qc
<a name="line-323"></a>  return ()
<a name="line-324"></a>
<a name="line-325"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-326"></a><font color=Blue><i>-- ** Measurement and preparation</i></font>
<a name="line-327"></a>
<a name="line-328"></a><a name="measure"></a><font color=Blue><i>-- | Measure a 'Qubit', resulting in a 'Bit'. More generally, measure</i></font>
<a name="line-329"></a><font color=Blue><i>-- all the Qubits in a quantum data structure, resulting in a</i></font>
<a name="line-330"></a><font color=Blue><i>-- corresponding data structure of Bits. This is not a reversible</i></font>
<a name="line-331"></a><font color=Blue><i>-- operation. Examples:</i></font>
<a name="line-332"></a><font color=Blue><i>-- </i></font>
<a name="line-333"></a><font color=Blue><i>-- &gt; b &lt;- measure q</i></font>
<a name="line-334"></a><font color=Blue><i>-- &gt; (b0, b1) &lt;- measure (q0, q1)</i></font>
<a name="line-335"></a><font color=Blue><i>-- &gt; [b0, b1, b2] &lt;- measure [q0, q1, q2]</i></font>
<a name="line-336"></a><font color=Blue>measure</font> <font color=Red>::</font> <font color=Cyan>(</font>QShape ba qa ca<font color=Cyan>)</font> <font color=Red>=&gt;</font> qa <font color=Red>-&gt;</font> Circ ca
<a name="line-337"></a><font color=Blue>measure</font> qa <font color=Red>=</font> qdata_mapM_op <font color=Cyan>(</font>shapetype_q qa<font color=Cyan>)</font> measure_qubit qa
<a name="line-338"></a>
<a name="line-339"></a><a name="prepare"></a><font color=Blue><i>-- | Prepare a 'Qubit' initialized from a 'Bit'. More generally,</i></font>
<a name="line-340"></a><font color=Blue><i>-- prepare a data structure of Qubits, initialized from a corresponding</i></font>
<a name="line-341"></a><font color=Blue><i>-- data structure of Bits. Examples:</i></font>
<a name="line-342"></a><font color=Blue><i>-- </i></font>
<a name="line-343"></a><font color=Blue><i>-- &gt; q &lt;- prepare b</i></font>
<a name="line-344"></a><font color=Blue><i>-- &gt; (q0, q1) &lt;- prepare (b0, b1)</i></font>
<a name="line-345"></a><font color=Blue><i>-- &gt; [q0, q1, q2] &lt;- prepare [b0, b1, b2]</i></font>
<a name="line-346"></a><font color=Blue>prepare</font> <font color=Red>::</font> <font color=Cyan>(</font>QShape ba qa ca<font color=Cyan>)</font> <font color=Red>=&gt;</font> ca <font color=Red>-&gt;</font> Circ qa
<a name="line-347"></a><font color=Blue>prepare</font> ca <font color=Red>=</font> qdata_mapM <font color=Cyan>(</font>shapetype_c ca<font color=Cyan>)</font> prepare_qubit ca
<a name="line-348"></a>
<a name="line-349"></a><a name="qc_measure"></a><font color=Blue><i>-- | Heterogeneous version of 'measure'. Given a heterogeneous data</i></font>
<a name="line-350"></a><font color=Blue><i>-- structure, measure all of its qubits, and leave any classical bits</i></font>
<a name="line-351"></a><font color=Blue><i>-- unchanged.</i></font>
<a name="line-352"></a><font color=Blue>qc_measure</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>QCType Bit Bit qc<font color=Cyan>)</font>
<a name="line-353"></a><font color=Blue>qc_measure</font> qc <font color=Red>=</font> qcdata_mapM_op qc measure_qubit do_bit qc 
<a name="line-354"></a>  <font color=Green><u>where</u></font> 
<a name="line-355"></a>    do_bit <font color=Red>::</font> Bit <font color=Red>-&gt;</font> Circ Bit
<a name="line-356"></a>    do_bit <font color=Red>=</font> return                                                         
<a name="line-357"></a>
<a name="line-358"></a><a name="qc_prepare"></a><font color=Blue><i>-- | Heterogeneous version of 'measure'. Given a heterogeneous data</i></font>
<a name="line-359"></a><font color=Blue><i>-- structure, prepare qubits from all classical bits, and leave any</i></font>
<a name="line-360"></a><font color=Blue><i>-- qubits unchanged.</i></font>
<a name="line-361"></a><font color=Blue>qc_prepare</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>QCType Qubit Qubit qc<font color=Cyan>)</font>
<a name="line-362"></a><font color=Blue>qc_prepare</font> qc <font color=Red>=</font> qcdata_mapM qc do_qubit prepare_qubit qc 
<a name="line-363"></a>  <font color=Green><u>where</u></font>
<a name="line-364"></a>    do_qubit <font color=Red>::</font> Qubit <font color=Red>-&gt;</font> Circ Qubit
<a name="line-365"></a>    do_qubit <font color=Red>=</font> return
<a name="line-366"></a>
<a name="line-367"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-368"></a><font color=Blue><i>-- * Global phase gate</i></font>
<a name="line-369"></a>  
<a name="line-370"></a><a name="global_phase_anchored"></a><font color=Blue><i>-- | Like 'global_phase', except the gate is also \"anchored\" at a</i></font>
<a name="line-371"></a><font color=Blue><i>-- qubit, a bit, or more generally at some quantum data. The anchor</i></font>
<a name="line-372"></a><font color=Blue><i>-- is only used as a hint for graphical display. The gate, which is a</i></font>
<a name="line-373"></a><font color=Blue><i>-- zero-qubit gate, will potentially be displayed near the anchor(s).</i></font>
<a name="line-374"></a><font color=Blue>global_phase_anchored</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> Double <font color=Red>-&gt;</font> qc <font color=Red>-&gt;</font> Circ ()
<a name="line-375"></a><font color=Blue>global_phase_anchored</font> t qc <font color=Red>=</font> global_phase_anchored_list t qs <font color=Green><u>where</u></font>
<a name="line-376"></a>  qs <font color=Red>=</font> endpoints_of_qcdata qc
<a name="line-377"></a>
<a name="line-378"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-379"></a><font color=Blue><i>-- * Mapped gates</i></font>
<a name="line-380"></a>
<a name="line-381"></a><a name="map_hadamard"></a><font color=Blue><i>-- | Apply a Hadamard gate to every qubit in a quantum data structure.</i></font>
<a name="line-382"></a><font color=Blue>map_hadamard</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> qa <font color=Red>-&gt;</font> Circ qa
<a name="line-383"></a><font color=Blue>map_hadamard</font> <font color=Red>=</font> mapUnary hadamard
<a name="line-384"></a>
<a name="line-385"></a><a name="map_hadamard_at"></a><font color=Blue><i>-- | Imperative version of 'map_hadamard'.</i></font>
<a name="line-386"></a><font color=Blue>map_hadamard_at</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> qa <font color=Red>-&gt;</font> Circ ()
<a name="line-387"></a><font color=Blue>map_hadamard_at</font> qa <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-388"></a>  map_hadamard qa
<a name="line-389"></a>  return ()
<a name="line-390"></a>
<a name="line-391"></a><a name="swap"></a><font color=Blue><i>-- | Apply a swap gate to two qubits. More generally, apply swap gates</i></font>
<a name="line-392"></a><font color=Blue><i>-- to every corresponding pair of qubits in two pieces of quantum</i></font>
<a name="line-393"></a><font color=Blue><i>-- data.</i></font>
<a name="line-394"></a><font color=Blue>swap</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> qc <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>qc<font color=Cyan>,</font>qc<font color=Cyan>)</font>
<a name="line-395"></a><font color=Blue>swap</font> a b <font color=Red>=</font> qc_mapBinary swap_qubit swap_bit a b
<a name="line-396"></a>
<a name="line-397"></a><a name="swap_at"></a><font color=Blue><i>-- | Apply a swap gate to two qubits. More generally, apply swap gates</i></font>
<a name="line-398"></a><font color=Blue><i>-- to every corresponding pair of qubits in two pieces of quantum</i></font>
<a name="line-399"></a><font color=Blue><i>-- data.</i></font>
<a name="line-400"></a><font color=Blue>swap_at</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> qc <font color=Red>-&gt;</font> Circ ()
<a name="line-401"></a><font color=Blue>swap_at</font> a b <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-402"></a>  swap a b
<a name="line-403"></a>  return ()
<a name="line-404"></a>
<a name="line-405"></a><a name="controlled_not"></a><font color=Blue><i>-- | Apply a controlled-not gate to every corresponding pair of</i></font>
<a name="line-406"></a><font color=Blue><i>-- quantum or classical bits in two pieces of QCData. The first</i></font>
<a name="line-407"></a><font color=Blue><i>-- argument is the target and the second the (positive) control.  </i></font>
<a name="line-408"></a><font color=Blue><i>-- </i></font>
<a name="line-409"></a><font color=Blue><i>-- For now, we require both pieces of QCData to have the same type,</i></font>
<a name="line-410"></a><font color=Blue><i>-- i.e., classical bits can be controlled only by classical bits and</i></font>
<a name="line-411"></a><font color=Blue><i>-- quantum bits can be controlled only by quantum bits.</i></font>
<a name="line-412"></a><font color=Blue><i>-- </i></font>
<a name="line-413"></a><font color=Blue><i>-- Example:</i></font>
<a name="line-414"></a><font color=Blue><i>-- </i></font>
<a name="line-415"></a><font color=Blue><i>-- &gt; ((a',b'), (x,y)) &lt;- controlled_not (a,b) (x,y)</i></font>
<a name="line-416"></a><font color=Blue><i>-- </i></font>
<a name="line-417"></a><font color=Blue><i>-- is equivalent to</i></font>
<a name="line-418"></a><font color=Blue><i>-- </i></font>
<a name="line-419"></a><font color=Blue><i>-- &gt; a' &lt;- qnot a `controlled` x</i></font>
<a name="line-420"></a><font color=Blue><i>-- &gt; b' &lt;- qnot b `controlled` y</i></font>
<a name="line-421"></a><font color=Blue>controlled_not</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> qc <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>qc<font color=Cyan>,</font> qc<font color=Cyan>)</font>
<a name="line-422"></a><font color=Blue>controlled_not</font> qc ctrl <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-423"></a>  <font color=Green><u>let</u></font> z <font color=Red>=</font> qcdata_zip qc qubit bit qubit bit qc ctrl errmsg
<a name="line-424"></a>  z' <font color=Red>&lt;-</font> qcdata_mapM qc map_qubit map_bit z
<a name="line-425"></a>  <font color=Green><u>let</u></font> <font color=Cyan>(</font>qc'<font color=Cyan>,</font> ctrl'<font color=Cyan>)</font> <font color=Red>=</font> qcdata_unzip qc qubit bit qubit bit z'
<a name="line-426"></a>  return <font color=Cyan>(</font>qc'<font color=Cyan>,</font> ctrl'<font color=Cyan>)</font>
<a name="line-427"></a>  <font color=Green><u>where</u></font>
<a name="line-428"></a>    
<a name="line-429"></a>    map_qubit <font color=Red>::</font> <font color=Cyan>(</font>Qubit<font color=Cyan>,</font> Qubit<font color=Cyan>)</font> <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>Qubit<font color=Cyan>,</font> Qubit<font color=Cyan>)</font>
<a name="line-430"></a>    map_qubit <font color=Cyan>(</font>q<font color=Cyan>,</font>c<font color=Cyan>)</font> <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-431"></a>      qnot_at q <font color=Cyan>`controlled`</font> c
<a name="line-432"></a>      return <font color=Cyan>(</font>q<font color=Cyan>,</font>c<font color=Cyan>)</font>
<a name="line-433"></a>
<a name="line-434"></a>    map_bit <font color=Red>::</font> <font color=Cyan>(</font>Bit<font color=Cyan>,</font> Bit<font color=Cyan>)</font> <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>Bit<font color=Cyan>,</font> Bit<font color=Cyan>)</font>
<a name="line-435"></a>    map_bit <font color=Cyan>(</font>b<font color=Cyan>,</font>c<font color=Cyan>)</font> <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-436"></a>      cnot_at b <font color=Cyan>`controlled`</font> c
<a name="line-437"></a>      return <font color=Cyan>(</font>b<font color=Cyan>,</font>c<font color=Cyan>)</font>
<a name="line-438"></a>
<a name="line-439"></a>    errmsg s <font color=Red>=</font> <font color=Magenta>"controlled_not: shapes of control and controlee do not match: "</font> <font color=Cyan>++</font> s
<a name="line-440"></a>
<a name="line-441"></a><a name="controlled_not_at"></a><font color=Blue><i>-- | Imperative version of 'controlled_not'. Apply a controlled-not</i></font>
<a name="line-442"></a><font color=Blue><i>-- gate to every corresponding pair of quantum or classical bits in</i></font>
<a name="line-443"></a><font color=Blue><i>-- two pieces of QCData. The first argument is the target and the</i></font>
<a name="line-444"></a><font color=Blue><i>-- second the (positive) control.</i></font>
<a name="line-445"></a><font color=Blue>controlled_not_at</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> qc <font color=Red>-&gt;</font> Circ ()
<a name="line-446"></a><font color=Blue>controlled_not_at</font> a b <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-447"></a>  controlled_not a b
<a name="line-448"></a>  return ()
<a name="line-449"></a>
<a name="line-450"></a><a name="bool_controlled_not"></a><font color=Blue><i>-- | A version of 'controlled_not' where the control consists of</i></font>
<a name="line-451"></a><font color=Blue><i>-- boolean data. Example:</i></font>
<a name="line-452"></a><font color=Blue><i>-- </i></font>
<a name="line-453"></a><font color=Blue><i>-- &gt; bool_controlled_not (q, r, s) (True, True, False)</i></font>
<a name="line-454"></a><font color=Blue><i>-- </i></font>
<a name="line-455"></a><font color=Blue><i>-- negates /q/ and /r/, but not /s/.</i></font>
<a name="line-456"></a><font color=Blue>bool_controlled_not</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> BType qc <font color=Red>-&gt;</font> Circ qc
<a name="line-457"></a><font color=Blue>bool_controlled_not</font> qc a <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-458"></a>  bool_controlled_not_at qc a
<a name="line-459"></a>  return qc
<a name="line-460"></a>
<a name="line-461"></a><a name="bool_controlled_not_at"></a><font color=Blue><i>-- | A version of 'controlled_not_at' where the control consists of</i></font>
<a name="line-462"></a><font color=Blue><i>-- boolean data. Example:</i></font>
<a name="line-463"></a><font color=Blue><i>-- </i></font>
<a name="line-464"></a><font color=Blue><i>-- &gt; bool_controlled_not_at (q, r, s) (True, True, False)</i></font>
<a name="line-465"></a><font color=Blue><i>-- </i></font>
<a name="line-466"></a><font color=Blue><i>-- negates /q/ and /r/, but not /s/.</i></font>
<a name="line-467"></a><font color=Blue>bool_controlled_not_at</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> BType qc <font color=Red>-&gt;</font> Circ ()
<a name="line-468"></a><font color=Blue>bool_controlled_not_at</font> qc a <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-469"></a>  qmultinot_list_at vq 
<a name="line-470"></a>  cmultinot_list_at vc 
<a name="line-471"></a>  <font color=Green><u>where</u></font>
<a name="line-472"></a>    v <font color=Red>=</font> Map<font color=Cyan>.</font>toList <font color=Cyan>$</font> qc_bind qc a
<a name="line-473"></a>    vq <font color=Red>=</font> <font color=Red>[</font> <font color=Cyan>(</font>qubit_of_wire q<font color=Cyan>,</font> b<font color=Cyan>)</font> <font color=Red>|</font> <font color=Cyan>(</font>q<font color=Cyan>,</font> Endpoint_Qubit b<font color=Cyan>)</font> <font color=Red>&lt;-</font> v <font color=Red>]</font>
<a name="line-474"></a>    vc <font color=Red>=</font> <font color=Red>[</font> <font color=Cyan>(</font>bit_of_wire c<font color=Cyan>,</font> b<font color=Cyan>)</font> <font color=Red>|</font> <font color=Cyan>(</font>c<font color=Cyan>,</font> Endpoint_Bit b<font color=Cyan>)</font> <font color=Red>&lt;-</font> v <font color=Red>]</font>
<a name="line-475"></a>
<a name="line-476"></a><a name="qmultinot"></a><font color=Blue><i>-- | Negate all qubits in a quantum data structure.</i></font>
<a name="line-477"></a><font color=Blue>qmultinot</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> qa <font color=Red>-&gt;</font> Circ qa
<a name="line-478"></a><font color=Blue>qmultinot</font> qa <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-479"></a>  qmultinot_at qa
<a name="line-480"></a>  return qa
<a name="line-481"></a>
<a name="line-482"></a><a name="qmultinot_at"></a><font color=Blue><i>-- | Negate all qubits in a quantum data structure.</i></font>
<a name="line-483"></a><font color=Blue>qmultinot_at</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> qa <font color=Red>-&gt;</font> Circ ()
<a name="line-484"></a><font color=Blue>qmultinot_at</font> qa <font color=Red>=</font>
<a name="line-485"></a>  qmultinot_list_at <font color=Red>[</font> <font color=Cyan>(</font>q<font color=Cyan>,</font>True<font color=Cyan>)</font> <font color=Red>|</font> q <font color=Red>&lt;-</font> qubits_of_qdata qa <font color=Red>]</font>
<a name="line-486"></a>
<a name="line-487"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-488"></a><font color=Blue><i>-- ** Copying and uncopying</i></font>
<a name="line-489"></a>
<a name="line-490"></a><a name="qc_copy_fun"></a><font color=Blue><i>-- | Initialize a new piece of quantum data, as a copy of a given</i></font>
<a name="line-491"></a><font color=Blue><i>-- piece.  Returns both the original and the copy.</i></font>
<a name="line-492"></a><font color=Blue>qc_copy_fun</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>qc<font color=Cyan>,</font>qc<font color=Cyan>)</font>
<a name="line-493"></a><font color=Blue>qc_copy_fun</font> orig <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-494"></a>  copy <font color=Red>&lt;-</font> qc_init <font color=Cyan>(</font>qc_false orig<font color=Cyan>)</font>
<a name="line-495"></a>  <font color=Cyan>(</font>copy<font color=Cyan>,</font> orig<font color=Cyan>)</font> <font color=Red>&lt;-</font> controlled_not copy orig
<a name="line-496"></a>  return <font color=Cyan>(</font>orig<font color=Cyan>,</font> copy<font color=Cyan>)</font>
<a name="line-497"></a>    
<a name="line-498"></a><a name="qc_uncopy_fun"></a><font color=Blue><i>-- | Given two pieces of quantum data, assumed equal (w.r.t. the</i></font>
<a name="line-499"></a><font color=Blue><i>-- computational basis), terminate the second piece (and return the</i></font>
<a name="line-500"></a><font color=Blue><i>-- first, unmodified). This is the inverse of 'qc_copy_fun', in the sense</i></font>
<a name="line-501"></a><font color=Blue><i>-- that the following sequence of instructions behaves like the</i></font>
<a name="line-502"></a><font color=Blue><i>-- identity function:</i></font>
<a name="line-503"></a><font color=Blue><i>-- </i></font>
<a name="line-504"></a><font color=Blue><i>-- &gt; (orig, copy) &lt;- qc_copy_fun orig</i></font>
<a name="line-505"></a><font color=Blue><i>-- &gt; orig &lt;- qc_uncopy_fun orig copy</i></font>
<a name="line-506"></a><font color=Blue>qc_uncopy_fun</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> qc <font color=Red>-&gt;</font> Circ qc
<a name="line-507"></a><font color=Blue>qc_uncopy_fun</font> orig copy <font color=Red>=</font> reverse_generic qc_copy_fun orig <font color=Cyan>(</font>orig<font color=Cyan>,</font>copy<font color=Cyan>)</font> 
<a name="line-508"></a>
<a name="line-509"></a><a name="qc_copy"></a><font color=Blue><i>-- | Create a fresh copy of a piece of quantum data. Note: copying is</i></font>
<a name="line-510"></a><font color=Blue><i>-- performed via a controlled-not operation, and is not cloning. This</i></font>
<a name="line-511"></a><font color=Blue><i>-- is similar to 'qc_copy_fun', except it returns only the copy, and not</i></font>
<a name="line-512"></a><font color=Blue><i>-- the original.</i></font>
<a name="line-513"></a><font color=Blue>qc_copy</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> Circ qc
<a name="line-514"></a><font color=Blue>qc_copy</font> qc <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-515"></a>  <font color=Cyan>(</font>qc<font color=Cyan>,</font> qc1<font color=Cyan>)</font> <font color=Red>&lt;-</font> qc_copy_fun qc
<a name="line-516"></a>  return qc1
<a name="line-517"></a>
<a name="line-518"></a><a name="qc_uncopy"></a><font color=Blue><i>-- | \"Uncopy\" a piece of quantum data; i.e. terminate /copy/,</i></font>
<a name="line-519"></a><font color=Blue><i>-- assuming it's a copy of /orig/. This is the inverse of</i></font>
<a name="line-520"></a><font color=Blue><i>-- 'qc_copy', in the sense that the following sequence of</i></font>
<a name="line-521"></a><font color=Blue><i>-- instructions behaves like the identity function:</i></font>
<a name="line-522"></a><font color=Blue><i>-- </i></font>
<a name="line-523"></a><font color=Blue><i>-- &gt; b &lt;- qc_copy a</i></font>
<a name="line-524"></a><font color=Blue><i>-- &gt; qc_uncopy a b</i></font>
<a name="line-525"></a><font color=Blue>qc_uncopy</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> qc <font color=Red>-&gt;</font> Circ ()
<a name="line-526"></a><font color=Blue>qc_uncopy</font> orig copy <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-527"></a>  qc_uncopy_fun orig copy
<a name="line-528"></a>  return ()
<a name="line-529"></a>
<a name="line-530"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-531"></a><font color=Blue><i>-- ** Classical gates</i></font>
<a name="line-532"></a>
<a name="line-533"></a><a name="cgate_if"></a><font color=Blue><i>-- | If /a/ is 'True', return a copy of /b/, else return a copy of</i></font>
<a name="line-534"></a><font color=Blue><i>-- /c/. Here /b/ and /c/ can be any data structures consisting of</i></font>
<a name="line-535"></a><font color=Blue><i>-- Bits, but /b/ and /c/ must be of the same type and shape (for</i></font>
<a name="line-536"></a><font color=Blue><i>-- example, if they are lists, they must be of equal</i></font>
<a name="line-537"></a><font color=Blue><i>-- length). Examples:</i></font>
<a name="line-538"></a><font color=Blue><i>-- </i></font>
<a name="line-539"></a><font color=Blue><i>-- &gt; output &lt;- cgate_if a b c</i></font>
<a name="line-540"></a><font color=Blue><i>-- &gt; (out0, out1) &lt;- cgate_if a (b0, b1) (c0, c1)</i></font>
<a name="line-541"></a><font color=Blue><i>-- &gt; [out0, out1, out2] &lt;- cgate_if a [b0, b1, b2] [c0, c1, c2]</i></font>
<a name="line-542"></a><font color=Blue>cgate_if</font> <font color=Red>::</font> <font color=Cyan>(</font>CData ca<font color=Cyan>)</font> <font color=Red>=&gt;</font> Bit <font color=Red>-&gt;</font> ca <font color=Red>-&gt;</font> ca <font color=Red>-&gt;</font> Circ ca
<a name="line-543"></a><font color=Blue>cgate_if</font> a b c <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-544"></a>  <font color=Green><u>let</u></font> shape <font color=Red>=</font> shapetype_c b
<a name="line-545"></a>  <font color=Green><u>let</u></font> z <font color=Red>=</font> qdata_zip shape bit bit b c errmsg
<a name="line-546"></a>  d <font color=Red>&lt;-</font> qdata_mapM shape <font color=Cyan>(</font><font color=Red>\</font><font color=Cyan>(</font>x<font color=Cyan>,</font>y<font color=Cyan>)</font> <font color=Red>-&gt;</font> cgate_if_bit a x y<font color=Cyan>)</font> z
<a name="line-547"></a>  return d
<a name="line-548"></a>  <font color=Green><u>where</u></font>
<a name="line-549"></a>    errmsg s <font color=Red>=</font> <font color=Magenta>"cgate_if: shapes of 'then' and 'else' part do not match: "</font> <font color=Cyan>++</font> s
<a name="line-550"></a>
<a name="line-551"></a><a name="circ_if"></a><font color=Blue><i>-- | 'circ_if' is an if-then-else function for classical circuits. </i></font>
<a name="line-552"></a><font color=Blue><i>-- It is a wrapper around 'cgate_if', intended to be used like this:</i></font>
<a name="line-553"></a><font color=Blue><i>-- </i></font>
<a name="line-554"></a><font color=Blue><i>-- &gt; result &lt;- circ_if &lt;&lt;&lt;condition&gt;&gt;&gt; (</i></font>
<a name="line-555"></a><font color=Blue><i>-- &gt;   &lt;&lt;then-part&gt;&gt;&gt;</i></font>
<a name="line-556"></a><font color=Blue><i>-- &gt;   )(</i></font>
<a name="line-557"></a><font color=Blue><i>-- &gt;   &lt;&lt;&lt;else-part&gt;&gt;&gt;</i></font>
<a name="line-558"></a><font color=Blue><i>-- &gt;   )</i></font>
<a name="line-559"></a><font color=Blue><i>-- </i></font>
<a name="line-560"></a><font color=Blue><i>-- Unlike 'cgate_if', this is a meta-operation, i.e., the bodies of</i></font>
<a name="line-561"></a><font color=Blue><i>-- the \"then\" and \"else\" parts can be circuit building</i></font>
<a name="line-562"></a><font color=Blue><i>-- operations. </i></font>
<a name="line-563"></a><font color=Blue><i>-- </i></font>
<a name="line-564"></a><font color=Blue><i>-- What makes this different from the usual boolean \"if-then-else\"</i></font>
<a name="line-565"></a><font color=Blue><i>-- is that the condition is of type 'Bit', i.e., it is only known at</i></font>
<a name="line-566"></a><font color=Blue><i>-- circuit execution time. Therefore the generated circuit contains</i></font>
<a name="line-567"></a><font color=Blue><i>-- /both/ the \"then\" and \"else\" parts, suitably</i></font>
<a name="line-568"></a><font color=Blue><i>-- controlled. Precondition: the \"then\" and \"else\" parts must be</i></font>
<a name="line-569"></a><font color=Blue><i>-- of the same type and shape.</i></font>
<a name="line-570"></a><font color=Blue>circ_if</font> <font color=Red>::</font> <font color=Cyan>(</font>CData ca<font color=Cyan>)</font> <font color=Red>=&gt;</font> Bit <font color=Red>-&gt;</font> Circ ca <font color=Red>-&gt;</font> Circ ca <font color=Red>-&gt;</font> Circ ca
<a name="line-571"></a><font color=Blue>circ_if</font> a b c <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-572"></a>  b' <font color=Red>&lt;-</font> b
<a name="line-573"></a>  c' <font color=Red>&lt;-</font> c
<a name="line-574"></a>  cgate_if a b' c'
<a name="line-575"></a>
<a name="line-576"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-577"></a><font color=Blue><i>-- ** Named gates</i></font>
<a name="line-578"></a>
<a name="line-579"></a><a name="extended_named_gate"></a><font color=Blue><i>-- | Define a new functional-style gate of the given name. Like</i></font>
<a name="line-580"></a><font color=Blue><i>-- 'named_gate', except that the generated gate is extended with</i></font>
<a name="line-581"></a><font color=Blue><i>-- \"generalized controls\". The generalized controls are additional</i></font>
<a name="line-582"></a><font color=Blue><i>-- inputs to the gate that are guaranteed not to be modified if they</i></font>
<a name="line-583"></a><font color=Blue><i>-- are in a computational basis state. They are rendered in a special</i></font>
<a name="line-584"></a><font color=Blue><i>-- way in circuit diagrams. Usage:</i></font>
<a name="line-585"></a><font color=Blue><i>-- </i></font>
<a name="line-586"></a><font color=Blue><i>-- &gt; my_new_gate :: (Qubit,Qubit) -&gt; Qubit -&gt; Circ (Qubit,Qubit)</i></font>
<a name="line-587"></a><font color=Blue><i>-- &gt; my_new_gate = extended_named_gate "Q"</i></font>
<a name="line-588"></a><font color=Blue><i>-- </i></font>
<a name="line-589"></a><font color=Blue><i>-- This defines a new gate with name "Q", two inputs, and one</i></font>
<a name="line-590"></a><font color=Blue><i>-- generalized input.</i></font>
<a name="line-591"></a><font color=Blue>extended_named_gate</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>,</font> QData qb<font color=Cyan>)</font> <font color=Red>=&gt;</font> String <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> qb <font color=Red>-&gt;</font> Circ qa
<a name="line-592"></a><font color=Blue>extended_named_gate</font> name operands gencontrols <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-593"></a>  named_gate_qulist_at name False <font color=Cyan>(</font>qubits_of_qdata operands<font color=Cyan>)</font> <font color=Cyan>(</font>qubits_of_qdata gencontrols<font color=Cyan>)</font>
<a name="line-594"></a>  return operands
<a name="line-595"></a>
<a name="line-596"></a><a name="extended_named_gate_at"></a><font color=Blue><i>-- | Like 'extended_named_gate', except defines an imperative style gate.</i></font>
<a name="line-597"></a><font color=Blue><i>-- Usage:</i></font>
<a name="line-598"></a><font color=Blue><i>-- </i></font>
<a name="line-599"></a><font color=Blue><i>-- &gt; my_new_gate_at :: (Qubit,Qubit) -&gt; Qubit -&gt; Circ ()</i></font>
<a name="line-600"></a><font color=Blue><i>-- &gt; my_new_gate_at = extended_named_gate_at "Q"</i></font>
<a name="line-601"></a><font color=Blue><i>-- </i></font>
<a name="line-602"></a><font color=Blue><i>-- This defines a new gate with name "Q", two inputs, and one</i></font>
<a name="line-603"></a><font color=Blue><i>-- generalized input.</i></font>
<a name="line-604"></a><font color=Blue>extended_named_gate_at</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>,</font> QData qb<font color=Cyan>)</font> <font color=Red>=&gt;</font> String <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> qb <font color=Red>-&gt;</font> Circ ()
<a name="line-605"></a><font color=Blue>extended_named_gate_at</font> name operands gencontrols <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-606"></a>  extended_named_gate name operands gencontrols
<a name="line-607"></a>  return ()
<a name="line-608"></a>
<a name="line-609"></a><font color=Blue><i>-- | Define a new functional-style gate of the given name. Usage:</i></font>
<a name="line-610"></a><font color=Blue><i>-- </i></font>
<a name="line-611"></a><font color=Blue><i>-- &gt; my_unary_gate :: Qubit -&gt; Circ Qubit</i></font>
<a name="line-612"></a><font color=Blue><i>-- &gt; my_unary_gate = named_gate "Q"</i></font>
<a name="line-613"></a><font color=Blue><i>-- </i></font>
<a name="line-614"></a><font color=Blue><i>-- &gt; my_binary_gate :: (Qubit, Qubit) -&gt; Circ (Qubit, Qubit)</i></font>
<a name="line-615"></a><font color=Blue><i>-- &gt; my_binary_gate = named_gate "R"</i></font>
<a name="line-616"></a><font color=Blue><i>--   </i></font>
<a name="line-617"></a><font color=Blue><i>-- This defines a new unary gate and a new binary gate, which will be</i></font>
<a name="line-618"></a><font color=Blue><i>-- rendered as "Q" and "R", respectively, in circuit diagrams. </i></font>
<a name="line-619"></a>
<a name="line-620"></a><a name="named_gate"></a><font color=Blue><i>-- Implementation note: contrary to our usual convention, the binary</i></font>
<a name="line-621"></a><font color=Blue><i>-- gate defined above is not in curried form. It would be nice to have</i></font>
<a name="line-622"></a><font color=Blue><i>-- a version of this operator that curries the gate.</i></font>
<a name="line-623"></a><font color=Blue>named_gate</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> String <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> Circ qa
<a name="line-624"></a><font color=Blue>named_gate</font> name operands <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-625"></a>  extended_named_gate name operands ()
<a name="line-626"></a>
<a name="line-627"></a><font color=Blue><i>-- | Define a new imperative-style gate of the given name. Usage:</i></font>
<a name="line-628"></a><font color=Blue><i>-- </i></font>
<a name="line-629"></a><font color=Blue><i>-- &gt; my_unary_gate_at :: Qubit -&gt; Circ ()</i></font>
<a name="line-630"></a><font color=Blue><i>-- &gt; my_unary_gate_at = named_gate_at "Q"</i></font>
<a name="line-631"></a><font color=Blue><i>-- </i></font>
<a name="line-632"></a><font color=Blue><i>-- &gt; my_binary_gate_at :: (Qubit, Qubit) -&gt; Circ ()</i></font>
<a name="line-633"></a><font color=Blue><i>-- &gt; my_binary_gate_at = named_gate_at "R"</i></font>
<a name="line-634"></a><font color=Blue><i>--   </i></font>
<a name="line-635"></a><font color=Blue><i>-- This defines a new unary gate and a new binary gate, which will be</i></font>
<a name="line-636"></a><font color=Blue><i>-- rendered as "Q" and "R", respectively, in circuit diagrams. </i></font>
<a name="line-637"></a>
<a name="line-638"></a><a name="named_gate_at"></a><font color=Blue>named_gate_at</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> String <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> Circ ()
<a name="line-639"></a><font color=Blue>named_gate_at</font> name operands <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-640"></a>  named_gate name operands
<a name="line-641"></a>  return ()
<a name="line-642"></a>
<a name="line-643"></a><a name="named_rotation"></a><font color=Blue><i>-- | Define a new functional-style gate of the given name, and</i></font>
<a name="line-644"></a><font color=Blue><i>-- parameterized by a real-valued parameter. This is typically used</i></font>
<a name="line-645"></a><font color=Blue><i>-- for rotations or phase gates that are parameterized by an angle.</i></font>
<a name="line-646"></a><font color=Blue><i>-- The name can contain \'%\' as a place holder for the parameter.</i></font>
<a name="line-647"></a><font color=Blue><i>-- Usage:</i></font>
<a name="line-648"></a><font color=Blue><i>-- </i></font>
<a name="line-649"></a><font color=Blue><i>-- &gt; my_unary_gate :: Qubit -&gt; Circ Qubit</i></font>
<a name="line-650"></a><font color=Blue><i>-- &gt; my_unary_gate = named_rotation "exp(-i%Z)" 0.123</i></font>
<a name="line-651"></a><font color=Blue><i>-- </i></font>
<a name="line-652"></a><font color=Blue><i>-- &gt; my_binary_gate :: TimeStep -&gt; (Qubit, Qubit) -&gt; Circ (Qubit, Qubit)</i></font>
<a name="line-653"></a><font color=Blue><i>-- &gt; my_binary_gate t = named_rotation "Q(%)" t</i></font>
<a name="line-654"></a><font color=Blue>named_rotation</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> String <font color=Red>-&gt;</font> Timestep <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> Circ qa
<a name="line-655"></a><font color=Blue>named_rotation</font> name theta operands <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-656"></a>  named_rotation_qulist_at name False theta <font color=Cyan>(</font>qubits_of_qdata operands<font color=Cyan>)</font> []
<a name="line-657"></a>  return operands
<a name="line-658"></a>
<a name="line-659"></a><a name="named_rotation_at"></a><font color=Blue><i>-- | Define a new imperative-style gate of the given name, and</i></font>
<a name="line-660"></a><font color=Blue><i>-- parameterized by a real-valued parameter. This is typically used</i></font>
<a name="line-661"></a><font color=Blue><i>-- for rotations or phase gates that are parameterized by an angle.</i></font>
<a name="line-662"></a><font color=Blue><i>-- The name can contain \'%\' as a place holder for the parameter.</i></font>
<a name="line-663"></a><font color=Blue><i>-- Usage:</i></font>
<a name="line-664"></a><font color=Blue><i>-- </i></font>
<a name="line-665"></a><font color=Blue><i>-- &gt; my_unary_gate_at :: Qubit -&gt; Circ ()</i></font>
<a name="line-666"></a><font color=Blue><i>-- &gt; my_unary_gate_at = named_rotation "exp(-i%Z)" 0.123</i></font>
<a name="line-667"></a><font color=Blue><i>-- </i></font>
<a name="line-668"></a><font color=Blue><i>-- &gt; my_binary_gate_at :: TimeStep -&gt; (Qubit, Qubit) -&gt; Circ ()</i></font>
<a name="line-669"></a><font color=Blue><i>-- &gt; my_binary_gate_at t = named_rotation "Q(%)" t</i></font>
<a name="line-670"></a><font color=Blue>named_rotation_at</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> String <font color=Red>-&gt;</font> Timestep <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> Circ ()
<a name="line-671"></a><font color=Blue>named_rotation_at</font> name theta operands <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-672"></a>  named_rotation name theta operands
<a name="line-673"></a>  return ()
<a name="line-674"></a>
<a name="line-675"></a><font color=Blue><i>----------------------------------------------------------------------</i></font>
<a name="line-676"></a><font color=Blue><i>-- ** Dynamic lifting</i></font>
<a name="line-677"></a>
<a name="line-678"></a><a name="dynamic_lift"></a><font color=Blue><i>-- | Convert a 'Bit' (boolean circuit output) to a 'Bool' (boolean</i></font>
<a name="line-679"></a><font color=Blue><i>-- parameter). More generally, convert a data structure of Bits to a</i></font>
<a name="line-680"></a><font color=Blue><i>-- corresponding data structure of Bools.</i></font>
<a name="line-681"></a><font color=Blue><i>-- </i></font>
<a name="line-682"></a><font color=Blue><i>-- For use in algorithms that require the output of a measurement to</i></font>
<a name="line-683"></a><font color=Blue><i>-- be used as a circuit-generation parameter. This is the case, for</i></font>
<a name="line-684"></a><font color=Blue><i>-- example, for sieving methods, and also for some iterative</i></font>
<a name="line-685"></a><font color=Blue><i>-- algorithms.</i></font>
<a name="line-686"></a><font color=Blue><i>-- </i></font>
<a name="line-687"></a><font color=Blue><i>-- Note that this is not a gate, but a meta-operation. The input</i></font>
<a name="line-688"></a><font color=Blue><i>-- consists of classical circuit endpoints (whose values are known at</i></font>
<a name="line-689"></a><font color=Blue><i>-- circuit execution time), and the output is a boolean parameter</i></font>
<a name="line-690"></a><font color=Blue><i>-- (whose value is known at circuit generation time). </i></font>
<a name="line-691"></a><font color=Blue><i>-- </i></font>
<a name="line-692"></a><font color=Blue><i>-- The use of this operation implies an interleaving between circuit</i></font>
<a name="line-693"></a><font color=Blue><i>-- execution and circuit generation. It is therefore a (physically)</i></font>
<a name="line-694"></a><font color=Blue><i>-- expensive operation and should be used sparingly. Using the</i></font>
<a name="line-695"></a><font color=Blue><i>-- 'dynamic_lift' operation interrupts the batch mode operation of the</i></font>
<a name="line-696"></a><font color=Blue><i>-- quantum device (where circuits are generated ahead of time), and</i></font>
<a name="line-697"></a><font color=Blue><i>-- forces interactive operation (the quantum device must wait for the</i></font>
<a name="line-698"></a><font color=Blue><i>-- next portion of the circuit to be generated). This operation is</i></font>
<a name="line-699"></a><font color=Blue><i>-- especially expensive if the current circuit contains unmeasured</i></font>
<a name="line-700"></a><font color=Blue><i>-- qubits; in this case, the qubits must be preserved while the</i></font>
<a name="line-701"></a><font color=Blue><i>-- quantum device remains on standby.</i></font>
<a name="line-702"></a><font color=Blue><i>-- </i></font>
<a name="line-703"></a><font color=Blue><i>-- Also note that this operation is not supported in all contexts. It</i></font>
<a name="line-704"></a><font color=Blue><i>-- is an error, for example, to use this operation in a circuit that</i></font>
<a name="line-705"></a><font color=Blue><i>-- is going to be reversed, or in the body of a boxed subroutine.</i></font>
<a name="line-706"></a><font color=Blue><i>-- Also, not all output devices (such as circuit viewers) support this</i></font>
<a name="line-707"></a><font color=Blue><i>-- operation.</i></font>
<a name="line-708"></a><font color=Blue>dynamic_lift</font> <font color=Red>::</font> <font color=Cyan>(</font>QShape ba qa ca<font color=Cyan>)</font> <font color=Red>=&gt;</font> ca <font color=Red>-&gt;</font> Circ ba
<a name="line-709"></a><font color=Blue>dynamic_lift</font> ca <font color=Red>=</font> qdata_mapM <font color=Cyan>(</font>shapetype_c ca<font color=Cyan>)</font> dynamic_lift_bit ca
<a name="line-710"></a>
<a name="line-711"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-712"></a><font color=Blue><i>-- * Mapping</i></font>
<a name="line-713"></a>
<a name="line-714"></a><a name="mapUnary"></a><font color=Blue><i>-- | Map a single qubit gate across every qubit in the data structure.</i></font>
<a name="line-715"></a><font color=Blue>mapUnary</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>Qubit <font color=Red>-&gt;</font> Circ Qubit<font color=Cyan>)</font> <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> Circ qa
<a name="line-716"></a><font color=Blue>mapUnary</font> f qa <font color=Red>=</font> qdata_mapM <font color=Cyan>(</font>shapetype_q qa<font color=Cyan>)</font> f qa
<a name="line-717"></a>
<a name="line-718"></a><a name="mapBinary"></a><font color=Blue><i>-- | Map a binary gate across every corresponding pair of qubits in</i></font>
<a name="line-719"></a><font color=Blue><i>-- two quantum data structures of equal shape.</i></font>
<a name="line-720"></a><font color=Blue>mapBinary</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>Qubit <font color=Red>-&gt;</font> Qubit <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>Qubit<font color=Cyan>,</font> Qubit<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>qa<font color=Cyan>,</font> qa<font color=Cyan>)</font>
<a name="line-721"></a><font color=Blue>mapBinary</font> f q1 q2 <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-722"></a>  <font color=Green><u>let</u></font> shape <font color=Red>=</font> shapetype_q q1
<a name="line-723"></a>  <font color=Green><u>let</u></font> z <font color=Red>=</font> qdata_zip shape qubit qubit q1 q2 errmsg
<a name="line-724"></a>  z' <font color=Red>&lt;-</font> qdata_mapM shape <font color=Cyan>(</font><font color=Red>\</font><font color=Cyan>(</font>x<font color=Cyan>,</font>y<font color=Cyan>)</font> <font color=Red>-&gt;</font> f x y<font color=Cyan>)</font> z
<a name="line-725"></a>  <font color=Green><u>let</u></font> <font color=Cyan>(</font>q1'<font color=Cyan>,</font> q2'<font color=Cyan>)</font> <font color=Red>=</font> qdata_unzip shape qubit qubit z'
<a name="line-726"></a>  return <font color=Cyan>(</font>q1'<font color=Cyan>,</font> q2'<font color=Cyan>)</font>
<a name="line-727"></a>  <font color=Green><u>where</u></font>
<a name="line-728"></a>    errmsg s <font color=Red>=</font> <font color=Magenta>"mapBinary: shapes of arguments do not match: "</font> <font color=Cyan>++</font> s
<a name="line-729"></a>  
<a name="line-730"></a><a name="mapBinary_c"></a><font color=Blue><i>-- | Like 'mapBinary', except the second data structure is classical.</i></font>
<a name="line-731"></a><font color=Blue>mapBinary_c</font> <font color=Red>::</font> <font color=Cyan>(</font>QShape ba qa ca<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>Qubit <font color=Red>-&gt;</font> Bit <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>Qubit<font color=Cyan>,</font> Bit<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> ca <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>qa<font color=Cyan>,</font> ca<font color=Cyan>)</font>
<a name="line-732"></a><font color=Blue>mapBinary_c</font> f q1 c2 <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-733"></a>  <font color=Green><u>let</u></font> shape <font color=Red>=</font> shapetype_q q1
<a name="line-734"></a>  <font color=Green><u>let</u></font> z <font color=Red>=</font> qdata_zip shape qubit bit q1 c2 errmsg
<a name="line-735"></a>  z' <font color=Red>&lt;-</font> qdata_mapM shape <font color=Cyan>(</font><font color=Red>\</font><font color=Cyan>(</font>x<font color=Cyan>,</font>y<font color=Cyan>)</font> <font color=Red>-&gt;</font> f x y<font color=Cyan>)</font> z
<a name="line-736"></a>  <font color=Green><u>let</u></font> <font color=Cyan>(</font>q1'<font color=Cyan>,</font> c2'<font color=Cyan>)</font> <font color=Red>=</font> qdata_unzip shape qubit bit z'
<a name="line-737"></a>  return <font color=Cyan>(</font>q1'<font color=Cyan>,</font> c2'<font color=Cyan>)</font>
<a name="line-738"></a>  <font color=Green><u>where</u></font>
<a name="line-739"></a>    errmsg s <font color=Red>=</font> <font color=Magenta>"mapBinary_c: shapes of arguments do not match: "</font> <font color=Cyan>++</font> s
<a name="line-740"></a>
<a name="line-741"></a><a name="map2Q"></a><font color=Blue><i>-- | Map a binary qubit circuit to every pair of qubits in the quantum</i></font>
<a name="line-742"></a><font color=Blue><i>-- data-type. It is a run-time error if the two structures do not have</i></font>
<a name="line-743"></a><font color=Blue><i>-- the same size.</i></font>
<a name="line-744"></a><font color=Blue>map2Q</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font><font color=Cyan>(</font>Qubit<font color=Cyan>,</font> Qubit<font color=Cyan>)</font> <font color=Red>-&gt;</font> Circ Qubit<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>qa<font color=Cyan>,</font> qa<font color=Cyan>)</font> <font color=Red>-&gt;</font> Circ qa
<a name="line-745"></a><font color=Blue>map2Q</font> f <font color=Cyan>(</font>q<font color=Cyan>,</font>p<font color=Cyan>)</font> <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-746"></a>  <font color=Green><u>let</u></font> shape <font color=Red>=</font> shapetype_q q
<a name="line-747"></a>  <font color=Green><u>let</u></font> z <font color=Red>=</font> qdata_zip shape qubit qubit q p errmsg
<a name="line-748"></a>  d <font color=Red>&lt;-</font> qdata_mapM shape f z
<a name="line-749"></a>  return d
<a name="line-750"></a>  <font color=Green><u>where</u></font>
<a name="line-751"></a>    errmsg s <font color=Red>=</font> <font color=Magenta>"map2Q: shapes of arguments do not match: "</font> <font color=Cyan>++</font> s
<a name="line-752"></a>  
<a name="line-753"></a><a name="qc_mapBinary"></a><font color=Blue><i>-- | Heterogeneous version of 'mapBinary'. Map a binary gate /f/</i></font>
<a name="line-754"></a><font color=Blue><i>-- across every corresponding pair of qubits, and a binary gate /g/</i></font>
<a name="line-755"></a><font color=Blue><i>-- across every corresponding pair of bits, in two quantum data</i></font>
<a name="line-756"></a><font color=Blue><i>-- structures of equal shape.</i></font>
<a name="line-757"></a><font color=Blue>qc_mapBinary</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>Qubit <font color=Red>-&gt;</font> Qubit <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>Qubit<font color=Cyan>,</font> Qubit<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>Bit <font color=Red>-&gt;</font> Bit <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>Bit<font color=Cyan>,</font> Bit<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>-&gt;</font> qc <font color=Red>-&gt;</font> qc <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>qc<font color=Cyan>,</font> qc<font color=Cyan>)</font>
<a name="line-758"></a><font color=Blue>qc_mapBinary</font> f g x y <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-759"></a>  <font color=Green><u>let</u></font> z <font color=Red>=</font> qcdata_zip x qubit bit qubit bit x y errmsg
<a name="line-760"></a>  z' <font color=Red>&lt;-</font> qcdata_mapM x map_qubit map_bit z
<a name="line-761"></a>  <font color=Green><u>let</u></font> <font color=Cyan>(</font>x'<font color=Cyan>,</font> y'<font color=Cyan>)</font> <font color=Red>=</font> qcdata_unzip x qubit bit qubit bit z'
<a name="line-762"></a>  return <font color=Cyan>(</font>x'<font color=Cyan>,</font> y'<font color=Cyan>)</font>
<a name="line-763"></a>  <font color=Green><u>where</u></font>
<a name="line-764"></a>    
<a name="line-765"></a>    map_qubit <font color=Red>::</font> <font color=Cyan>(</font>Qubit<font color=Cyan>,</font> Qubit<font color=Cyan>)</font> <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>Qubit<font color=Cyan>,</font> Qubit<font color=Cyan>)</font>
<a name="line-766"></a>    map_qubit <font color=Cyan>(</font>x<font color=Cyan>,</font>y<font color=Cyan>)</font> <font color=Red>=</font> f x y
<a name="line-767"></a>
<a name="line-768"></a>    map_bit <font color=Red>::</font> <font color=Cyan>(</font>Bit<font color=Cyan>,</font> Bit<font color=Cyan>)</font> <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>Bit<font color=Cyan>,</font> Bit<font color=Cyan>)</font>
<a name="line-769"></a>    map_bit <font color=Cyan>(</font>x<font color=Cyan>,</font>y<font color=Cyan>)</font> <font color=Red>=</font> g x y
<a name="line-770"></a>
<a name="line-771"></a>    errmsg s <font color=Red>=</font> <font color=Magenta>"qc_mapBinary: shapes of arguments do not match: "</font> <font color=Cyan>++</font> s
<a name="line-772"></a>
<a name="line-773"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-774"></a><font color=Blue><i>-- * Conversion to lists</i></font>
<a name="line-775"></a>
<a name="line-776"></a><font color=Blue><i>-- $CONVERSION The functions in this section can be used to convert</i></font>
<a name="line-777"></a><font color=Blue><i>-- quantum data structures to and from lists. Do not use them! The</i></font>
<a name="line-778"></a><font color=Blue><i>-- conversion is unsafe in the same way pointers to void are unsafe in</i></font>
<a name="line-779"></a><font color=Blue><i>-- the C programming language. There is almost always a better and</i></font>
<a name="line-780"></a><font color=Blue><i>-- more natural way to accomplish what you need to do.</i></font>
<a name="line-781"></a>
<a name="line-782"></a><a name="qubits_of_qdata"></a><font color=Blue><i>-- | Return the list of qubits representing the given quantum data.</i></font>
<a name="line-783"></a><font color=Blue><i>-- The qubits are ordered in some fixed, but arbitrary way. It is</i></font>
<a name="line-784"></a><font color=Blue><i>-- guaranteed that two pieces of qdata of the same given shape will be</i></font>
<a name="line-785"></a><font color=Blue><i>-- ordered in the same way. No other property of the order is</i></font>
<a name="line-786"></a><font color=Blue><i>-- guaranteed, In particular, the order may change without notice from</i></font>
<a name="line-787"></a><font color=Blue><i>-- one version of Quipper to the next.</i></font>
<a name="line-788"></a><font color=Blue>qubits_of_qdata</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> qa <font color=Red>-&gt;</font> <font color=Red>[</font>Qubit<font color=Red>]</font>
<a name="line-789"></a><font color=Blue>qubits_of_qdata</font> qa <font color=Red>=</font> qdata_sequentialize <font color=Cyan>(</font>shapetype_q qa<font color=Cyan>)</font> qa
<a name="line-790"></a>
<a name="line-791"></a><a name="qdata_of_qubits"></a><font color=Blue><i>-- | Take a specimen piece of quantum data to specify the \"shape\"</i></font>
<a name="line-792"></a><font color=Blue><i>-- desired (length of lists, etc); then reads the given list of qubits</i></font>
<a name="line-793"></a><font color=Blue><i>-- in as a piece of quantum data of the same shape. The ordering of</i></font>
<a name="line-794"></a><font color=Blue><i>-- the input qubits is the same as 'qubits_of_qdata' produces for the</i></font>
<a name="line-795"></a><font color=Blue><i>-- given shape.</i></font>
<a name="line-796"></a><font color=Blue><i>-- </i></font>
<a name="line-797"></a><font color=Blue><i>-- A \"length mismatch\" error occurs if the list does not have</i></font>
<a name="line-798"></a><font color=Blue><i>-- exactly the required length.</i></font>
<a name="line-799"></a><font color=Blue>qdata_of_qubits</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> qa <font color=Red>-&gt;</font> <font color=Red>[</font>Qubit<font color=Red>]</font> <font color=Red>-&gt;</font> qa
<a name="line-800"></a><font color=Blue>qdata_of_qubits</font> qa list <font color=Red>=</font> qdata_unsequentialize qa list
<a name="line-801"></a>
<a name="line-802"></a><a name="endpoints_of_qcdata"></a><font color=Blue><i>-- | Return the list of endpoints that form the leaves of the given</i></font>
<a name="line-803"></a><font color=Blue><i>-- 'QCData'. The leaves are ordered in some fixed, but arbitrary</i></font>
<a name="line-804"></a><font color=Blue><i>-- way. It is guaranteed that two pieces of data of the same given</i></font>
<a name="line-805"></a><font color=Blue><i>-- shape will be ordered in the same way. No other property of the</i></font>
<a name="line-806"></a><font color=Blue><i>-- order is guaranteed. In particular, the order may change without notice from</i></font>
<a name="line-807"></a><font color=Blue><i>-- one version of Quipper to the next.</i></font>
<a name="line-808"></a><font color=Blue>endpoints_of_qcdata</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> <font color=Red>[</font>Endpoint<font color=Red>]</font>
<a name="line-809"></a><font color=Blue>endpoints_of_qcdata</font> qc <font color=Red>=</font> qcdata_sequentialize qc qc
<a name="line-810"></a>
<a name="line-811"></a><a name="qcdata_of_endpoints"></a><font color=Blue><i>-- | Take a specimen piece of 'QCData' to specify the \"shape\"</i></font>
<a name="line-812"></a><font color=Blue><i>-- desired (length of lists, etc); then reads the given list of</i></font>
<a name="line-813"></a><font color=Blue><i>-- endpoints in as a piece of quantum data of the same shape. The</i></font>
<a name="line-814"></a><font color=Blue><i>-- ordering of the input endpoints equals that produced by</i></font>
<a name="line-815"></a><font color=Blue><i>-- 'endpoints_of_qcdata' for the given shape.</i></font>
<a name="line-816"></a><font color=Blue><i>-- </i></font>
<a name="line-817"></a><font color=Blue><i>-- A \"length mismatch\" error occurs if the list does not have</i></font>
<a name="line-818"></a><font color=Blue><i>-- exactly the required length. A \"shape mismatch\" error occurs if</i></font>
<a name="line-819"></a><font color=Blue><i>-- the list contains a 'Qubit' when a 'Bit' was expected, or vice versa. </i></font>
<a name="line-820"></a><font color=Blue>qcdata_of_endpoints</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> <font color=Red>[</font>Endpoint<font color=Red>]</font> <font color=Red>-&gt;</font> qc
<a name="line-821"></a><font color=Blue>qcdata_of_endpoints</font> qc list <font color=Red>=</font> qcdata_unsequentialize qc list <font color=Green><u>where</u></font>
<a name="line-822"></a>
<a name="line-823"></a><a name="circuit_type_structure_of_qcdata"></a><font color=Blue><i>-- | Take a specimen piece of 'QCData' to specify a shape;</i></font>
<a name="line-824"></a><font color=Blue><i>-- return a 'CircuitTypeStructure' that structures appropriate</i></font>
<a name="line-825"></a><font color=Blue><i>-- lists of wires with arities into data of this shape, and conversely</i></font>
<a name="line-826"></a><font color=Blue><i>-- destructures data of this shape into wires and an arity.</i></font>
<a name="line-827"></a><font color=Blue><i>--</i></font>
<a name="line-828"></a><font color=Blue><i>-- The caveats mentioned in 'endpoints_of_qcdata' apply equally for</i></font>
<a name="line-829"></a><font color=Blue><i>-- this function.</i></font>
<a name="line-830"></a><font color=Blue>circuit_type_structure_of_qcdata</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> CircuitTypeStructure qc
<a name="line-831"></a><font color=Blue>circuit_type_structure_of_qcdata</font> qc <font color=Red>=</font> CircuitTypeStructure
<a name="line-832"></a>  <font color=Cyan>(</font>wires_with_arity_of_endpoints <font color=Cyan>.</font> endpoints_of_qcdata<font color=Cyan>)</font>
<a name="line-833"></a>  <font color=Cyan>(</font><font color=Red>\</font><font color=Cyan>(</font>ws<font color=Cyan>,</font>a<font color=Cyan>)</font> <font color=Red>-&gt;</font> qcdata_of_endpoints qc <font color=Cyan>$</font> endpoints_of_wires_in_arity a ws<font color=Cyan>)</font>
<a name="line-834"></a>
<a name="line-835"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-836"></a><font color=Blue><i>-- * Shape related operations</i></font>
<a name="line-837"></a>
<a name="line-838"></a><a name="qc_false"></a><font color=Blue><i>-- | Return a boolean data structure of the given shape, with every</i></font>
<a name="line-839"></a><font color=Blue><i>-- leaf initialized to 'False'.</i></font>
<a name="line-840"></a><font color=Blue>qc_false</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> BType qc
<a name="line-841"></a><font color=Blue>qc_false</font> qc <font color=Red>=</font> qcdata_map qc map_qubit map_bit qc 
<a name="line-842"></a>  <font color=Green><u>where</u></font>
<a name="line-843"></a>    map_qubit <font color=Red>=</font> const False <font color=Red>::</font> Qubit <font color=Red>-&gt;</font> Bool
<a name="line-844"></a>    map_bit <font color=Red>=</font> const False <font color=Red>::</font> Bit <font color=Red>-&gt;</font> Bool
<a name="line-845"></a>
<a name="line-846"></a><a name="qshape"></a><font color=Blue><i>-- | Return a quantum data structure of the given boolean shape, with</i></font>
<a name="line-847"></a><font color=Blue><i>-- every leaf initialized to the undefined dummy value 'qubit'.</i></font>
<a name="line-848"></a><font color=Blue>qshape</font> <font color=Red>::</font> <font color=Cyan>(</font>QData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> BType qa <font color=Red>-&gt;</font> qa
<a name="line-849"></a><font color=Blue>qshape</font> ba <font color=Red>=</font> qdata_map <font color=Cyan>(</font>shapetype_b ba<font color=Cyan>)</font> map_qubit ba
<a name="line-850"></a>  <font color=Green><u>where</u></font>
<a name="line-851"></a>    map_qubit <font color=Red>=</font> const qubit <font color=Red>::</font> Bool <font color=Red>-&gt;</font> Qubit
<a name="line-852"></a>
<a name="line-853"></a><font color=Blue><i>-- ----------------------------------------------------------------------</i></font>
<a name="line-854"></a><font color=Blue><i>-- * Bindings</i></font>
<a name="line-855"></a>
<a name="line-856"></a><a name="qc_bind"></a><font color=Blue><i>-- | Take two pieces of quantum data of the same shape (the first of</i></font>
<a name="line-857"></a><font color=Blue><i>-- which consists of wires of a low-level circuit) and create</i></font>
<a name="line-858"></a><font color=Blue><i>-- bindings.</i></font>
<a name="line-859"></a><font color=Blue>qc_bind</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> QCType a b qc <font color=Red>-&gt;</font> Bindings a b
<a name="line-860"></a><font color=Blue>qc_bind</font> qc <font color=Green><u>as</u></font> <font color=Red>=</font> qc_bind_aux qc <font color=Green><u>as</u></font> bindings_empty
<a name="line-861"></a>  <font color=Green><u>where</u></font>
<a name="line-862"></a>    <font color=Blue><i>-- This can't be inlined without upsetting the type checker.</i></font>
<a name="line-863"></a>    qc_bind_aux <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> QCType a b qc <font color=Red>-&gt;</font> Bindings a b <font color=Red>-&gt;</font> Bindings a b
<a name="line-864"></a>    qc_bind_aux qc <font color=Green><u>as</u></font> <font color=Cyan>(</font>bind_in <font color=Red>::</font> Bindings a b<font color=Cyan>)</font> <font color=Red>=</font> bindings <font color=Green><u>where</u></font>
<a name="line-865"></a>      a <font color=Red>=</font> <font color=Cyan>(</font>dummy <font color=Red>::</font> a<font color=Cyan>)</font> <font color=Blue><i>-- shape type</i></font>
<a name="line-866"></a>      b <font color=Red>=</font> <font color=Cyan>(</font>dummy <font color=Red>::</font> b<font color=Cyan>)</font> <font color=Blue><i>-- shape type</i></font>
<a name="line-867"></a>      z <font color=Red>=</font> qcdata_zip qc qubit bit a b qc <font color=Green><u>as</u></font> errmsg
<a name="line-868"></a>      bindings <font color=Red>=</font> qcdata_fold qc do_qubit do_bit z bind_in
<a name="line-869"></a>  
<a name="line-870"></a>    do_qubit <font color=Red>::</font> <font color=Cyan>(</font>Qubit<font color=Cyan>,</font> a<font color=Cyan>)</font> <font color=Red>-&gt;</font> Bindings a b <font color=Red>-&gt;</font> Bindings a b
<a name="line-871"></a>    do_qubit <font color=Cyan>(</font>q<font color=Cyan>,</font> binding<font color=Cyan>)</font> <font color=Red>=</font> bind_qubit q binding
<a name="line-872"></a>  
<a name="line-873"></a>    do_bit <font color=Red>::</font> <font color=Cyan>(</font>Bit<font color=Cyan>,</font> b<font color=Cyan>)</font> <font color=Red>-&gt;</font> Bindings a b <font color=Red>-&gt;</font> Bindings a b
<a name="line-874"></a>    do_bit <font color=Cyan>(</font>c<font color=Cyan>,</font> binding<font color=Cyan>)</font> <font color=Red>=</font> bind_bit c binding
<a name="line-875"></a>
<a name="line-876"></a>    errmsg s <font color=Red>=</font> <font color=Magenta>"qc_bind: shapes of arguments do not match: "</font> <font color=Cyan>++</font> s
<a name="line-877"></a>
<a name="line-878"></a><a name="qc_unbind"></a><font color=Blue><i>-- | Apply bindings to a piece of quantum and/or classical data</i></font>
<a name="line-879"></a><font color=Blue><i>-- holding low-level wires, to get data of the same shape.</i></font>
<a name="line-880"></a><font color=Blue>qc_unbind</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> Bindings a b <font color=Red>-&gt;</font> qc <font color=Red>-&gt;</font> QCType a b qc
<a name="line-881"></a><font color=Blue>qc_unbind</font> <font color=Cyan>(</font>bindings <font color=Red>::</font> Bindings a b<font color=Cyan>)</font> qc <font color=Red>=</font>
<a name="line-882"></a>  qcdata_map qc map_qubit map_bit qc
<a name="line-883"></a>  <font color=Green><u>where</u></font>
<a name="line-884"></a>    map_qubit <font color=Red>::</font> Qubit <font color=Red>-&gt;</font> a
<a name="line-885"></a>    map_qubit q <font color=Red>=</font> unbind_qubit bindings q
<a name="line-886"></a>    
<a name="line-887"></a>    map_bit <font color=Red>::</font> Bit <font color=Red>-&gt;</font> b
<a name="line-888"></a>    map_bit b <font color=Red>=</font> unbind_bit bindings b
<a name="line-889"></a>
<a name="line-890"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-891"></a><font color=Blue><i>-- * Generic controls</i></font>
<a name="line-892"></a>
<a name="line-893"></a><font color=Blue><i>-- $CONTROL The following functions define a convenient syntax for</i></font>
<a name="line-894"></a><font color=Blue><i>-- controls. With this, we can write controls in much the same way as</i></font>
<a name="line-895"></a><font color=Blue><i>-- one would write (a restricted class of) boolean</i></font>
<a name="line-896"></a><font color=Blue><i>-- expressions. Examples:</i></font>
<a name="line-897"></a><font color=Blue><i>-- </i></font>
<a name="line-898"></a><font color=Blue><i>-- &gt; q1 .==. 0 .&amp;&amp;. q2 .==. 1         for Qubits q1, q2</i></font>
<a name="line-899"></a><font color=Blue><i>-- </i></font>
<a name="line-900"></a><font color=Blue><i>-- &gt; q .&amp;&amp;. p                         means  q .==. 1  .&amp;&amp;.  p .==. 1</i></font>
<a name="line-901"></a><font color=Blue><i>-- </i></font>
<a name="line-902"></a><font color=Blue><i>-- &gt; qx .==. 5                        for a QDInt qx</i></font>
<a name="line-903"></a><font color=Blue><i>-- </i></font>
<a name="line-904"></a><font color=Blue><i>-- &gt; q1 .==. 0 .&amp;&amp;. z &lt;= 7            we can combine quantum and classical controls</i></font>
<a name="line-905"></a><font color=Blue><i>-- </i></font>
<a name="line-906"></a><font color=Blue><i>-- &gt; q ./=. b                         the negation of q .==. b;</i></font>
<a name="line-907"></a><font color=Blue><i>-- &gt;                                  here b is a boolean.</i></font>
<a name="line-908"></a><font color=Blue><i>-- </i></font>
<a name="line-909"></a><font color=Blue><i>-- &gt; [p,q,r,s]                        a list of positive controls</i></font>
<a name="line-910"></a><font color=Blue><i>-- </i></font>
<a name="line-911"></a><font color=Blue><i>-- &gt; [(p, True), (q, False), (r, False), (s, True)]</i></font>
<a name="line-912"></a><font color=Blue><i>-- &gt;                                  a list of positive and negative controls</i></font>
<a name="line-913"></a><font color=Blue><i>--</i></font>
<a name="line-914"></a><font color=Blue><i>-- Among these infix operators, @(.&amp;&amp;.)@ binds more weakly than</i></font>
<a name="line-915"></a><font color=Blue><i>-- @(.==.)@, @(./=.)@.</i></font>
<a name="line-916"></a>
<a name="line-917"></a><a name="qc_control"></a><font color=Blue><i>-- | Given a piece of quantum data and a possible value for it, return</i></font>
<a name="line-918"></a><font color=Blue><i>-- a 'ControlList' representing the condition that the quantum data</i></font>
<a name="line-919"></a><font color=Blue><i>-- has that value.</i></font>
<a name="line-920"></a><font color=Blue><i>-- </i></font>
<a name="line-921"></a><font color=Blue><i>-- If some aspect of the value's shape is indeterminate, it is</i></font>
<a name="line-922"></a><font color=Blue><i>-- promoted to the same shape as the quantum data; therefore, it is</i></font>
<a name="line-923"></a><font color=Blue><i>-- possible, for example, to write:</i></font>
<a name="line-924"></a><font color=Blue><i>-- </i></font>
<a name="line-925"></a><font color=Blue><i>-- &gt; qc_control qa 17          -- when qa :: QDInt</i></font>
<a name="line-926"></a><font color=Blue><i>-- &gt; qc_control qa [False..]   -- when qa :: [Qubit]</i></font>
<a name="line-927"></a><font color=Blue>qc_control</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> BType qc <font color=Red>-&gt;</font> ControlList
<a name="line-928"></a><font color=Blue>qc_control</font> qc b <font color=Red>=</font> clist <font color=Green><u>where</u></font>
<a name="line-929"></a>  b' <font color=Red>=</font> qcdata_promote b qc errmsg
<a name="line-930"></a>  z <font color=Red>=</font> qcdata_zip qc qubit bit bool bool qc b' errmsg
<a name="line-931"></a>  clist <font color=Red>=</font> qcdata_fold qc do_qubit do_bit z clist_empty
<a name="line-932"></a>  
<a name="line-933"></a>  do_qubit <font color=Red>::</font> <font color=Cyan>(</font>Qubit<font color=Cyan>,</font> Bool<font color=Cyan>)</font> <font color=Red>-&gt;</font> ControlList <font color=Red>-&gt;</font> ControlList
<a name="line-934"></a>  do_qubit <font color=Cyan>(</font>q<font color=Cyan>,</font> b<font color=Cyan>)</font> <font color=Red>=</font> clist_add_qubit q b
<a name="line-935"></a>  
<a name="line-936"></a>  do_bit <font color=Red>::</font> <font color=Cyan>(</font>Bit<font color=Cyan>,</font> Bool<font color=Cyan>)</font> <font color=Red>-&gt;</font> ControlList <font color=Red>-&gt;</font> ControlList
<a name="line-937"></a>  do_bit <font color=Cyan>(</font>c<font color=Cyan>,</font> b<font color=Cyan>)</font> <font color=Red>=</font> clist_add_bit c b
<a name="line-938"></a>
<a name="line-939"></a>  errmsg s <font color=Red>=</font> <font color=Magenta>"qc_control: shape of control value does not match data: "</font> <font color=Cyan>++</font> s
<a name="line-940"></a>
<a name="line-941"></a><a name=".&&."></a><font color=Blue><i>-- | This is an infix operator to concatenate two controls, forming</i></font>
<a name="line-942"></a><font color=Blue><i>-- their logical conjunction.</i></font>
<a name="line-943"></a><font color=Cyan>(</font><font color=Cyan>.&amp;&amp;.</font><font color=Cyan>)</font> <font color=Red>::</font> <font color=Cyan>(</font>ControlSource a<font color=Cyan>,</font> ControlSource b<font color=Cyan>)</font> <font color=Red>=&gt;</font> a <font color=Red>-&gt;</font> b <font color=Red>-&gt;</font> ControlList
<a name="line-944"></a><a name="exp1"></a><font color=Blue>exp1</font> <font color=Cyan>.&amp;&amp;.</font> exp2 <font color=Red>=</font> combine <font color=Cyan>(</font>to_control exp1<font color=Cyan>)</font> <font color=Cyan>(</font>to_control exp2<font color=Cyan>)</font>
<a name="line-945"></a>
<a name="line-946"></a><a name=".==."></a><font color=Blue><i>-- | @(qx .==. x)@: a control which is true just if quantum data /qx/ is in the specified state /x/. </i></font>
<a name="line-947"></a><font color=Cyan>(</font><font color=Cyan>.==.</font><font color=Cyan>)</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> BType qc <font color=Red>-&gt;</font> ControlList
<a name="line-948"></a><a name="qx"></a><font color=Blue>qx</font> <font color=Cyan>.==.</font> x <font color=Red>=</font> qc_control qx x
<a name="line-949"></a>
<a name="line-950"></a><a name="./=."></a><font color=Blue><i>-- | The notation @(q ./=. x)@ is shorthand for @(q .==. not x)@, when</i></font>
<a name="line-951"></a><font color=Blue><i>-- /x/ is a boolean parameter. </i></font>
<a name="line-952"></a><font color=Blue><i>-- </i></font>
<a name="line-953"></a><font color=Blue><i>-- Unlike '.==.', which is defined for any shape of quantum data,</i></font>
<a name="line-954"></a><font color=Blue><i>-- './=.' is only defined for a single control bit or qubit.</i></font>
<a name="line-955"></a><font color=Cyan>(</font><font color=Cyan>./=.</font><font color=Cyan>)</font> <font color=Red>::</font> <font color=Cyan>(</font>QCLeaf q<font color=Cyan>)</font> <font color=Red>=&gt;</font> q <font color=Red>-&gt;</font> Bool <font color=Red>-&gt;</font> ControlList
<a name="line-956"></a><a name="q"></a><font color=Blue>q</font> <font color=Cyan>./=.</font> b <font color=Red>=</font> to_control <font color=Red>[</font>Signed q <font color=Cyan>(</font>not b<font color=Cyan>)</font><font color=Red>]</font>
<a name="line-957"></a>
<a name="line-958"></a><font color=Blue><i>-- Set the precedence for infix operators '.&amp;&amp;.', '.==.', and './=.'.</i></font>
<a name="line-959"></a><font color=Green><u>infixr</u></font> <font color=Magenta>3</font> <font color=Cyan>.&amp;&amp;.</font> <font color=Blue><i>-- same precedence as (&amp;&amp;)</i></font>
<a name="line-960"></a><font color=Green><u>infix</u></font> <font color=Magenta>4</font> <font color=Cyan>.==.</font> <font color=Blue><i>-- same precedence as (==)</i></font>
<a name="line-961"></a><font color=Green><u>infix</u></font> <font color=Magenta>4</font> <font color=Cyan>./=.</font> <font color=Blue><i>-- same precedence as (/=)</i></font>
<a name="line-962"></a>
<a name="line-963"></a><font color=Blue><i>-- The following allows us to write 0 and 1 instead of 'False' and</i></font>
<a name="line-964"></a><font color=Blue><i>-- 'True' everywhere.</i></font>
<a name="line-965"></a><font color=Green><u>instance</u></font> Num Bool <font color=Green><u>where</u></font>
<a name="line-966"></a>  <font color=Cyan>(</font><font color=Cyan>+</font><font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font><font color=Cyan>/=</font><font color=Cyan>)</font> 
<a name="line-967"></a>  <font color=Cyan>(</font><font color=Cyan>*</font><font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font><font color=Cyan>&amp;&amp;</font><font color=Cyan>)</font>
<a name="line-968"></a>  <font color=Cyan>(</font><font color=Blue><i>-</i></font><font color=Cyan>)</font> <font color=Red>=</font> <font color=Cyan>(</font><font color=Cyan>/=</font><font color=Cyan>)</font>
<a name="line-969"></a>  negate <font color=Red>=</font> id
<a name="line-970"></a>  signum <font color=Red>=</font> id
<a name="line-971"></a>  abs <font color=Red>=</font> id
<a name="line-972"></a>  fromInteger n <font color=Red>=</font> <font color=Cyan>(</font>n <font color=Cyan>`mod`</font> <font color=Magenta>2</font> <font color=Cyan>==</font> <font color=Magenta>1</font><font color=Cyan>)</font>
<a name="line-973"></a>
<a name="line-974"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-975"></a><font color=Blue><i>-- * Generic encapsulation</i></font>
<a name="line-976"></a>
<a name="line-977"></a><font color=Blue><i>-- $encapsulate</i></font>
<a name="line-978"></a><font color=Blue><i>-- </i></font>
<a name="line-979"></a><font color=Blue><i>-- An encapsulated circuit is a low-level circuit together with data</i></font>
<a name="line-980"></a><font color=Blue><i>-- structures holding the input endpoints and output endpoints. A</i></font>
<a name="line-981"></a><font color=Blue><i>-- circuit-generating function, with fully specified parameters, can</i></font>
<a name="line-982"></a><font color=Blue><i>-- be turned into an encapsulated circuit; conversely, an encapsulated</i></font>
<a name="line-983"></a><font color=Blue><i>-- circuit can be turned into a circuit-generating function. Thus,</i></font>
<a name="line-984"></a><font color=Blue><i>-- encapsulation and unencapsulation are the main interface for</i></font>
<a name="line-985"></a><font color=Blue><i>-- passing between high- and low-level data structures.</i></font>
<a name="line-986"></a>
<a name="line-987"></a><a name="qc_alloc"></a><font color=Blue><i>-- | Allocate new quantum data of the given shape, in the given</i></font>
<a name="line-988"></a><font color=Blue><i>-- arity. Returns the quantum data and the updated arity.</i></font>
<a name="line-989"></a><font color=Blue>qc_alloc</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qc<font color=Cyan>)</font> <font color=Red>=&gt;</font> qc <font color=Red>-&gt;</font> ExtArity <font color=Red>-&gt;</font> <font color=Cyan>(</font>qc<font color=Cyan>,</font> ExtArity<font color=Cyan>)</font>
<a name="line-990"></a><font color=Blue>qc_alloc</font> qc arity <font color=Red>=</font> qcdata_fold_map qc do_qubit do_bit qc arity <font color=Green><u>where</u></font>
<a name="line-991"></a>  
<a name="line-992"></a>  do_qubit <font color=Red>::</font> Qubit <font color=Red>-&gt;</font> ExtArity <font color=Red>-&gt;</font> <font color=Cyan>(</font>Qubit<font color=Cyan>,</font> ExtArity<font color=Cyan>)</font>
<a name="line-993"></a>  do_qubit q arity <font color=Red>=</font> <font color=Cyan>(</font>qubit_of_wire w<font color=Cyan>,</font> a<font color=Cyan>)</font> 
<a name="line-994"></a>    <font color=Green><u>where</u></font>
<a name="line-995"></a>      <font color=Cyan>(</font>w<font color=Cyan>,</font> a<font color=Cyan>)</font> <font color=Red>=</font> arity_alloc Qbit arity
<a name="line-996"></a>  
<a name="line-997"></a>  do_bit <font color=Red>::</font> Bit <font color=Red>-&gt;</font> ExtArity <font color=Red>-&gt;</font> <font color=Cyan>(</font>Bit<font color=Cyan>,</font> ExtArity<font color=Cyan>)</font>
<a name="line-998"></a>  do_bit c arity <font color=Red>=</font> <font color=Cyan>(</font>bit_of_wire w<font color=Cyan>,</font> a<font color=Cyan>)</font>
<a name="line-999"></a>    <font color=Green><u>where</u></font>
<a name="line-1000"></a>      <font color=Cyan>(</font>w<font color=Cyan>,</font> a<font color=Cyan>)</font> <font color=Red>=</font> arity_alloc Cbit arity
<a name="line-1001"></a>
<a name="line-1002"></a><a name="encapsulate_generic"></a><font color=Blue><i>-- | Extract an encapsulated circuit from a circuit-generating</i></font>
<a name="line-1003"></a><font color=Blue><i>-- function. This requires a shape parameter.</i></font>
<a name="line-1004"></a><font color=Blue>encapsulate_generic</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>)</font> <font color=Red>=&gt;</font> ErrMsg <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> Circ y<font color=Cyan>)</font> <font color=Red>-&gt;</font> x <font color=Red>-&gt;</font> <font color=Cyan>(</font>x<font color=Cyan>,</font> BCircuit<font color=Cyan>,</font> y<font color=Cyan>)</font>
<a name="line-1005"></a><font color=Blue>encapsulate_generic</font> e f shape <font color=Red>=</font> <font color=Cyan>(</font>x<font color=Cyan>,</font> circ<font color=Cyan>,</font> y<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-1006"></a>  <font color=Cyan>(</font>x<font color=Cyan>,</font> arity<font color=Cyan>)</font> <font color=Red>=</font> qc_alloc shape arity_empty
<a name="line-1007"></a>  <font color=Cyan>(</font>circ<font color=Cyan>,</font> y<font color=Cyan>)</font> <font color=Red>=</font> extract_simple e arity <font color=Cyan>(</font>f x<font color=Cyan>)</font>
<a name="line-1008"></a>
<a name="line-1009"></a><a name="encapsulate_generic_in_namespace"></a><font color=Blue><i>-- | As 'encapsulate_generic', but passes the current namespace</i></font>
<a name="line-1010"></a><font color=Blue><i>-- into the circuit-generating function, to save recomputing</i></font>
<a name="line-1011"></a><font color=Blue><i>-- shared subroutines</i></font>
<a name="line-1012"></a><font color=Blue>encapsulate_generic_in_namespace</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>)</font> <font color=Red>=&gt;</font> ErrMsg <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> Circ y<font color=Cyan>)</font> <font color=Red>-&gt;</font> x <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>x<font color=Cyan>,</font> BCircuit<font color=Cyan>,</font> y<font color=Cyan>)</font>
<a name="line-1013"></a><font color=Blue>encapsulate_generic_in_namespace</font> e f shape <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1014"></a>  <font color=Green><u>let</u></font> <font color=Cyan>(</font>x<font color=Cyan>,</font> arity<font color=Cyan>)</font> <font color=Red>=</font> qc_alloc shape arity_empty
<a name="line-1015"></a>  <font color=Cyan>(</font>circ<font color=Cyan>,</font> y<font color=Cyan>)</font> <font color=Red>&lt;-</font> extract_in_current_namespace e arity <font color=Cyan>(</font>f x<font color=Cyan>)</font>
<a name="line-1016"></a>  return <font color=Cyan>(</font>x<font color=Cyan>,</font> circ<font color=Cyan>,</font> y<font color=Cyan>)</font>
<a name="line-1017"></a>
<a name="line-1018"></a><a name="unencapsulate_generic"></a><font color=Blue><i>-- | Turn an encapsulated circuit back into a circuit-generating</i></font>
<a name="line-1019"></a><font color=Blue><i>-- function.</i></font>
<a name="line-1020"></a><font color=Blue>unencapsulate_generic</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>,</font> QCData y<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>x<font color=Cyan>,</font> BCircuit<font color=Cyan>,</font> y<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> Circ y<font color=Cyan>)</font>
<a name="line-1021"></a><font color=Blue>unencapsulate_generic</font> <font color=Cyan>(</font>c_in<font color=Cyan>,</font> c<font color=Cyan>,</font> c_out<font color=Cyan>)</font> input <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1022"></a>  <font color=Green><u>let</u></font> in_bindings <font color=Red>=</font> qc_bind c_in input
<a name="line-1023"></a>  out_bindings <font color=Red>&lt;-</font> apply_bcircuit_with_bindings c in_bindings
<a name="line-1024"></a>  <font color=Green><u>let</u></font> output <font color=Red>=</font> qc_unbind out_bindings c_out
<a name="line-1025"></a>  return output
<a name="line-1026"></a>
<a name="line-1027"></a><font color=Blue><i>-- $dynamic_encapsulate</i></font>
<a name="line-1028"></a><font color=Blue><i>-- </i></font>
<a name="line-1029"></a><font color=Blue><i>-- A dynamic encapsulated circuit is to an encapsulated circuit like a</i></font>
<a name="line-1030"></a><font color=Blue><i>-- 'DBCircuit' to a 'BCircuit'. The output is not a static circuit,</i></font>
<a name="line-1031"></a><font color=Blue><i>-- but an interactive computation expressed through the 'ReadWrite'</i></font>
<a name="line-1032"></a><font color=Blue><i>-- monad, which can be run on a quantum device to get a static circuit</i></font>
<a name="line-1033"></a><font color=Blue><i>-- out.</i></font>
<a name="line-1034"></a>
<a name="line-1035"></a><a name="encapsulate_dynamic"></a><font color=Blue><i>-- | Extract an encapsulated dynamic circuit from a circuit-generating</i></font>
<a name="line-1036"></a><font color=Blue><i>-- function. This requires a shape parameter.</i></font>
<a name="line-1037"></a><font color=Blue>encapsulate_dynamic</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> Circ y<font color=Cyan>)</font> <font color=Red>-&gt;</font> x <font color=Red>-&gt;</font> <font color=Cyan>(</font>x<font color=Cyan>,</font> DBCircuit y<font color=Cyan>)</font>
<a name="line-1038"></a><font color=Blue>encapsulate_dynamic</font> f shape <font color=Red>=</font> <font color=Cyan>(</font>x<font color=Cyan>,</font> comp<font color=Cyan>)</font> <font color=Green><u>where</u></font>
<a name="line-1039"></a>  <font color=Cyan>(</font>x<font color=Cyan>,</font> arity<font color=Cyan>)</font> <font color=Red>=</font> qc_alloc shape arity_empty
<a name="line-1040"></a>  comp <font color=Red>=</font> extract_general arity <font color=Cyan>(</font>f x<font color=Cyan>)</font>
<a name="line-1041"></a>
<a name="line-1042"></a><a name="unencapsulate_dynamic"></a><font color=Blue><i>-- | Turn an encapsulated dynamic circuit back into a</i></font>
<a name="line-1043"></a><font color=Blue><i>-- circuit-generating function.</i></font>
<a name="line-1044"></a><font color=Blue><i>-- </i></font>
<a name="line-1045"></a><font color=Blue><i>-- This currently fails if the dynamic circuit contains output</i></font>
<a name="line-1046"></a><font color=Blue><i>-- liftings, because the transformer interface has not yet been</i></font>
<a name="line-1047"></a><font color=Blue><i>-- updated to work with dynamic circuits.</i></font>
<a name="line-1048"></a><font color=Blue>unencapsulate_dynamic</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>,</font> QCData y<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>x<font color=Cyan>,</font> DBCircuit y<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> Circ y<font color=Cyan>)</font>
<a name="line-1049"></a><font color=Blue>unencapsulate_dynamic</font> <font color=Cyan>(</font>c_in<font color=Cyan>,</font> comp<font color=Cyan>)</font> input <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1050"></a>  <font color=Green><u>let</u></font> in_bindings <font color=Red>=</font> qc_bind c_in input
<a name="line-1051"></a>  <font color=Cyan>(</font>out_bindings<font color=Cyan>,</font> c_out<font color=Cyan>)</font> <font color=Red>&lt;-</font> apply_dbcircuit_with_bindings comp in_bindings
<a name="line-1052"></a>  <font color=Green><u>let</u></font> output <font color=Red>=</font> qc_unbind out_bindings c_out
<a name="line-1053"></a>  return output
<a name="line-1054"></a>
<a name="line-1055"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-1056"></a><font color=Blue><i>-- * Generic reversing</i></font>
<a name="line-1057"></a>
<a name="line-1058"></a><a name="reverse_errmsg"></a><font color=Blue><i>-- | Like 'reverse_unary', but also takes a stub error message. </i></font>
<a name="line-1059"></a><font color=Blue>reverse_errmsg</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>,</font> QCData y<font color=Cyan>)</font> <font color=Red>=&gt;</font> ErrMsg <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> Circ y<font color=Cyan>)</font> <font color=Red>-&gt;</font> x <font color=Red>-&gt;</font> <font color=Cyan>(</font>y <font color=Red>-&gt;</font> Circ x<font color=Cyan>)</font>
<a name="line-1060"></a><font color=Blue>reverse_errmsg</font> e f shape y <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1061"></a>  circuit <font color=Red>&lt;-</font> encapsulate_generic_in_namespace errmsg f shape
<a name="line-1062"></a>  <font color=Green><u>let</u></font> circuit_inv <font color=Red>=</font> reverse_encapsulated circuit
<a name="line-1063"></a>      f_inv <font color=Red>=</font> unencapsulate_generic circuit_inv
<a name="line-1064"></a>  f_inv y
<a name="line-1065"></a>  <font color=Green><u>where</u></font>
<a name="line-1066"></a>    errmsg x <font color=Red>=</font> e <font color=Cyan>(</font><font color=Magenta>"operation not permitted in reversible circuit: "</font> <font color=Cyan>++</font> x<font color=Cyan>)</font>
<a name="line-1067"></a>
<a name="line-1068"></a><a name="reverse_unary"></a><font color=Blue><i>-- | Reverse a non-curried circuit-generating function. The second</i></font>
<a name="line-1069"></a><font color=Blue><i>-- parameter is a shape parameter.</i></font>
<a name="line-1070"></a><font color=Blue>reverse_unary</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>,</font> QCData y<font color=Cyan>)</font> <font color=Red>=&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> Circ y<font color=Cyan>)</font> <font color=Red>-&gt;</font> x <font color=Red>-&gt;</font> <font color=Cyan>(</font>y <font color=Red>-&gt;</font> Circ x<font color=Cyan>)</font>
<a name="line-1071"></a><font color=Blue>reverse_unary</font> <font color=Red>=</font> reverse_errmsg errmsg 
<a name="line-1072"></a>  <font color=Green><u>where</u></font>
<a name="line-1073"></a>    errmsg x <font color=Red>=</font> <font color=Magenta>"reverse_unary: "</font> <font color=Cyan>++</font> x
<a name="line-1074"></a>
<a name="line-1075"></a><a name="reverse_generic"></a><font color=Blue><i>-- | Reverse a circuit-generating function. The reversed function</i></font>
<a name="line-1076"></a><font color=Blue><i>-- requires a shape parameter, given as the input type of the original</i></font>
<a name="line-1077"></a><font color=Blue><i>-- function.</i></font>
<a name="line-1078"></a><font color=Blue><i>-- </i></font>
<a name="line-1079"></a><font color=Blue><i>-- The type of this highly overloaded function is quite difficult to</i></font>
<a name="line-1080"></a><font color=Blue><i>-- read.  It can have for example the following types:</i></font>
<a name="line-1081"></a><font color=Blue><i>-- </i></font>
<a name="line-1082"></a><font color=Blue><i>-- &gt; reverse_generic :: (QCData x, QCData y) =&gt; (x -&gt; Circ y) -&gt; x -&gt; (y -&gt; Circ x) </i></font>
<a name="line-1083"></a><font color=Blue><i>-- &gt; reverse_generic :: (QCData x, QCData y, QCData z) =&gt; (x -&gt; y -&gt; Circ z) -&gt; x -&gt; y -&gt; (z -&gt; Circ (x,y)) </i></font>
<a name="line-1084"></a><font color=Blue>reverse_generic</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>,</font> QCData y<font color=Cyan>,</font> TupleOrUnary xt x<font color=Cyan>,</font> QCurry x_y x y<font color=Cyan>,</font> Curry x_y_xt x <font color=Cyan>(</font>y <font color=Red>-&gt;</font> Circ xt<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>=&gt;</font> x_y <font color=Red>-&gt;</font> x_y_xt
<a name="line-1085"></a><font color=Blue>reverse_generic</font> f <font color=Red>=</font> 
<a name="line-1086"></a>  mcurry <font color=Cyan>$</font> aux f
<a name="line-1087"></a>  <font color=Green><u>where</u></font>
<a name="line-1088"></a>    <font color=Blue><i>-- An auxiliary function for defining 'reverse_generic'.  (Inlining</i></font>
<a name="line-1089"></a>    <font color=Blue><i>-- this causes difficulty with the type inference for 'mcurry'.)</i></font>
<a name="line-1090"></a>    <font color=Blue><i>--aux :: (QCData x, QCData y, TupleOrUnary xt x, QCurry x_y x y) =&gt; x_y -&gt; x -&gt; (y -&gt; Circ xt)</i></font>
<a name="line-1091"></a>    aux f shape <font color=Red>=</font>
<a name="line-1092"></a>      <font color=Cyan>(</font>fmap weak_tuple<font color=Cyan>)</font> <font color=Cyan>.</font> <font color=Cyan>(</font>reverse_errmsg errmsg <font color=Cyan>(</font>quncurry f<font color=Cyan>)</font> shape<font color=Cyan>)</font>
<a name="line-1093"></a>
<a name="line-1094"></a>    errmsg x <font color=Red>=</font> <font color=Magenta>"reverse_generic: "</font> <font color=Cyan>++</font> x
<a name="line-1095"></a>
<a name="line-1096"></a><a name="reverse_generic_curried"></a><font color=Blue><i>-- | Like 'reverse_generic', but takes functions whose output is a</i></font>
<a name="line-1097"></a><font color=Blue><i>-- tuple, and curries the reversed function.  Differs from</i></font>
<a name="line-1098"></a><font color=Blue><i>-- 'reverse_generic' in an example such as:</i></font>
<a name="line-1099"></a><font color=Blue><i>-- </i></font>
<a name="line-1100"></a><font color=Blue><i>-- &gt; f                         :: (x -&gt; y -&gt; Circ (z,w))</i></font>
<a name="line-1101"></a><font color=Blue><i>-- &gt; reverse_generic f         :: x -&gt; y -&gt; ((z,w) -&gt; Circ (x,y))</i></font>
<a name="line-1102"></a><font color=Blue><i>-- &gt; reverse_generic_curried f :: x -&gt; y -&gt; (z -&gt; w -&gt; Circ (x,y))</i></font>
<a name="line-1103"></a><font color=Blue><i>-- </i></font>
<a name="line-1104"></a><font color=Blue><i>-- Note: the output /must/ be a /n/-tuple, where /n/ = 0 or /n/ &#8805;</i></font>
<a name="line-1105"></a><font color=Blue><i>-- 2. Applying this to a circuit whose output is a non-tuple type is a</i></font>
<a name="line-1106"></a><font color=Blue><i>-- type error; in this case, 'reverse_generic' should be used.</i></font>
<a name="line-1107"></a><font color=Blue>reverse_generic_curried</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>,</font> QCData y<font color=Cyan>,</font> TupleOrUnary xt x<font color=Cyan>,</font> Tuple yt y<font color=Cyan>,</font> QCurry x_yt x yt<font color=Cyan>,</font> QCurry y_xt y xt<font color=Cyan>,</font> Curry x_y_xt x y_xt<font color=Cyan>)</font> <font color=Red>=&gt;</font> x_yt <font color=Red>-&gt;</font> x_y_xt
<a name="line-1108"></a><font color=Blue>reverse_generic_curried</font> f <font color=Red>=</font> 
<a name="line-1109"></a>  mcurry <font color=Cyan>$</font> aux f
<a name="line-1110"></a>  <font color=Green><u>where</u></font>
<a name="line-1111"></a>    <font color=Blue><i>-- An auxiliary function for 'reverse_generic_curried'.  (Inlining</i></font>
<a name="line-1112"></a>    <font color=Blue><i>-- this causes difficulty with the type inference for 'mcurry'.)</i></font>
<a name="line-1113"></a>    aux <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>,</font> QCData y<font color=Cyan>,</font> TupleOrUnary xt x<font color=Cyan>,</font> Tuple yt y<font color=Cyan>,</font> QCurry x_yt x yt<font color=Cyan>,</font> QCurry y_xt y xt<font color=Cyan>)</font> <font color=Red>=&gt;</font> x_yt <font color=Red>-&gt;</font> x <font color=Red>-&gt;</font> y_xt
<a name="line-1114"></a>    aux f <font color=Red>=</font> 
<a name="line-1115"></a>      <font color=Cyan>(</font>qcurry <font color=Cyan>.</font><font color=Cyan>)</font> <font color=Cyan>$</font> <font color=Red>\</font>x y <font color=Red>-&gt;</font> <font color=Cyan>(</font>fmap weak_tuple<font color=Cyan>)</font> <font color=Cyan>$</font> <font color=Cyan>(</font>reverse_errmsg errmsg <font color=Cyan>$</font> <font color=Cyan>(</font>fmap untuple<font color=Cyan>)</font> <font color=Cyan>.</font> <font color=Cyan>(</font>quncurry f<font color=Cyan>)</font><font color=Cyan>)</font> x y
<a name="line-1116"></a>
<a name="line-1117"></a>    errmsg x <font color=Red>=</font> <font color=Magenta>"reverse_generic_curried: "</font> <font color=Cyan>++</font> x
<a name="line-1118"></a>
<a name="line-1119"></a><a name="reverse_simple"></a><font color=Blue><i>-- | Like 'reverse_generic', but only works at simple types, and</i></font>
<a name="line-1120"></a><font color=Blue><i>-- therefore requires no shape parameters.  Typical type instances:</i></font>
<a name="line-1121"></a><font color=Blue><i>-- </i></font>
<a name="line-1122"></a><font color=Blue><i>-- &gt; reverse_simple :: (QCData_Simple x, QCData y) =&gt; (x -&gt; Circ y) -&gt; (y -&gt; Circ x)</i></font>
<a name="line-1123"></a><font color=Blue><i>-- &gt; reverse_simple :: (QCData_Simple x, QCData_Simple y, QCData z) =&gt; (x -&gt; y -&gt; Circ z) -&gt; (z -&gt; Circ (x,y))</i></font>
<a name="line-1124"></a><font color=Blue>reverse_simple</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData_Simple x<font color=Cyan>,</font> QCData y<font color=Cyan>,</font> TupleOrUnary xt x<font color=Cyan>,</font> QCurry x_y x y<font color=Cyan>)</font> <font color=Red>=&gt;</font> x_y <font color=Red>-&gt;</font> y <font color=Red>-&gt;</font> Circ xt
<a name="line-1125"></a><font color=Blue>reverse_simple</font> f <font color=Red>=</font> <font color=Cyan>(</font>fmap weak_tuple<font color=Cyan>)</font> <font color=Cyan>.</font> <font color=Cyan>(</font>reverse_errmsg errmsg <font color=Cyan>(</font>quncurry f<font color=Cyan>)</font> fs_shape<font color=Cyan>)</font>
<a name="line-1126"></a>  <font color=Green><u>where</u></font>
<a name="line-1127"></a>    errmsg x <font color=Red>=</font> <font color=Magenta>"reverse_simple: "</font> <font color=Cyan>++</font> x
<a name="line-1128"></a>
<a name="line-1129"></a><a name="reverse_simple_curried"></a><font color=Blue><i>-- | Like 'reverse_simple', but takes functions whose output is a</i></font>
<a name="line-1130"></a><font color=Blue><i>-- tuple, and curries the reversed function. Typical type instance:</i></font>
<a name="line-1131"></a><font color=Blue><i>-- </i></font>
<a name="line-1132"></a><font color=Blue><i>-- &gt; reverse_simple_curried :: (QCData_Simple x, QCData y, QCData z) =&gt; (x -&gt; Circ (y,z)) -&gt; (y -&gt; z -&gt; Circ x)</i></font>
<a name="line-1133"></a><font color=Blue><i>-- </i></font>
<a name="line-1134"></a><font color=Blue><i>-- Note: the output /must/ be a /n/-tuple, where /n/ = 0 or /n/ &#8805;</i></font>
<a name="line-1135"></a><font color=Blue><i>-- 2. Applying this to a circuit whose output is a non-tuple type is a</i></font>
<a name="line-1136"></a><font color=Blue><i>-- type error; in this case, 'reverse_generic' should be used.</i></font>
<a name="line-1137"></a><font color=Blue>reverse_simple_curried</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData_Simple x<font color=Cyan>,</font> QCData y<font color=Cyan>,</font> TupleOrUnary xt x<font color=Cyan>,</font> Tuple yt y<font color=Cyan>,</font> QCurry x_yt x yt<font color=Cyan>,</font> QCurry y_xt y xt<font color=Cyan>)</font>
<a name="line-1138"></a>  <font color=Red>=&gt;</font> x_yt <font color=Red>-&gt;</font> y_xt
<a name="line-1139"></a><font color=Blue>reverse_simple_curried</font> f <font color=Red>=</font> qcurry <font color=Cyan>$</font> 
<a name="line-1140"></a>  <font color=Cyan>(</font>fmap weak_tuple<font color=Cyan>)</font> <font color=Cyan>.</font> <font color=Cyan>(</font>reverse_errmsg errmsg <font color=Cyan>(</font><font color=Cyan>(</font>fmap untuple<font color=Cyan>)</font> <font color=Cyan>.</font> <font color=Cyan>(</font>quncurry f<font color=Cyan>)</font><font color=Cyan>)</font> fs_shape<font color=Cyan>)</font>
<a name="line-1141"></a>  <font color=Green><u>where</u></font>
<a name="line-1142"></a>    errmsg x <font color=Red>=</font> <font color=Magenta>"reverse_simple_curried: "</font> <font color=Cyan>++</font> x
<a name="line-1143"></a>
<a name="line-1144"></a><a name="reverse_generic_endo"></a><font color=Blue><i>-- | Like 'reverse_generic', but specialized to endomorphic circuits,</i></font>
<a name="line-1145"></a><font color=Blue><i>-- i.e., circuits where the input and output have the same type (modulo</i></font>
<a name="line-1146"></a><font color=Blue><i>-- possibly currying) and shape. In this case, unlike 'reverse_generic',</i></font>
<a name="line-1147"></a><font color=Blue><i>-- no additional shape parameter is required, and the reversed function</i></font>
<a name="line-1148"></a><font color=Blue><i>-- is curried if the original function was.  Typical type instances:</i></font>
<a name="line-1149"></a><font color=Blue><i>-- </i></font>
<a name="line-1150"></a><font color=Blue><i>-- &gt; reverse_generic_endo :: (QCData x) =&gt; (x -&gt; Circ x) -&gt; (x -&gt; Circ x)</i></font>
<a name="line-1151"></a><font color=Blue><i>-- &gt; reverse_generic_endo :: (QCData x, QCData y) =&gt; (x -&gt; y -&gt; Circ (x,y)) -&gt; (x -&gt; y -&gt; Circ (x,y))</i></font>
<a name="line-1152"></a><font color=Blue>reverse_generic_endo</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>,</font> TupleOrUnary xt x<font color=Cyan>,</font> QCurry x_xt x xt<font color=Cyan>)</font> <font color=Red>=&gt;</font> x_xt <font color=Red>-&gt;</font> x_xt
<a name="line-1153"></a><font color=Blue>reverse_generic_endo</font> <font color=Red>=</font> qcurry <font color=Cyan>.</font> <font color=Cyan>(</font><font color=Cyan>(</font>fmap weak_tuple<font color=Cyan>)</font> <font color=Cyan>.</font><font color=Cyan>)</font> <font color=Cyan>.</font> 
<a name="line-1154"></a>                         <font color=Cyan>(</font><font color=Red>\</font>f x <font color=Red>-&gt;</font> reverse_errmsg errmsg f x x<font color=Cyan>)</font>
<a name="line-1155"></a>                                       <font color=Cyan>.</font> <font color=Cyan>(</font><font color=Cyan>(</font>fmap weak_untuple<font color=Cyan>)</font> <font color=Cyan>.</font><font color=Cyan>)</font> <font color=Cyan>.</font> quncurry
<a name="line-1156"></a>  <font color=Green><u>where</u></font>
<a name="line-1157"></a>    errmsg x <font color=Red>=</font> <font color=Magenta>"reverse_generic_endo: "</font> <font color=Cyan>++</font> x
<a name="line-1158"></a>
<a name="line-1159"></a><a name="reverse_generic_imp"></a><font color=Blue><i>-- | Like 'reverse_generic_endo', but applies to endomorphic circuits</i></font>
<a name="line-1160"></a><font color=Blue><i>-- expressed in \"imperative\" style. Typical type instances:</i></font>
<a name="line-1161"></a><font color=Blue><i>-- </i></font>
<a name="line-1162"></a><font color=Blue><i>-- &gt; reverse_generic_endo :: (QCData x) =&gt; (x -&gt; Circ ()) -&gt; (x -&gt; Circ ())</i></font>
<a name="line-1163"></a><font color=Blue><i>-- &gt; reverse_generic_endo :: (QCData x, QCData y) =&gt; (x -&gt; y -&gt; Circ ()) -&gt; (x -&gt; y -&gt; Circ ())</i></font>
<a name="line-1164"></a><font color=Blue>reverse_generic_imp</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>,</font> QCurry x__ x ()<font color=Cyan>)</font> <font color=Red>=&gt;</font> x__ <font color=Red>-&gt;</font> x__
<a name="line-1165"></a><font color=Blue>reverse_generic_imp</font> f <font color=Red>=</font> qcurry <font color=Cyan>$</font> <font color=Red>\</font>input <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-1166"></a>  reverse_generic_endo f' input
<a name="line-1167"></a>  return ()
<a name="line-1168"></a>  <font color=Green><u>where</u></font>
<a name="line-1169"></a>    f' x <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1170"></a>      <font color=Cyan>(</font>quncurry f<font color=Cyan>)</font> x
<a name="line-1171"></a>      return x
<a name="line-1172"></a>    
<a name="line-1173"></a><a name="reverse_endo_if"></a><font color=Blue><i>-- | Conditional version of 'reverse_generic_endo'. Invert the</i></font>
<a name="line-1174"></a><font color=Blue><i>-- endomorphic quantum circuit if the boolean is true; otherwise,</i></font>
<a name="line-1175"></a><font color=Blue><i>-- insert the non-inverted circuit.</i></font>
<a name="line-1176"></a><font color=Blue>reverse_endo_if</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>,</font> TupleOrUnary xt x<font color=Cyan>,</font> QCurry x_xt x xt<font color=Cyan>)</font> <font color=Red>=&gt;</font> Bool <font color=Red>-&gt;</font> x_xt <font color=Red>-&gt;</font> x_xt
<a name="line-1177"></a><font color=Blue>reverse_endo_if</font> False f <font color=Red>=</font> f
<a name="line-1178"></a><font color=Blue>reverse_endo_if</font> True f <font color=Red>=</font> reverse_generic_endo f
<a name="line-1179"></a>
<a name="line-1180"></a><a name="reverse_imp_if"></a><font color=Blue><i>-- | Conditional version of 'reverse_generic_imp'. Invert the</i></font>
<a name="line-1181"></a><font color=Blue><i>-- imperative style quantum circuit if the boolean is true; otherwise,</i></font>
<a name="line-1182"></a><font color=Blue><i>-- insert the non-inverted circuit.</i></font>
<a name="line-1183"></a><font color=Blue>reverse_imp_if</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qa<font color=Cyan>,</font> QCurry fun qa ()<font color=Cyan>)</font> <font color=Red>=&gt;</font> Bool <font color=Red>-&gt;</font> fun <font color=Red>-&gt;</font> fun
<a name="line-1184"></a><font color=Blue>reverse_imp_if</font> False f <font color=Red>=</font> f
<a name="line-1185"></a><font color=Blue>reverse_imp_if</font> True f <font color=Red>=</font> reverse_generic_imp f
<a name="line-1186"></a>
<a name="line-1187"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-1188"></a><font color=Blue><i>-- * The QCurry type class</i></font>
<a name="line-1189"></a>
<a name="line-1190"></a><font color=Blue><i>-- | The 'QCurry' type class is similar to the 'Curry' type class,</i></font>
<a name="line-1191"></a><font color=Blue><i>-- except that the result type is guarded by the 'Circ' monad. It</i></font>
<a name="line-1192"></a><font color=Blue><i>-- provides a family of type isomorphisms</i></font>
<a name="line-1193"></a><font color=Blue><i>-- </i></font>
<a name="line-1194"></a><font color=Blue><i>-- @fun  &#8773;  args -&gt; Circ res,@</i></font>
<a name="line-1195"></a><font color=Blue><i>-- </i></font>
<a name="line-1196"></a><font color=Blue><i>-- where</i></font>
<a name="line-1197"></a><font color=Blue><i>-- </i></font>
<a name="line-1198"></a><font color=Blue><i>-- &gt; fun = a1 -&gt; a2 -&gt; ... -&gt; an -&gt; Circ res,</i></font>
<a name="line-1199"></a><font color=Blue><i>-- &gt; args = (a1, (a2, (..., (an, ())))).</i></font>
<a name="line-1200"></a><font color=Blue><i>-- </i></font>
<a name="line-1201"></a><font color=Blue><i>-- The benefit of having @Circ@ in the result type is that it ensures</i></font>
<a name="line-1202"></a><font color=Blue><i>-- that the result type is not itself a function type, and therefore</i></font>
<a name="line-1203"></a><font color=Blue><i>-- /fun/ has a /unique/ arity /n/. Then /args/ and /res/ are uniquely</i></font>
<a name="line-1204"></a><font color=Blue><i>-- determined by /fun/, which can be used to write higher-order</i></font>
<a name="line-1205"></a><font color=Blue><i>-- operators that consume /fun/ of any arity and \"do the right</i></font>
<a name="line-1206"></a><font color=Blue><i>-- thing\".</i></font>
<a name="line-1207"></a>  
<a name="line-1208"></a><a name="QCurry"></a><font color=Green><u>class</u></font> QCurry fun args res <font color=Red>|</font> fun <font color=Red>-&gt;</font> args res<font color=Cyan>,</font> args res <font color=Red>-&gt;</font> fun <font color=Green><u>where</u></font>
<a name="line-1209"></a>  qcurry <font color=Red>::</font> <font color=Cyan>(</font>args <font color=Red>-&gt;</font> Circ res<font color=Cyan>)</font> <font color=Red>-&gt;</font> fun
<a name="line-1210"></a>  quncurry <font color=Red>::</font> fun <font color=Red>-&gt;</font> <font color=Cyan>(</font>args <font color=Red>-&gt;</font> Circ res<font color=Cyan>)</font>
<a name="line-1211"></a>  
<a name="line-1212"></a><font color=Green><u>instance</u></font> QCurry <font color=Cyan>(</font>Circ b<font color=Cyan>)</font> () b <font color=Green><u>where</u></font>
<a name="line-1213"></a>  qcurry g <font color=Red>=</font> g ()
<a name="line-1214"></a>  quncurry x <font color=Red>=</font> const x
<a name="line-1215"></a>
<a name="line-1216"></a><font color=Green><u>instance</u></font> QCurry fun args res <font color=Red>=&gt;</font> QCurry <font color=Cyan>(</font>a <font color=Red>-&gt;</font> fun<font color=Cyan>)</font> <font color=Cyan>(</font>a<font color=Cyan>,</font>args<font color=Cyan>)</font> res <font color=Green><u>where</u></font>
<a name="line-1217"></a>  qcurry g x <font color=Red>=</font> qcurry <font color=Cyan>(</font><font color=Red>\</font>xs <font color=Red>-&gt;</font> g <font color=Cyan>(</font>x<font color=Cyan>,</font>xs<font color=Cyan>)</font><font color=Cyan>)</font>
<a name="line-1218"></a>  quncurry f <font color=Cyan>(</font>x<font color=Cyan>,</font>xs<font color=Cyan>)</font> <font color=Red>=</font> quncurry <font color=Cyan>(</font>f x<font color=Cyan>)</font> xs
<a name="line-1219"></a>
<a name="line-1220"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-1221"></a><font color=Blue><i>-- * Generic circuit transformations</i></font>
<a name="line-1222"></a>
<a name="line-1223"></a><a name="transform_errmsg"></a><font color=Blue><i>-- | Like 'transform_unary_shape', but also takes a stub error message.</i></font>
<a name="line-1224"></a><font color=Blue>transform_errmsg</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>,</font> QCData y<font color=Cyan>,</font> x' <font color=Red>~</font> QCType a b x<font color=Cyan>,</font> y' <font color=Red>~</font> QCType a b y<font color=Cyan>,</font> Monad m<font color=Cyan>)</font> <font color=Red>=&gt;</font> ErrMsg <font color=Red>-&gt;</font> Transformer m a b <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> Circ y<font color=Cyan>)</font> <font color=Red>-&gt;</font> x <font color=Red>-&gt;</font> <font color=Cyan>(</font>x' <font color=Red>-&gt;</font> m y'<font color=Cyan>)</font>
<a name="line-1225"></a><font color=Blue>transform_errmsg</font> e transformer f shape input <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1226"></a>  <font color=Green><u>let</u></font> <font color=Cyan>(</font>x<font color=Cyan>,</font> circuit<font color=Cyan>,</font> y<font color=Cyan>)</font> <font color=Red>=</font> encapsulate_generic errmsg f shape
<a name="line-1227"></a>  <font color=Green><u>let</u></font> in_bind <font color=Red>=</font> qc_bind x input
<a name="line-1228"></a>  out_bind <font color=Red>&lt;-</font> transform_bcircuit_rec transformer circuit in_bind
<a name="line-1229"></a>  <font color=Green><u>let</u></font> output <font color=Red>=</font> qc_unbind out_bind y
<a name="line-1230"></a>  return output
<a name="line-1231"></a>  <font color=Green><u>where</u></font>
<a name="line-1232"></a>    errmsg x <font color=Red>=</font> e <font color=Cyan>(</font><font color=Magenta>"operation not currently permitted in transformed circuit: "</font> <font color=Cyan>++</font> x<font color=Cyan>)</font>
<a name="line-1233"></a>
<a name="line-1234"></a><a name="transform_unary_shape"></a><font color=Blue><i>-- | Like 'transform_generic', but applies to arbitrary transformers</i></font>
<a name="line-1235"></a><font color=Blue><i>-- of type</i></font>
<a name="line-1236"></a><font color=Blue><i>-- </i></font>
<a name="line-1237"></a><font color=Blue><i>-- &gt; Transformer m a b</i></font>
<a name="line-1238"></a><font color=Blue><i>-- </i></font>
<a name="line-1239"></a><font color=Blue><i>-- instead of the special case</i></font>
<a name="line-1240"></a><font color=Blue><i>-- </i></font>
<a name="line-1241"></a><font color=Blue><i>-- &gt; Transformer Circ Qubit Bit.</i></font>
<a name="line-1242"></a><font color=Blue><i>-- </i></font>
<a name="line-1243"></a><font color=Blue><i>-- This requires an additional shape argument. </i></font>
<a name="line-1244"></a><font color=Blue>transform_unary_shape</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>,</font> QCData y<font color=Cyan>,</font> x' <font color=Red>~</font> QCType a b x<font color=Cyan>,</font> y' <font color=Red>~</font> QCType a b y<font color=Cyan>,</font> Monad m<font color=Cyan>)</font> <font color=Red>=&gt;</font> Transformer m a b <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> Circ y<font color=Cyan>)</font> <font color=Red>-&gt;</font> x <font color=Red>-&gt;</font> <font color=Cyan>(</font>x' <font color=Red>-&gt;</font> m y'<font color=Cyan>)</font>
<a name="line-1245"></a><font color=Blue>transform_unary_shape</font> <font color=Red>=</font> transform_errmsg errmsg 
<a name="line-1246"></a>  <font color=Green><u>where</u></font>
<a name="line-1247"></a>    errmsg x <font color=Red>=</font> <font color=Magenta>"transform_unary_shape: "</font> <font color=Cyan>++</font> x
<a name="line-1248"></a>
<a name="line-1249"></a><a name="transform_unary"></a><font color=Blue><i>-- | Apply the given transformer to a circuit.</i></font>
<a name="line-1250"></a><font color=Blue>transform_unary</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>,</font> QCData y<font color=Cyan>)</font> <font color=Red>=&gt;</font> Transformer Circ Qubit Bit <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> Circ y<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> Circ y<font color=Cyan>)</font>
<a name="line-1251"></a><font color=Blue>transform_unary</font> transformer f x <font color=Red>=</font> transform_errmsg errmsg transformer f x x
<a name="line-1252"></a>  <font color=Green><u>where</u></font>
<a name="line-1253"></a>    errmsg x <font color=Red>=</font> <font color=Magenta>"transform_unary: "</font> <font color=Cyan>++</font> x
<a name="line-1254"></a>
<a name="line-1255"></a>
<a name="line-1256"></a><a name="transform_unary_dynamic_shape"></a><font color=Blue><i>-- | Like transform_unary_shape but for a dynamic transformer</i></font>
<a name="line-1257"></a><font color=Blue>transform_unary_dynamic_shape</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>,</font> QCData y<font color=Cyan>,</font> x' <font color=Red>~</font> QCType a b x<font color=Cyan>,</font> y' <font color=Red>~</font> QCType a b y<font color=Cyan>,</font> Monad m<font color=Cyan>)</font> <font color=Red>=&gt;</font> DynamicTransformer m a b <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> Circ y<font color=Cyan>)</font> <font color=Red>-&gt;</font> x <font color=Red>-&gt;</font> <font color=Cyan>(</font>x' <font color=Red>-&gt;</font> m y'<font color=Cyan>)</font>
<a name="line-1258"></a><font color=Blue>transform_unary_dynamic_shape</font> dtransformer f shape input <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1259"></a>  <font color=Green><u>let</u></font> <font color=Cyan>(</font>x<font color=Cyan>,</font> dbcircuit<font color=Cyan>)</font> <font color=Red>=</font> encapsulate_dynamic f shape
<a name="line-1260"></a>  <font color=Green><u>let</u></font> in_bind <font color=Red>=</font> qc_bind x input
<a name="line-1261"></a>  <font color=Cyan>(</font>y<font color=Cyan>,</font>out_bind<font color=Cyan>)</font> <font color=Red>&lt;-</font> transform_dbcircuit dtransformer dbcircuit in_bind
<a name="line-1262"></a>  <font color=Green><u>let</u></font> output <font color=Red>=</font> qc_unbind out_bind y
<a name="line-1263"></a>  return output
<a name="line-1264"></a>
<a name="line-1265"></a><a name="transform_unary_dynamic"></a><font color=Blue><i>-- | Like transform_unary but for a dynamic transformer</i></font>
<a name="line-1266"></a><font color=Blue>transform_unary_dynamic</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>,</font> QCData y<font color=Cyan>)</font> <font color=Red>=&gt;</font> DynamicTransformer Circ Qubit Bit <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> Circ y<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> Circ y<font color=Cyan>)</font>
<a name="line-1267"></a><font color=Blue>transform_unary_dynamic</font> dtransformer f x <font color=Red>=</font> transform_unary_dynamic_shape dtransformer f x x
<a name="line-1268"></a>
<a name="line-1269"></a>
<a name="line-1270"></a><font color=Blue><i>-- | Like 'transform_generic', but applies to arbitrary transformers</i></font>
<a name="line-1271"></a><font color=Blue><i>-- of type</i></font>
<a name="line-1272"></a><font color=Blue><i>-- </i></font>
<a name="line-1273"></a><font color=Blue><i>-- &gt; Transformer m a b</i></font>
<a name="line-1274"></a><font color=Blue><i>-- </i></font>
<a name="line-1275"></a><font color=Blue><i>-- instead of the special case</i></font>
<a name="line-1276"></a><font color=Blue><i>-- </i></font>
<a name="line-1277"></a><font color=Blue><i>-- &gt; Transformer Circ Qubit Bit.</i></font>
<a name="line-1278"></a><font color=Blue><i>-- </i></font>
<a name="line-1279"></a><font color=Blue><i>-- This requires an additional shape argument. </i></font>
<a name="line-1280"></a><font color=Blue><i>-- </i></font>
<a name="line-1281"></a><font color=Blue><i>-- The type of this heavily overloaded function is difficult to</i></font>
<a name="line-1282"></a><font color=Blue><i>-- read. In more readable form, it has all of the following types:</i></font>
<a name="line-1283"></a><font color=Blue><i>-- </i></font>
<a name="line-1284"></a><font color=Blue><i>-- &gt; transform_generic :: (QCData x) =&gt; Transformer m a b -&gt; Circ x -&gt; m (QCData a b x)</i></font>
<a name="line-1285"></a><font color=Blue><i>-- &gt; transform_generic :: (QCData x, QCData y) =&gt; Transformer m a b -&gt; (x -&gt; Circ y) -&gt; x -&gt; (QCData a b x -&gt; m (QCData a b y))</i></font>
<a name="line-1286"></a><font color=Blue><i>-- &gt; transform_generic :: (QCData x, QCData y, QCData z) =&gt; Transformer m a b -&gt; (x -&gt; y -&gt; Circ z) -&gt; x -&gt; y -&gt; (QCData a b x -&gt; QCData a b y -&gt; m (QCData a b z))</i></font>
<a name="line-1287"></a><font color=Blue><i>-- </i></font>
<a name="line-1288"></a><font color=Blue><i>-- and so forth.</i></font>
<a name="line-1289"></a>
<a name="line-1290"></a><a name="transform_generic_shape"></a><font color=Blue>transform_generic_shape</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>,</font> QCData y<font color=Cyan>,</font> QCurry qfun x y<font color=Cyan>,</font> Curry qfun' x' <font color=Cyan>(</font>m y'<font color=Cyan>)</font><font color=Cyan>,</font> Curry qfun'' x qfun'<font color=Cyan>,</font> x' <font color=Red>~</font> QCType a b x<font color=Cyan>,</font> y' <font color=Red>~</font> QCType a b y<font color=Cyan>,</font> Monad m<font color=Cyan>)</font> <font color=Red>=&gt;</font> Transformer m a b <font color=Red>-&gt;</font> qfun <font color=Red>-&gt;</font> qfun''
<a name="line-1291"></a><font color=Blue>transform_generic_shape</font> transformer f <font color=Red>=</font> g <font color=Green><u>where</u></font>
<a name="line-1292"></a>  f1 <font color=Red>=</font> quncurry f
<a name="line-1293"></a>  g1 <font color=Red>=</font> transform_errmsg errmsg transformer f1
<a name="line-1294"></a>  g2 <font color=Red>=</font> <font color=Red>\</font>x <font color=Red>-&gt;</font> mcurry <font color=Cyan>(</font>g1 x<font color=Cyan>)</font>
<a name="line-1295"></a>  g <font color=Red>=</font> mcurry g2
<a name="line-1296"></a>  errmsg x <font color=Red>=</font> <font color=Magenta>"transform_generic: "</font> <font color=Cyan>++</font> x
<a name="line-1297"></a>
<a name="line-1298"></a><font color=Blue><i>-- | Apply the given transformer to a circuit.  Unlike</i></font>
<a name="line-1299"></a><font color=Blue><i>-- 'transform_unary', this function can be applied to a</i></font>
<a name="line-1300"></a><font color=Blue><i>-- circuit-generating function in curried form with /n/ arguments, for</i></font>
<a name="line-1301"></a><font color=Blue><i>-- any /n/ &#8805; 0.</i></font>
<a name="line-1302"></a><font color=Blue><i>-- </i></font>
<a name="line-1303"></a><font color=Blue><i>-- The type of this heavily overloaded function is difficult to</i></font>
<a name="line-1304"></a><font color=Blue><i>-- read. In more readable form, it has all of the following types:</i></font>
<a name="line-1305"></a><font color=Blue><i>-- </i></font>
<a name="line-1306"></a><font color=Blue><i>-- &gt; transform_generic :: (QCData x) =&gt; Transformer Circ Qubit Bit -&gt; Circ x -&gt; Circ x</i></font>
<a name="line-1307"></a><font color=Blue><i>-- &gt; transform_generic :: (QCData x, QCData y) =&gt; Transformer Circ Qubit Bit -&gt; (x -&gt; Circ y) -&gt; (x -&gt; Circ y)</i></font>
<a name="line-1308"></a><font color=Blue><i>-- &gt; transform_generic :: (QCData x, QCData y, QCData z) =&gt; Transformer Circ Qubit Bit -&gt; (x -&gt; y -&gt; Circ z) -&gt; (x -&gt; y -&gt; Circ z)</i></font>
<a name="line-1309"></a><font color=Blue><i>-- </i></font>
<a name="line-1310"></a><font color=Blue><i>-- and so forth.</i></font>
<a name="line-1311"></a>
<a name="line-1312"></a><a name="transform_generic"></a><font color=Blue>transform_generic</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>,</font> QCData y<font color=Cyan>,</font> QCurry qfun x y<font color=Cyan>)</font> <font color=Red>=&gt;</font> Transformer Circ Qubit Bit <font color=Red>-&gt;</font> qfun <font color=Red>-&gt;</font> qfun
<a name="line-1313"></a><font color=Blue>transform_generic</font> transformer f <font color=Red>=</font> g <font color=Green><u>where</u></font>
<a name="line-1314"></a>  f1 <font color=Red>=</font> quncurry f
<a name="line-1315"></a>  g1 <font color=Red>=</font> <font color=Red>\</font>x <font color=Red>-&gt;</font> transform_errmsg errmsg transformer f1 x x
<a name="line-1316"></a>  g <font color=Red>=</font> qcurry g1
<a name="line-1317"></a>  errmsg x <font color=Red>=</font> <font color=Magenta>"transform_generic: "</font> <font color=Cyan>++</font> x
<a name="line-1318"></a>
<a name="line-1319"></a>
<a name="line-1320"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-1321"></a><font color=Blue><i>-- * Generic block structure</i></font>
<a name="line-1322"></a>
<a name="line-1323"></a><a name="with_ancilla_init"></a><font color=Blue><i>-- | Execute a block with local ancillas. Opens a block, initializing an ancilla with a specified classical value, and terminates it with the same value when the block closes. Note: it is the programmer's responsibility to return the ancilla to its original state at the end of the enclosed block. Usage:</i></font>
<a name="line-1324"></a><font color=Blue><i>-- </i></font>
<a name="line-1325"></a><font color=Blue><i>-- &gt; with_ancilla_init True $ \a -&gt; do {</i></font>
<a name="line-1326"></a><font color=Blue><i>-- &gt;   &lt;&lt;&lt;code block using ancilla a initialized to True&gt;&gt;&gt;</i></font>
<a name="line-1327"></a><font color=Blue><i>-- &gt; }</i></font>
<a name="line-1328"></a><font color=Blue><i>-- </i></font>
<a name="line-1329"></a><font color=Blue><i>-- &gt; with_ancilla_init [True,False,True] $ \a -&gt; do {</i></font>
<a name="line-1330"></a><font color=Blue><i>-- &gt;   &lt;&lt;&lt;code block using list of ancillas a initialized to [True,False,True]&gt;&gt;&gt;</i></font>
<a name="line-1331"></a><font color=Blue><i>-- &gt; }</i></font>
<a name="line-1332"></a><font color=Blue>with_ancilla_init</font> <font color=Red>::</font> <font color=Cyan>(</font>QShape a qa ca<font color=Cyan>)</font> <font color=Red>=&gt;</font> a <font color=Red>-&gt;</font> <font color=Cyan>(</font>qa <font color=Red>-&gt;</font> Circ b<font color=Cyan>)</font> <font color=Red>-&gt;</font> Circ b
<a name="line-1333"></a><font color=Blue>with_ancilla_init</font> x f <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1334"></a>  qx <font color=Red>&lt;-</font> without_controls <font color=Cyan>(</font>qinit x<font color=Cyan>)</font>
<a name="line-1335"></a>  qy <font color=Red>&lt;-</font> f qx
<a name="line-1336"></a>  without_controls <font color=Cyan>(</font>qterm x qx<font color=Cyan>)</font>
<a name="line-1337"></a>  return qy
<a name="line-1338"></a>
<a name="line-1339"></a><a name="with_ancilla_list"></a><font color=Blue><i>-- | Like 'with_ancilla', but creates a list of /n/ ancillas, all</i></font>
<a name="line-1340"></a><font color=Blue><i>-- initialized to |0&#9002;. Usage:</i></font>
<a name="line-1341"></a><font color=Blue><i>-- </i></font>
<a name="line-1342"></a><font color=Blue><i>-- &gt; with_ancilla_list n $ \a -&gt; do {</i></font>
<a name="line-1343"></a><font color=Blue><i>-- &gt;   &lt;&lt;&lt;code block using list of ancillas a&gt;&gt;&gt;</i></font>
<a name="line-1344"></a><font color=Blue><i>-- &gt; }</i></font>
<a name="line-1345"></a><font color=Blue>with_ancilla_list</font> <font color=Red>::</font> Int <font color=Red>-&gt;</font> <font color=Cyan>(</font>Qulist <font color=Red>-&gt;</font> Circ a<font color=Cyan>)</font> <font color=Red>-&gt;</font> Circ a
<a name="line-1346"></a><font color=Blue>with_ancilla_list</font> n f <font color=Red>=</font> 
<a name="line-1347"></a>  with_ancilla_init <font color=Cyan>(</font>replicate n False<font color=Cyan>)</font> f
<a name="line-1348"></a>
<a name="line-1349"></a><font color=Blue><i>-- | @'with_computed_fun' /x/ /f/ /g/@: computes /x' := f(x)/; then computes /g(x')/, which should be organized as a pair /(x',y)/; then uncomputes /x'/ back to /x/, and returns /(x,y)/.</i></font>
<a name="line-1350"></a><font color=Blue><i>-- </i></font>
<a name="line-1351"></a><font color=Blue><i>-- Important subtlety in usage: all quantum data referenced in /f/, even as controls, must be explicitly bound and returned by /f/, or the reversing may rebind it incorrectly.  /g/, on the other hand, can safely refer to anything that is in scope outside the 'with_computed_fun'.</i></font>
<a name="line-1352"></a> 
<a name="line-1353"></a><a name="with_computed_fun"></a><font color=Blue>with_computed_fun</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>,</font> QCData y<font color=Cyan>)</font> <font color=Red>=&gt;</font> x <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> Circ y<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>y <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>y<font color=Cyan>,</font>b<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Red>-&gt;</font> Circ <font color=Cyan>(</font>x<font color=Cyan>,</font>b<font color=Cyan>)</font>
<a name="line-1354"></a><font color=Blue>with_computed_fun</font> x f g <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1355"></a>  y <font color=Red>&lt;-</font> without_controls <font color=Cyan>(</font>f x<font color=Cyan>)</font>  
<a name="line-1356"></a>  <font color=Cyan>(</font>y<font color=Cyan>,</font>b<font color=Cyan>)</font> <font color=Red>&lt;-</font> g y
<a name="line-1357"></a>  x <font color=Red>&lt;-</font> without_controls <font color=Cyan>(</font>reverse_generic f x y<font color=Cyan>)</font>
<a name="line-1358"></a>  return <font color=Cyan>(</font>x<font color=Cyan>,</font>b<font color=Cyan>)</font>
<a name="line-1359"></a>
<a name="line-1360"></a><font color=Blue><i>-- | @'with_computed' /computation/ /code/@: performs /computation/</i></font>
<a name="line-1361"></a><font color=Blue><i>-- (with result /x/), then performs /code/ /x/, and finally performs</i></font>
<a name="line-1362"></a><font color=Blue><i>-- the reverse of /computation/, for example like this:</i></font>
<a name="line-1363"></a><font color=Blue><i>-- </i></font>
<a name="line-1364"></a><font color=Blue><i>-- \[image with_computed.png]</i></font>
<a name="line-1365"></a><font color=Blue><i>-- </i></font>
<a name="line-1366"></a><font color=Blue><i>-- Both /computation/ and /code/ may refer to any qubits that exist in</i></font>
<a name="line-1367"></a><font color=Blue><i>-- the current environment, and they may also create new</i></font>
<a name="line-1368"></a><font color=Blue><i>-- qubits. /computation/ may produce arbitrary garbage in addition to</i></font>
<a name="line-1369"></a><font color=Blue><i>-- its output. </i></font>
<a name="line-1370"></a><font color=Blue><i>-- </i></font>
<a name="line-1371"></a><font color=Blue><i>-- This is a very general but relatively unsafe operation. It is the</i></font>
<a name="line-1372"></a><font color=Blue><i>-- user's responsibility to ensure that the computation can indeed be</i></font>
<a name="line-1373"></a><font color=Blue><i>-- undone. In particular, if /computation/ contains any</i></font>
<a name="line-1374"></a><font color=Blue><i>-- initializations, then /code/ must ensure that the corresponding</i></font>
<a name="line-1375"></a><font color=Blue><i>-- assertions will be satisfied in /computation/[sup &#8722;1].</i></font>
<a name="line-1376"></a><font color=Blue><i>-- </i></font>
<a name="line-1377"></a><font color=Blue><i>-- Related more specialized, but potentially safer, operations are: </i></font>
<a name="line-1378"></a><font color=Blue><i>-- </i></font>
<a name="line-1379"></a><font color=Blue><i>-- * 'with_basis_change', which is like 'with_computed', but assumes</i></font>
<a name="line-1380"></a><font color=Blue><i>-- that /computation/ is unitary, and</i></font>
<a name="line-1381"></a><font color=Blue><i>-- </i></font>
<a name="line-1382"></a><font color=Blue><i>-- * 'classical_to_reversible', which assumes that /computation/ is</i></font>
<a name="line-1383"></a><font color=Blue><i>-- classical (or pseudo-classical), and /code/ is a simple</i></font>
<a name="line-1384"></a><font color=Blue><i>-- copy-by-controlled-not operation.</i></font>
<a name="line-1385"></a>
<a name="line-1386"></a><a name="with_computed"></a><font color=Blue>with_computed</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>)</font> <font color=Red>=&gt;</font> Circ x <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> Circ b<font color=Cyan>)</font> <font color=Red>-&gt;</font> Circ b
<a name="line-1387"></a><font color=Blue>with_computed</font> computation code <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1388"></a>  <font color=Cyan>(</font>bcirc<font color=Cyan>,</font> dirty<font color=Cyan>,</font> x<font color=Cyan>)</font> <font color=Red>&lt;-</font> extract_in_context errmsg computation
<a name="line-1389"></a>  without_controls <font color=Cyan>$</font> <font color=Green><u>do</u></font>
<a name="line-1390"></a>    unextract_in_context bcirc
<a name="line-1391"></a>  y <font color=Red>&lt;-</font> with_reserve dirty <font color=Cyan>$</font> <font color=Green><u>do</u></font>
<a name="line-1392"></a>    code x
<a name="line-1393"></a>  without_controls <font color=Cyan>$</font> <font color=Green><u>do</u></font>
<a name="line-1394"></a>    unextract_in_context <font color=Cyan>(</font>reverse_bcircuit bcirc<font color=Cyan>)</font>
<a name="line-1395"></a>  return y
<a name="line-1396"></a>  <font color=Green><u>where</u></font>
<a name="line-1397"></a>    errmsg x <font color=Red>=</font> <font color=Magenta>"with_computed: operation not permitted in pre-computation: "</font> <font color=Cyan>++</font> x
<a name="line-1398"></a>
<a name="line-1399"></a><font color=Blue><i>-- | @'with_basis_change' /basischange/ /code/@: performs a basis change,</i></font>
<a name="line-1400"></a><font color=Blue><i>-- then the /code/, then the inverse of the basis change. Both</i></font>
<a name="line-1401"></a><font color=Blue><i>-- /basischange/ and /code/ are in imperative style. It is the user's</i></font>
<a name="line-1402"></a><font color=Blue><i>-- responsibility to ensure that the image of /code/ is contained in</i></font>
<a name="line-1403"></a><font color=Blue><i>-- the image of /basischange/, or else there will be unmet assertions</i></font>
<a name="line-1404"></a><font color=Blue><i>-- or runtime errors. Usage:</i></font>
<a name="line-1405"></a><font color=Blue><i>-- </i></font>
<a name="line-1406"></a><font color=Blue><i>-- &gt; with_basis_change basischange $ do</i></font>
<a name="line-1407"></a><font color=Blue><i>-- &gt;   &lt;&lt;&lt;code&gt;&gt;&gt;</i></font>
<a name="line-1408"></a><font color=Blue><i>-- &gt;</i></font>
<a name="line-1409"></a><font color=Blue><i>-- &gt; where</i></font>
<a name="line-1410"></a><font color=Blue><i>-- &gt;   basischange = do</i></font>
<a name="line-1411"></a><font color=Blue><i>-- &gt;     &lt;&lt;&lt;gates&gt;&gt;&gt;</i></font>
<a name="line-1412"></a>
<a name="line-1413"></a><a name="with_basis_change"></a><font color=Blue>with_basis_change</font> <font color=Red>::</font> Circ () <font color=Red>-&gt;</font> Circ b <font color=Red>-&gt;</font> Circ b
<a name="line-1414"></a><font color=Blue>with_basis_change</font> basischange code <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1415"></a>  with_computed basischange <font color=Cyan>(</font><font color=Red>\</font>x <font color=Red>-&gt;</font> code<font color=Cyan>)</font>
<a name="line-1416"></a>
<a name="line-1417"></a><font color=Blue><i>-- ======================================================================</i></font>
<a name="line-1418"></a><font color=Blue><i>-- * Boxed subcircuits</i></font>
<a name="line-1419"></a>
<a name="line-1420"></a>
<a name="line-1421"></a><a name="provide_subroutine_generic"></a><font color=Blue><i>-- | Bind a name to a function as a subroutine in the current</i></font>
<a name="line-1422"></a><font color=Blue><i>-- namespace. This requires a shape argument, as well as complete</i></font>
<a name="line-1423"></a><font color=Blue><i>-- parameters, so that it is uniquely determined which actual circuit</i></font>
<a name="line-1424"></a><font color=Blue><i>-- will be the subroutine. It is an error to call that subroutine</i></font>
<a name="line-1425"></a><font color=Blue><i>-- later with a different shape argument. It is therefore the user's</i></font>
<a name="line-1426"></a><font color=Blue><i>-- responsibility to ensure that the name is unique to the subroutine,</i></font>
<a name="line-1427"></a><font color=Blue><i>-- parameters, and shape. </i></font>
<a name="line-1428"></a><font color=Blue><i>--</i></font>
<a name="line-1429"></a><font color=Blue><i>-- This function does nothing if the name</i></font>
<a name="line-1430"></a><font color=Blue><i>-- already exists in the namespace; in particular, it does /not/ check</i></font>
<a name="line-1431"></a><font color=Blue><i>-- whether the given function is equal to the stored subroutine. </i></font>
<a name="line-1432"></a><font color=Blue>provide_subroutine_generic</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>,</font> QCData y<font color=Cyan>)</font> <font color=Red>=&gt;</font> ErrMsg <font color=Red>-&gt;</font> BoxId <font color=Red>-&gt;</font> Bool <font color=Red>-&gt;</font> <font color=Cyan>(</font>x <font color=Red>-&gt;</font> Circ y<font color=Cyan>)</font> <font color=Red>-&gt;</font> x <font color=Red>-&gt;</font> Circ ()
<a name="line-1433"></a><font color=Blue>provide_subroutine_generic</font> e name is_classically_controllable f shape <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1434"></a>  main_state <font color=Red>&lt;-</font> get_namespace
<a name="line-1435"></a>  <font color=Green><u>if</u></font> <font color=Cyan>(</font>Map<font color=Cyan>.</font>member name main_state<font color=Cyan>)</font>
<a name="line-1436"></a>  <font color=Green><u>then</u></font> return ()
<a name="line-1437"></a>  <font color=Green><u>else</u></font> <font color=Green><u>do</u></font>
<a name="line-1438"></a>    <font color=Cyan>(</font>x<font color=Cyan>,</font> bcircuit<font color=Cyan>,</font> y<font color=Cyan>)</font> <font color=Red>&lt;-</font> encapsulate_generic_in_namespace errmsg f shape
<a name="line-1439"></a>
<a name="line-1440"></a>    <font color=Blue><i>-- The 'y' element only corresponds to the output type of the box,</i></font>
<a name="line-1441"></a>    <font color=Blue><i>-- not the complete list of wires outputted by the circuit. This</i></font>
<a name="line-1442"></a>    <font color=Blue><i>-- information is gathered and stored in forgotten_output_qcdata</i></font>
<a name="line-1443"></a>    <font color=Blue><i>-- as ([Qubit],[Bit]).</i></font>
<a name="line-1444"></a>    <font color=Green><u>let</u></font> <font color=Cyan>(</font><font color=Cyan>(</font><font color=Green><u>_</u></font><font color=Cyan>,</font><font color=Green><u>_</u></font><font color=Cyan>,</font>aout<font color=Cyan>,</font><font color=Green><u>_</u></font><font color=Cyan>)</font><font color=Cyan>,</font><font color=Green><u>_</u></font><font color=Cyan>)</font> <font color=Red>=</font> bcircuit
<a name="line-1445"></a>        forgotten_output_arity  <font color=Red>=</font> strip_qcdata_from_arity y aout
<a name="line-1446"></a>        forgotten_output_qcdata <font color=Red>=</font> extract_from_arity forgotten_output_arity
<a name="line-1447"></a>
<a name="line-1448"></a>    <font color=Green><u>let</u></font> ein <font color=Red>=</font> endpoints_of_qcdata x
<a name="line-1449"></a>        eout <font color=Red>=</font> endpoints_of_qcdata <font color=Cyan>(</font>y<font color=Cyan>,</font>forgotten_output_qcdata<font color=Cyan>)</font>
<a name="line-1450"></a>        win <font color=Red>=</font> map wire_of_endpoint ein
<a name="line-1451"></a>        wout <font color=Red>=</font> map wire_of_endpoint eout
<a name="line-1452"></a>
<a name="line-1453"></a>        input_destructure <font color=Red>=</font> wires_with_arity_of_endpoints <font color=Cyan>.</font> endpoints_of_qcdata
<a name="line-1454"></a>        input_structure <font color=Red>=</font> <font color=Cyan>(</font><font color=Red>\</font><font color=Cyan>(</font>ws<font color=Cyan>,</font>a<font color=Cyan>)</font> <font color=Red>-&gt;</font> qcdata_of_endpoints x <font color=Cyan>$</font> endpoints_of_wires_in_arity a ws<font color=Cyan>)</font>
<a name="line-1455"></a>
<a name="line-1456"></a>        input_CircTypeStructure <font color=Red>=</font> CircuitTypeStructure input_destructure input_structure 
<a name="line-1457"></a>
<a name="line-1458"></a>        output_destructure <font color=Red>=</font> wires_with_arity_of_endpoints <font color=Cyan>.</font> endpoints_of_qcdata
<a name="line-1459"></a>        output_structure <font color=Red>=</font> <font color=Cyan>(</font><font color=Red>\</font><font color=Cyan>(</font>ws<font color=Cyan>,</font>a<font color=Cyan>)</font> <font color=Red>-&gt;</font> qcdata_of_endpoints <font color=Cyan>(</font>y<font color=Cyan>,</font>forgotten_output_qcdata<font color=Cyan>)</font> <font color=Cyan>$</font> endpoints_of_wires_in_arity a ws<font color=Cyan>)</font>
<a name="line-1460"></a>
<a name="line-1461"></a>        output_CircTypeStructure <font color=Red>=</font> CircuitTypeStructure output_destructure output_structure 
<a name="line-1462"></a>
<a name="line-1463"></a>    provide_subroutine name <font color=Cyan>(</font>ob_circuit win bcircuit wout<font color=Cyan>)</font> input_CircTypeStructure output_CircTypeStructure is_classically_controllable
<a name="line-1464"></a>    <font color=Green><u>where</u></font>
<a name="line-1465"></a>      errmsg x <font color=Red>=</font> e <font color=Cyan>(</font><font color=Magenta>"operation not permitted in boxed subroutine: "</font> <font color=Cyan>++</font> x<font color=Cyan>)</font>
<a name="line-1466"></a>
<a name="line-1467"></a>      <font color=Blue><i>-- Make a 'QCData' out of an arity.</i></font>
<a name="line-1468"></a>      extract_from_arity <font color=Red>::</font> Arity <font color=Red>-&gt;</font> <font color=Cyan>(</font><font color=Red>[</font>Qubit<font color=Red>]</font><font color=Cyan>,</font><font color=Red>[</font>Bit<font color=Red>]</font><font color=Cyan>)</font>
<a name="line-1469"></a>      extract_from_arity x <font color=Red>=</font>
<a name="line-1470"></a>        fst <font color=Cyan>$</font> IntMap<font color=Cyan>.</font>mapAccumWithKey record_wire <font color=Cyan>(</font>[]<font color=Cyan>,</font>[]<font color=Cyan>)</font> x
<a name="line-1471"></a>        <font color=Green><u>where</u></font>
<a name="line-1472"></a>          record_wire <font color=Red>::</font> <font color=Cyan>(</font><font color=Red>[</font>Qubit<font color=Red>]</font><font color=Cyan>,</font><font color=Red>[</font>Bit<font color=Red>]</font><font color=Cyan>)</font> <font color=Red>-&gt;</font> Int <font color=Red>-&gt;</font> Wiretype <font color=Red>-&gt;</font> <font color=Cyan>(</font><font color=Cyan>(</font><font color=Red>[</font>Qubit<font color=Red>]</font><font color=Cyan>,</font><font color=Red>[</font>Bit<font color=Red>]</font><font color=Cyan>)</font><font color=Cyan>,</font>Wiretype<font color=Cyan>)</font>
<a name="line-1473"></a>          record_wire <font color=Cyan>(</font>qs<font color=Cyan>,</font>bs<font color=Cyan>)</font> wire Qbit <font color=Red>=</font> <font color=Cyan>(</font><font color=Cyan>(</font><font color=Cyan>(</font>qubit_of_wire wire<font color=Cyan>)</font><font color=Red><b>:</b></font>qs<font color=Cyan>,</font>bs<font color=Cyan>)</font><font color=Cyan>,</font> Qbit<font color=Cyan>)</font>
<a name="line-1474"></a>          record_wire <font color=Cyan>(</font>qs<font color=Cyan>,</font>bs<font color=Cyan>)</font> wire Cbit <font color=Red>=</font> <font color=Cyan>(</font><font color=Cyan>(</font>qs<font color=Cyan>,</font><font color=Cyan>(</font>bit_of_wire wire<font color=Cyan>)</font><font color=Red><b>:</b></font>bs<font color=Cyan>)</font><font color=Cyan>,</font> Cbit<font color=Cyan>)</font>
<a name="line-1475"></a>
<a name="line-1476"></a>      <font color=Blue><i>-- Take a 'QCData' /x/ and an 'Arity' /a/ and remove all the wires</i></font>
<a name="line-1477"></a>      <font color=Blue><i>-- of /a/ that are already existing in /x/.</i></font>
<a name="line-1478"></a>      strip_qcdata_from_arity <font color=Red>::</font> <font color=Cyan>(</font>QCData x<font color=Cyan>)</font> <font color=Red>=&gt;</font> x <font color=Red>-&gt;</font> Arity <font color=Red>-&gt;</font> Arity
<a name="line-1479"></a>      strip_qcdata_from_arity x a <font color=Red>=</font>
<a name="line-1480"></a>        snd <font color=Cyan>$</font> State<font color=Cyan>.</font>runState <font color=Cyan>(</font>qcdata_mapM x delete_qubit delete_bit x<font color=Cyan>)</font> a
<a name="line-1481"></a>        <font color=Green><u>where</u></font>
<a name="line-1482"></a>          
<a name="line-1483"></a>          delete_qubit <font color=Red>::</font> Qubit <font color=Red>-&gt;</font> State<font color=Cyan>.</font>State Arity ()
<a name="line-1484"></a>          delete_qubit q <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1485"></a>            s <font color=Red>&lt;-</font> State<font color=Cyan>.</font>get
<a name="line-1486"></a>            State<font color=Cyan>.</font>put <font color=Cyan>$</font> flip IntMap<font color=Cyan>.</font>delete s <font color=Cyan>$</font> wire_of_qubit q
<a name="line-1487"></a>          
<a name="line-1488"></a>          delete_bit <font color=Red>::</font> Bit <font color=Red>-&gt;</font> State<font color=Cyan>.</font>State Arity ()
<a name="line-1489"></a>          delete_bit b <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1490"></a>            s <font color=Red>&lt;-</font> State<font color=Cyan>.</font>get
<a name="line-1491"></a>            State<font color=Cyan>.</font>put <font color=Cyan>$</font> flip IntMap<font color=Cyan>.</font>delete s <font color=Cyan>$</font> wire_of_bit b
<a name="line-1492"></a>
<a name="line-1493"></a>
<a name="line-1494"></a>
<a name="line-1495"></a>
<a name="line-1496"></a>
<a name="line-1497"></a>
<a name="line-1498"></a><a name="box"></a><font color=Blue><i>-- | A generic interface for wrapping a circuit-generating function</i></font>
<a name="line-1499"></a><font color=Blue><i>-- into a boxed and named subroutine. This takes a name and a</i></font>
<a name="line-1500"></a><font color=Blue><i>-- circuit-generating function, and returns a new circuit-generating</i></font>
<a name="line-1501"></a><font color=Blue><i>-- function of the same type, but which inserts a boxed subroutine</i></font>
<a name="line-1502"></a><font color=Blue><i>-- instead of the actual body of the subroutine.</i></font>
<a name="line-1503"></a><font color=Blue><i>-- </i></font>
<a name="line-1504"></a><font color=Blue><i>-- It is intended to be used like this:</i></font>
<a name="line-1505"></a><font color=Blue><i>-- </i></font>
<a name="line-1506"></a><font color=Blue><i>-- &gt; somefunc :: Qubit -&gt; Circ Qubit</i></font>
<a name="line-1507"></a><font color=Blue><i>-- &gt; somefunc a = do ...</i></font>
<a name="line-1508"></a><font color=Blue><i>-- &gt; </i></font>
<a name="line-1509"></a><font color=Blue><i>-- &gt; somefunc_boxed :: Qubit -&gt; Circ Qubit</i></font>
<a name="line-1510"></a><font color=Blue><i>-- &gt; somefunc_boxed = box "somefunc" somefunc</i></font>
<a name="line-1511"></a><font color=Blue><i>-- </i></font>
<a name="line-1512"></a><font color=Blue><i>-- Here, the type of @somefunc@ is just an example; this could indeed</i></font>
<a name="line-1513"></a><font color=Blue><i>-- be a function with any number and type of arguments, as long as the</i></font>
<a name="line-1514"></a><font color=Blue><i>-- arguments and return type are quantum data.</i></font>
<a name="line-1515"></a><font color=Blue><i>-- </i></font>
<a name="line-1516"></a><font color=Blue><i>-- It is also possible to inline the 'box' operator directly, in which</i></font>
<a name="line-1517"></a><font color=Blue><i>-- case it should be done like this:</i></font>
<a name="line-1518"></a><font color=Blue><i>-- </i></font>
<a name="line-1519"></a><font color=Blue><i>-- &gt; somefunc :: Qubit -&gt; Circ Qubit</i></font>
<a name="line-1520"></a><font color=Blue><i>-- &gt; somefunc = box "somefunc" $ \a -&gt; do ...</i></font>
<a name="line-1521"></a><font color=Blue><i>-- </i></font>
<a name="line-1522"></a><font color=Blue><i>-- Note: The 'box' operator wraps around a complete function,</i></font>
<a name="line-1523"></a><font color=Blue><i>-- including all of its arguments. It would be incorrect to apply the</i></font>
<a name="line-1524"></a><font color=Blue><i>-- 'box' operator after some quantum variables have already been</i></font>
<a name="line-1525"></a><font color=Blue><i>-- defined. Thus, the following is incorrect:</i></font>
<a name="line-1526"></a><font color=Blue><i>-- </i></font>
<a name="line-1527"></a><font color=Blue><i>-- &gt; incorrect_somefunc :: Qubit -&gt; Circ Qubit</i></font>
<a name="line-1528"></a><font color=Blue><i>-- &gt; incorrect_somefunc a = box "somefunc" $ do ...</i></font>
<a name="line-1529"></a><font color=Blue><i>-- </i></font>
<a name="line-1530"></a><font color=Blue><i>-- It is the user's responsibility not to use the same name for</i></font>
<a name="line-1531"></a><font color=Blue><i>-- different subroutines. If 'box' is called more than once with the</i></font>
<a name="line-1532"></a><font color=Blue><i>-- same name and shape of input, Quipper assumes, without checking,</i></font>
<a name="line-1533"></a><font color=Blue><i>-- that they are subsequent calls to the same subroutine. </i></font>
<a name="line-1534"></a><font color=Blue><i>-- </i></font>
<a name="line-1535"></a><font color=Blue><i>-- The type of the 'box' operator is overloaded and quite difficult to</i></font>
<a name="line-1536"></a><font color=Blue><i>-- read.  It can have for example the following types:</i></font>
<a name="line-1537"></a><font color=Blue><i>-- </i></font>
<a name="line-1538"></a><font color=Blue><i>-- &gt; box :: String -&gt; (Qubit -&gt; Circ Qubit) -&gt; (Qubit -&gt; Circ Qubit)</i></font>
<a name="line-1539"></a><font color=Blue><i>-- &gt; box :: String -&gt; (QDInt -&gt; QDInt -&gt; Circ (QDInt,QDInt,QDInt)) -&gt; (QDInt -&gt; QDInt -&gt; Circ (QDInt,QDInt,QDInt))</i></font>
<a name="line-1540"></a><font color=Blue>box</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qa<font color=Cyan>,</font> QCData qb<font color=Cyan>,</font> QCurry qa_qb qa qb<font color=Cyan>)</font>
<a name="line-1541"></a>    <font color=Red>=&gt;</font> String <font color=Red>-&gt;</font> qa_qb <font color=Red>-&gt;</font> qa_qb
<a name="line-1542"></a><font color=Blue>box</font> n <font color=Red>=</font> qcurry <font color=Cyan>.</font> <font color=Cyan>(</font>box_internal err n <font color=Cyan>$</font> RepeatFlag <font color=Magenta>1</font><font color=Cyan>)</font> <font color=Cyan>.</font> quncurry
<a name="line-1543"></a>  <font color=Green><u>where</u></font>
<a name="line-1544"></a>    err e <font color=Red>=</font> <font color=Magenta>"box: "</font> <font color=Cyan>++</font> e
<a name="line-1545"></a>
<a name="line-1546"></a><a name="nbox"></a><font color=Blue><i>-- | A version of 'box' with iteration. The second argument is an</i></font>
<a name="line-1547"></a><font color=Blue><i>-- iteration count.</i></font>
<a name="line-1548"></a><font color=Blue><i>-- </i></font>
<a name="line-1549"></a><font color=Blue><i>-- This can only be applied to functions of a single argument, where</i></font>
<a name="line-1550"></a><font color=Blue><i>-- the input and output types are the same.</i></font>
<a name="line-1551"></a><font color=Blue>nbox</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> String <font color=Red>-&gt;</font> Integer <font color=Red>-&gt;</font> <font color=Cyan>(</font>qa <font color=Red>-&gt;</font> Circ qa<font color=Cyan>)</font> <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> Circ qa
<a name="line-1552"></a><font color=Blue>nbox</font> n rep <font color=Red>=</font> qcurry <font color=Cyan>.</font> <font color=Cyan>(</font>box_internal err n <font color=Cyan>(</font>RepeatFlag rep<font color=Cyan>)</font><font color=Cyan>)</font> <font color=Cyan>.</font> quncurry
<a name="line-1553"></a>  <font color=Green><u>where</u></font>
<a name="line-1554"></a>    err e <font color=Red>=</font> <font color=Magenta>"nbox: "</font> <font color=Cyan>++</font> e
<a name="line-1555"></a>
<a name="line-1556"></a><a name="box_loopM"></a><font color=Blue><i>-- | A version of 'nbox' with same type as 'loopM'.</i></font>
<a name="line-1557"></a><font color=Blue>box_loopM</font> <font color=Red>::</font> <font color=Cyan>(</font>Integral int<font color=Cyan>,</font> QCData qa<font color=Cyan>)</font>
<a name="line-1558"></a>    <font color=Red>=&gt;</font> String <font color=Red>-&gt;</font> int <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> <font color=Cyan>(</font>qa <font color=Red>-&gt;</font> Circ qa<font color=Cyan>)</font> <font color=Red>-&gt;</font> Circ qa
<a name="line-1559"></a><font color=Blue>box_loopM</font> n rep <font color=Red>=</font> flip <font color=Cyan>(</font>nbox  n <font color=Cyan>$</font> fromIntegral rep<font color=Cyan>)</font>
<a name="line-1560"></a>
<a name="line-1561"></a><a name="loopM_boxed_if"></a><font color=Blue><i>-- | A version of 'loopM' that will be boxed conditionally on a</i></font>
<a name="line-1562"></a><font color=Blue><i>-- boolean condition. Typical usage:</i></font>
<a name="line-1563"></a><font color=Blue><i>-- </i></font>
<a name="line-1564"></a><font color=Blue><i>-- &gt; loopM_boxed_if (s &gt; 1) "name" s x $ \x -&gt; do</i></font>
<a name="line-1565"></a><font color=Blue><i>-- &gt;   &lt;&lt;&lt;body&gt;&gt;&gt;</i></font>
<a name="line-1566"></a><font color=Blue><i>-- &gt;   return x</i></font>
<a name="line-1567"></a><font color=Blue>loopM_boxed_if</font> <font color=Red>::</font> <font color=Cyan>(</font>Integral int<font color=Cyan>,</font> QCData qa<font color=Cyan>)</font> <font color=Red>=&gt;</font> Bool <font color=Red>-&gt;</font> String <font color=Red>-&gt;</font> int <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> <font color=Cyan>(</font>qa <font color=Red>-&gt;</font> Circ qa<font color=Cyan>)</font> <font color=Red>-&gt;</font> Circ qa
<a name="line-1568"></a><font color=Blue>loopM_boxed_if</font> True name <font color=Red>=</font> box_loopM name
<a name="line-1569"></a><font color=Blue>loopM_boxed_if</font> False name <font color=Red>=</font> loopM
<a name="line-1570"></a>
<a name="line-1571"></a><a name="box_internal"></a><font color=Blue><i>-- | The underlying implementation of 'box' and 'nbox'. It behaves</i></font>
<a name="line-1572"></a><font color=Blue><i>-- like 'box', but is restricted to unary functions, and takes an</i></font>
<a name="line-1573"></a><font color=Blue><i>-- 'ErrMsg' argument.</i></font>
<a name="line-1574"></a><font color=Blue>box_internal</font> <font color=Red>::</font> <font color=Cyan>(</font>QCData qa<font color=Cyan>,</font> QCData qb<font color=Cyan>)</font>
<a name="line-1575"></a>             <font color=Red>=&gt;</font> ErrMsg <font color=Red>-&gt;</font> String <font color=Red>-&gt;</font> RepeatFlag <font color=Red>-&gt;</font> <font color=Cyan>(</font>qa <font color=Red>-&gt;</font> Circ qb<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Cyan>(</font>qa <font color=Red>-&gt;</font> Circ qb<font color=Cyan>)</font>
<a name="line-1576"></a><font color=Blue>box_internal</font> e n r f x <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1577"></a>  <font color=Green><u>let</u></font> boxid <font color=Red>=</font> BoxId n <font color=Cyan>(</font>canonical_shape x<font color=Cyan>)</font>
<a name="line-1578"></a>  provide_subroutine_generic e boxid False f x <font color=Blue><i>-- By default, fall back on the general controlling scheme: </i></font>
<a name="line-1579"></a>                                               <font color=Blue><i>-- set the classical-control flag to False.</i></font>
<a name="line-1580"></a>  call_subroutine boxid r x
<a name="line-1581"></a>
<a name="line-1582"></a>
<a name="line-1583"></a><a name="with_classical_control"></a><font color=Blue><i>-- | Classical control on a function with same shape of input and</i></font>
<a name="line-1584"></a><font color=Blue><i>-- output: if the control bit is true the function is fired, otherwise</i></font>
<a name="line-1585"></a><font color=Blue><i>-- the identity map is used.</i></font>
<a name="line-1586"></a><font color=Blue><i>-- Note: the constraint on the types is dynamically checked.</i></font>
<a name="line-1587"></a><font color=Blue>with_classical_control</font> <font color=Red>::</font> QCData qa <font color=Red>=&gt;</font> Bit <font color=Red>-&gt;</font> String <font color=Red>-&gt;</font> qa <font color=Red>-&gt;</font> <font color=Cyan>(</font>qa <font color=Red>-&gt;</font> Circ qa<font color=Cyan>)</font> <font color=Red>-&gt;</font> Circ qa
<a name="line-1588"></a><font color=Blue>with_classical_control</font> c n x f <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1589"></a>  <font color=Green><u>let</u></font> boxid <font color=Red>=</font> BoxId n <font color=Cyan>(</font>canonical_shape x<font color=Cyan>)</font>
<a name="line-1590"></a>  provide_subroutine_generic err boxid True f x
<a name="line-1591"></a>  call_subroutine boxid <font color=Cyan>(</font>RepeatFlag <font color=Magenta>1</font><font color=Cyan>)</font> x <font color=Cyan>`controlled`</font> c
<a name="line-1592"></a> <font color=Green><u>where</u></font>
<a name="line-1593"></a>  err e <font color=Red>=</font> <font color=Magenta>"with_classical_control: "</font> <font color=Cyan>++</font> e
<a name="line-1594"></a>
<a name="line-1595"></a><a name="inline_subroutine"></a><font color=Blue><i>-- | Like 'call_subroutine', except inline the subroutine body from</i></font>
<a name="line-1596"></a><font color=Blue><i>-- the given namespace, instead of inserting a subroutine call.</i></font>
<a name="line-1597"></a><font color=Blue><i>-- </i></font>
<a name="line-1598"></a><font color=Blue><i>-- Implementation note: this currently copies /all/ subroutine</i></font>
<a name="line-1599"></a><font color=Blue><i>-- definitions from the given namespace into the current namespace,</i></font>
<a name="line-1600"></a><font color=Blue><i>-- and not just the ones used by the current subroutine.</i></font>
<a name="line-1601"></a><font color=Blue><i>-- </i></font>
<a name="line-1602"></a><font color=Blue><i>-- Implementation note: this currently only works on lists of endpoints.</i></font>
<a name="line-1603"></a><font color=Blue>inline_subroutine</font> <font color=Red>::</font> BoxId <font color=Red>-&gt;</font> Namespace <font color=Red>-&gt;</font> <font color=Red>[</font>Endpoint<font color=Red>]</font> <font color=Red>-&gt;</font> Circ <font color=Red>[</font>Endpoint<font color=Red>]</font>
<a name="line-1604"></a><font color=Blue>inline_subroutine</font> name ns inputs <font color=Red>=</font> <font color=Green><u>do</u></font>
<a name="line-1605"></a>  <font color=Green><u>let</u></font> mc <font color=Red>=</font> Map<font color=Cyan>.</font>lookup name ns
<a name="line-1606"></a>  <font color=Green><u>case</u></font> mc <font color=Green><u>of</u></font> 
<a name="line-1607"></a>    Nothing <font color=Red>-&gt;</font> 
<a name="line-1608"></a>      error <font color=Cyan>(</font><font color=Magenta>"inline_subroutine: subroutine "</font> <font color=Cyan>++</font> show name <font color=Cyan>++</font> <font color=Magenta>" does not exist in the given namespace: "</font> <font color=Cyan>++</font> showNames ns<font color=Cyan>)</font>
<a name="line-1609"></a>    Just <font color=Cyan>(</font>TypedSubroutine ocircuit <font color=Green><u>_</u></font> <font color=Green><u>_</u></font> scf<font color=Cyan>)</font> <font color=Red>-&gt;</font> <font color=Green><u>do</u></font>
<a name="line-1610"></a>      <font color=Green><u>let</u></font> OCircuit <font color=Cyan>(</font>win<font color=Cyan>,</font> circuit<font color=Cyan>,</font> wout<font color=Cyan>)</font> <font color=Red>=</font> ocircuit
<a name="line-1611"></a>      provide_subroutines ns
<a name="line-1612"></a>      when <font color=Cyan>(</font>length win <font color=Cyan>/=</font> length inputs<font color=Cyan>)</font> <font color=Cyan>$</font> <font color=Green><u>do</u></font>
<a name="line-1613"></a>        error <font color=Cyan>(</font><font color=Magenta>"inline_subroutine: subroutine "</font> <font color=Cyan>++</font> show name <font color=Cyan>++</font> <font color=Magenta>" has been applied to incorrect size of QCData"</font><font color=Cyan>)</font>
<a name="line-1614"></a>      <font color=Green><u>let</u></font> in_bind <font color=Red>=</font> bind_list win inputs bindings_empty
<a name="line-1615"></a>      out_bind <font color=Red>&lt;-</font> apply_circuit_with_bindings circuit in_bind
<a name="line-1616"></a>      <font color=Green><u>let</u></font> outputs <font color=Red>=</font> unbind_list out_bind wout
<a name="line-1617"></a>      return outputs
</pre>
</body>
</html>