<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>QuipperLib.QuipperASCIIParser.CircInfo</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_QuipperLib-QuipperASCIIParser-CircInfo.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">QuipperLib.QuipperASCIIParser.CircInfo</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Data-types for the State
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module uses a state monad to track certain circuit information
 that is collected during parsing. This information contains
 the inputs and outputs of a circuit, as well as an entry for each subroutine
 that is defined within a circuit, and all the gates that make up the circuit.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span>  <a href="#t:Sub">Sub</a>  = <a href="#v:Sub">Sub</a> {<ul class="subs"><li><a href="#v:name">name</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a></li><li><a href="#v:shape">shape</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a></li><li><a href="#v:controllable">controllable</a> :: <a href="Quipper-Circuit.html#t:ControllableFlag">ControllableFlag</a></li><li><a href="#v:inputs">inputs</a> :: &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93;</li><li><a href="#v:outputs">outputs</a> :: &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93;</li><li><a href="#v:circuit">circuit</a> :: &#91;<a href="Quipper-Circuit.html#t:Gate">Gate</a>&#93;</li></ul>}</li><li class="src short"><a href="#v:new_subroutine">new_subroutine</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:Sub">Sub</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:CircInfoState">CircInfoState</a>  = <a href="#v:CircInfoState">CircInfoState</a> {<ul class="subs"><li><a href="#v:used_wires">used_wires</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)</li><li><a href="#v:defined_inputs">defined_inputs</a> :: &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93;</li><li><a href="#v:undefined_inputs">undefined_inputs</a> :: &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93;</li><li><a href="#v:defined_outputs">defined_outputs</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93;</li><li><a href="#v:current_subroutine">current_subroutine</a> :: &#91;<a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:Sub">Sub</a>&#93;</li></ul>}</li><li class="src short"><a href="#v:empty_circinfostate">empty_circinfostate</a> :: <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoState">CircInfoState</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:CircInfo">CircInfo</a> a = State <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoState">CircInfoState</a> a</li><li class="src short"><a href="#v:add_wire_inputs">add_wire_inputs</a> :: &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93; -&gt; <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> ()</li><li class="src short"><a href="#v:add_wire_outputs">add_wire_outputs</a> :: &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93; -&gt; <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> ()</li><li class="src short"><a href="#v:check_input">check_input</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>) -&gt; (<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>) -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:check_inputs">check_inputs</a> :: &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>) -&gt; &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93;</li><li class="src short"><a href="#v:add_gate">add_gate</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93; -&gt; <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoOut">CircInfoOut</a></li><li class="src short"><a href="#v:enter_subroutine">enter_subroutine</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> ()</li><li class="src short"><a href="#v:add_subroutine_shape">add_subroutine_shape</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> ()</li><li class="src short"><a href="#v:set_controllable">set_controllable</a> :: <a href="Quipper-Circuit.html#t:ControllableFlag">ControllableFlag</a> -&gt; <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> ()</li><li class="src short"><span class="keyword">data</span>  <a href="#t:CircInfoOut">CircInfoOut</a> <ul class="subs"><li>= <a href="#v:Empty">Empty</a>  </li><li>| <a href="#v:Lazy">Lazy</a> <a href="Quipper-Circuit.html#t:Gate">Gate</a>  </li><li>| <a href="#v:SubDef">SubDef</a> (<a href="Quipper-Circuit.html#t:BoxId">BoxId</a>, <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:Sub">Sub</a>)  </li></ul></li><li class="src short"><a href="#v:isGate">isGate</a> :: <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoOut">CircInfoOut</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:isSub">isSub</a> :: <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoOut">CircInfoOut</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:exit_subroutine">exit_subroutine</a> :: <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoOut">CircInfoOut</a></li><li class="src short"><a href="#v:do_gate">do_gate</a> :: <a href="QuipperLib-QuipperASCIIParser-Parse.html#t:GatePlus">GatePlus</a> -&gt; <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoOut">CircInfoOut</a></li><li class="src short"><a href="#v:run_ascii_line">run_ascii_line</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoOut">CircInfoOut</a></li><li class="src short"><a href="#v:run_ascii_lines">run_ascii_lines</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a>&#93; -&gt; (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93;, <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> &#91;<a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoOut">CircInfoOut</a>&#93;)</li><li class="src short"><a href="#v:run">run</a> :: <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> &#91;<a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoOut">CircInfoOut</a>&#93; -&gt; (&#91;<a href="Quipper-Circuit.html#t:Gate">Gate</a>&#93;, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:Sub">Sub</a>, <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoState">CircInfoState</a>)</li></ul></div><div id="interface"><h1 id="g:1">Data-types for the State
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Sub" class="def">Sub</a>  <a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html#line-24" class="link">Source</a></p><div class="doc"><p>Information collected about the current subroutine
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Sub" class="def">Sub</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:name" class="def">name</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:shape" class="def">shape</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:controllable" class="def">controllable</a> :: <a href="Quipper-Circuit.html#t:ControllableFlag">ControllableFlag</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:inputs" class="def">inputs</a> :: &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93;</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:outputs" class="def">outputs</a> :: &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93;</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:circuit" class="def">circuit</a> :: &#91;<a href="Quipper-Circuit.html#t:Gate">Gate</a>&#93;</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><a name="v:new_subroutine" class="def">new_subroutine</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:Sub">Sub</a><a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html#line-34" class="link">Source</a></p><div class="doc"><p>An initial subroutine, with only a name
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:CircInfoState" class="def">CircInfoState</a>  <a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html#line-41" class="link">Source</a></p><div class="doc"><p>A <code><a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoState">CircInfoState</a></code> is a record containing a list of input wires, along with their
 types, and a list of output wires, along with their types. We also keep track of 
 whether we're in a subroutine definition, and all the subroutines that have been 
 defined.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:CircInfoState" class="def">CircInfoState</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:used_wires" class="def">used_wires</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:defined_inputs" class="def">defined_inputs</a> :: &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93;</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:undefined_inputs" class="def">undefined_inputs</a> :: &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93;</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:defined_outputs" class="def">defined_outputs</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93;</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:current_subroutine" class="def">current_subroutine</a> :: &#91;<a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:Sub">Sub</a>&#93;</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><a name="v:empty_circinfostate" class="def">empty_circinfostate</a> :: <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoState">CircInfoState</a><a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html#line-50" class="link">Source</a></p><div class="doc"><p>An initial, empty CircInfoState
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:CircInfo" class="def">CircInfo</a> a = State <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoState">CircInfoState</a> a<a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html#line-55" class="link">Source</a></p><div class="doc"><p>The <code><a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a></code> Monad is used to track a <code><a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoState">CircInfoState</a></code> during parsing.
</p></div></div><div class="top"><p class="src"><a name="v:add_wire_inputs" class="def">add_wire_inputs</a> :: &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93; -&gt; <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> ()<a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html#line-60" class="link">Source</a></p><div class="doc"><p>The CircInfo Monad tracks wires that are inputs, these can only be given in
 a <a href="Input.html">Input</a> line in the parsed ASCII, so we assume that duplicate wires don't
 occur, and we add input wires to the state without checking.
</p></div></div><div class="top"><p class="src"><a name="v:add_wire_outputs" class="def">add_wire_outputs</a> :: &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93; -&gt; <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> ()<a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html#line-78" class="link">Source</a></p><div class="doc"><p>The CircInfo Monad tracks wires that are outputs, these can only be given in
 a <a href="Output.html">Output</a> line in the parsed ASCII, so we assume that duplicate wires don't
 occur, and we add output wires to the state without checking.
</p></div></div><div class="top"><p class="src"><a name="v:check_input" class="def">check_input</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>) -&gt; (<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>) -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html#line-93" class="link">Source</a></p><div class="doc"><p>Given a a wire, check whether it is already in scope.
</p></div></div><div class="top"><p class="src"><a name="v:check_inputs" class="def">check_inputs</a> :: &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>) -&gt; &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93;<a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html#line-101" class="link">Source</a></p><div class="doc"><p>Given a list of wires that are inputs to a gate, check whether they
 are already in scope. The returned wires are not in scope, when used by a gate,
 and must be declared as undefined inputs.
</p></div></div><div class="top"><p class="src"><a name="v:add_gate" class="def">add_gate</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93; -&gt; <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoOut">CircInfoOut</a><a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html#line-106" class="link">Source</a></p><div class="doc"><p>The CircInfo Monad keeps track of all the gates that have been parsed
 and adds them to the relevant part of the state.
</p></div></div><div class="top"><p class="src"><a name="v:enter_subroutine" class="def">enter_subroutine</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> ()<a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html#line-135" class="link">Source</a></p><div class="doc"><p>The CircInfo Monad tracks whether we are in a subroutine, and collects info
 about that subroutine. The entrance to the subroutine contains its name.
</p></div></div><div class="top"><p class="src"><a name="v:add_subroutine_shape" class="def">add_subroutine_shape</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> ()<a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html#line-142" class="link">Source</a></p><div class="doc"><p>We can add the shape to the current subroutine
</p></div></div><div class="top"><p class="src"><a name="v:set_controllable" class="def">set_controllable</a> :: <a href="Quipper-Circuit.html#t:ControllableFlag">ControllableFlag</a> -&gt; <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> ()<a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html#line-152" class="link">Source</a></p><div class="doc"><p>The CircInfo Monad tracks whether we are in a subroutine, and collects info
 about that subroutine. The subroutine might be controllable.
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:CircInfoOut" class="def">CircInfoOut</a>  <a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html#line-162" class="link">Source</a></p><div class="doc"><p>A datatype to represent the various outputs a CircInfo computation
 may require.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Empty" class="def">Empty</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Lazy" class="def">Lazy</a> <a href="Quipper-Circuit.html#t:Gate">Gate</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:SubDef" class="def">SubDef</a> (<a href="Quipper-Circuit.html#t:BoxId">BoxId</a>, <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:Sub">Sub</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:isGate" class="def">isGate</a> :: <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoOut">CircInfoOut</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html#line-165" class="link">Source</a></p><div class="doc"><p>This function returns True if the given input defines a Gate
</p></div></div><div class="top"><p class="src"><a name="v:isSub" class="def">isSub</a> :: <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoOut">CircInfoOut</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html#line-170" class="link">Source</a></p><div class="doc"><p>This function returns True if the given inputs defines a SubDef
</p></div></div><div class="top"><p class="src"><a name="v:exit_subroutine" class="def">exit_subroutine</a> :: <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoOut">CircInfoOut</a><a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html#line-177" class="link">Source</a></p><div class="doc"><p>The CircInfo Monad tracks whether we are in a subroutine, and collects info
 about that subroutine. At the end of the subroutine, it stores the subroutine
 for later use.
</p></div></div><div class="top"><p class="src"><a name="v:do_gate" class="def">do_gate</a> :: <a href="QuipperLib-QuipperASCIIParser-Parse.html#t:GatePlus">GatePlus</a> -&gt; <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoOut">CircInfoOut</a><a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html#line-192" class="link">Source</a></p><div class="doc"><p>Take a GatePlus  and execute it in the <code><a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a></code> monad.
 Again, the executed computation may depend upon whether we're in a subroutine
 definition.
</p></div></div><div class="top"><p class="src"><a name="v:run_ascii_line" class="def">run_ascii_line</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoOut">CircInfoOut</a><a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html#line-206" class="link">Source</a></p><div class="doc"><p>Monad version of <code><a href="QuipperLib-QuipperASCIIParser-Parse.html#v:parse_ascii_line">parse_ascii_line</a></code>: parse a string and execute the
 resulting gate directly in the <code><a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a></code> monad.
</p></div></div><div class="top"><p class="src"><a name="v:run_ascii_lines" class="def">run_ascii_lines</a> :: &#91;<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a>&#93; -&gt; (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93;, <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> &#91;<a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoOut">CircInfoOut</a>&#93;)<a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html#line-214" class="link">Source</a></p><div class="doc"><p>Parse a stream consisting of many lines of ASCII output and execute
 the parsed gates in the <code><a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a></code> monad, checking to see if the first
 line defines the inputs to the circuit.
</p></div></div><div class="top"><p class="src"><a name="v:run" class="def">run</a> :: <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a> &#91;<a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoOut">CircInfoOut</a>&#93; -&gt; (&#91;<a href="Quipper-Circuit.html#t:Gate">Gate</a>&#93;, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-Map-Lazy.html#t:Map">Map</a> <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:Sub">Sub</a>, <a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfoState">CircInfoState</a>)<a href="src/QuipperLib/QuipperASCIIParser/CircInfo.html#line-230" class="link">Source</a></p><div class="doc"><p>Run function for the <code><a href="QuipperLib-QuipperASCIIParser-CircInfo.html#t:CircInfo">CircInfo</a></code> monad: evaluate the state and
 produce a list of inputs, outputs, and used wires.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>
