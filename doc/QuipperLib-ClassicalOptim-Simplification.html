<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>QuipperLib.ClassicalOptim.Simplification</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_QuipperLib-ClassicalOptim-Simplification.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/QuipperLib/ClassicalOptim/Simplification.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">QuipperLib.ClassicalOptim.Simplification</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Auxiliary definitions
</a></li><li><a href="#g:2">Small, simple optimizations
</a></li><li><a href="#g:3">Compression of wire numbering
</a></li><li><a href="#g:4">A useful data structure
</a></li><li><a href="#g:5">Algebraic optimization method
</a><ul><li><a href="#g:6">State of the optimization automaton
</a></li><li><a href="#g:7">The state monad
</a></li><li><a href="#g:8">Low-level access functions
</a></li><li><a href="#g:9">Higher-level access functions
</a></li><li><a href="#g:10">Auxiliary functions
</a></li><li><a href="#g:11">The algebraic optimization automaton          
</a></li><li><a href="#g:12">Some wrappers
</a></li></ul></li><li><a href="#g:13">Multi-pass optimization
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module contains the core of the classical circuit
 optimization algorithm.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:trace">trace</a> ::  <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; b -&gt; b</li><li class="src short"><a href="#v:moveWire">moveWire</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a></li><li class="src short"><a href="#v:flipCtl">flipCtl</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a></li><li class="src short"><a href="#v:moveWireFlip">moveWireFlip</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a></li><li class="src short"><a href="#v:suppress_garbage">suppress_garbage</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;</li><li class="src short"><a href="#v:suppressGarbageGates">suppressGarbageGates</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)</li><li class="src short"><a href="#v:getAllWires">getAllWires</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a></li><li class="src short"><a href="#v:getInitWires">getInitWires</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a></li><li class="src short"><a href="#v:getInputWires">getInputWires</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a></li><li class="src short"><a href="#v:compressWires">compressWires</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)</li><li class="src short"><span class="keyword">type</span> <a href="#t:GateId">GateId</a> = <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:GateIdSet">GateIdSet</a> = <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:UsedWire">UsedWire</a> = <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateIdSet">GateIdSet</a></li><li class="src short"><a href="#v:gateIdFindMin">gateIdFindMin</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateIdSet">GateIdSet</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a></li><li class="src short"><a href="#v:gateIdFindMax">gateIdFindMax</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateIdSet">GateIdSet</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a></li><li class="src short"><a href="#v:pairUsedWire">pairUsedWire</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateIdSet">GateIdSet</a></li><li class="src short"><a href="#v:firstUsedWire">firstUsedWire</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a></li><li class="src short"><a href="#v:lastUsedWire">lastUsedWire</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a></li><li class="src short"><a href="#v:nextUsedGate">nextUsedGate</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a></li><li class="src short"><a href="#v:circuitControlWires">circuitControlWires</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a></li><li class="src short"><a href="#v:circuitNotWires">circuitNotWires</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a></li><li class="src short"><a href="#v:exp_length">exp_length</a> :: <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:exp_list_and">exp_list_and</a> :: &#91;Set <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>&#93; -&gt; Set <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:expEvalCtl">expEvalCtl</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>)) -&gt; (<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; Set <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a></li><li class="src short"><a href="#v:expEvalGate">expEvalGate</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>)) -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>))</li><li class="src short"><span class="keyword">data</span>  <a href="#t:ExpState">ExpState</a>  = <a href="#v:ExpState">ExpState</a> {<ul class="subs"><li><a href="#v:gates_to_skip">gates_to_skip</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a></li><li><a href="#v:allWiresInCirc">allWiresInCirc</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a></li><li><a href="#v:gateId">gateId</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a></li><li><a href="#v:usedControlWires">usedControlWires</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a></li><li><a href="#v:usedNotWires">usedNotWires</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a></li><li><a href="#v:future">future</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;</li><li><a href="#v:past">past</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;</li><li><a href="#v:expMap">expMap</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>))</li><li><a href="#v:freshVar">freshVar</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integer">Integer</a></li><li><a href="#v:outWires">outWires</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;</li><li><a href="#v:sizeCirc">sizeCirc</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a></li></ul>}</li><li class="src short"><a href="#v:initExpState">initExpState</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:EvalCirc">EvalCirc</a> a = <a href="#v:EvalCirc">EvalCirc</a> (<a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a> -&gt; (<a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a>, a))</li><li class="src short"><a href="#v:runEvalCirc">runEvalCirc</a> ::  <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> a -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a></li><li class="src short"><a href="#v:getExpState">getExpState</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a></li><li class="src short"><a href="#v:setExpState">setExpState</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:newFreshVar">newFreshVar</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integer">Integer</a></li><li class="src short"><a href="#v:pullNewGate">pullNewGate</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>)</li><li class="src short"><a href="#v:changeFuture">changeFuture</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:updateFuture">updateFuture</a> :: (<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a>)</li><li class="src short"><a href="#v:storeOldGate">storeOldGate</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:incrGateId">incrGateId</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:getAllWiresInCirc">getAllWiresInCirc</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a></li><li class="src short"><a href="#v:setAllWiresInCirc">setAllWiresInCirc</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:removeFromAllWiresInCirc">removeFromAllWiresInCirc</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:getExpMap">getExpMap</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>)))</li><li class="src short"><a href="#v:setExpMap">setExpMap</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>)) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:updateUsedControlWires">updateUsedControlWires</a> :: (<a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a>) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:updateUsedNotWires">updateUsedNotWires</a> :: (<a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a>) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:updateOutWires">updateOutWires</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:addToSkipGates">addToSkipGates</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:sendEndOfTime">sendEndOfTime</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:shiftGate">shiftGate</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()</li><li class="src short"><a href="#v:pairEqualExp">pairEqualExp</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> &#91;<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> &#91;<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;(<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>, <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>)&#93;</li><li class="src short"><a href="#v:pruneListExp">pruneListExp</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>) -&gt; Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>)</li><li class="src short"><a href="#v:stepEvalCirc">stepEvalCirc</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:stepSwapCirc">stepSwapCirc</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:stepSwapCirc_simple">stepSwapCirc_simple</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:runWhile">runWhile</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:Monad">Monad</a> m =&gt; (a -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; m a -&gt; m ()</li><li class="src short"><a href="#v:stripNoOp">stripNoOp</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;</li><li class="src short"><a href="#v:alg_simplify">alg_simplify</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)</li><li class="src short"><a href="#v:alg_swap">alg_swap</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)</li><li class="src short"><a href="#v:alg_swap_simple">alg_swap_simple</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)</li><li class="src short"><a href="#v:is_equal_list">is_equal_list</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> a =&gt; &#91;a&#93; -&gt; &#91;a&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>)</li><li class="src short"><a href="#v:get_list_init">get_list_init</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;</li><li class="src short"><a href="#v:simplRec-39-">simplRec'</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)</li><li class="src short"><a href="#v:simplRec">simplRec</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)</li></ul></div><div id="interface"><h1 id="g:1">Auxiliary definitions
</h1><div class="top"><p class="src"><a name="v:trace" class="def">trace</a> ::  <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a> -&gt; b -&gt; b<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-29" class="link">Source</a></p><div class="doc"><p>Internal definition of a trace, for debugging purposes. This is a
 no-op, but can be replaced to turn on debugging.
</p></div></div><div class="top"><p class="src"><a name="v:moveWire" class="def">moveWire</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-34" class="link">Source</a></p><div class="doc"><p>Change a wire ID in a gate. The first two arguments are the old
 and the new wire ID.
</p></div></div><div class="top"><p class="src"><a name="v:flipCtl" class="def">flipCtl</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-45" class="link">Source</a></p><div class="doc"><p>Flip the control on the given wire (from positive to negative or
 vice versa).
</p></div></div><div class="top"><p class="src"><a name="v:moveWireFlip" class="def">moveWireFlip</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-51" class="link">Source</a></p><div class="doc"><p>Change a wire ID in a gate and flip the potential control.
</p></div></div><h1 id="g:2">Small, simple optimizations
</h1><div class="top"><p class="src"><a name="v:suppress_garbage" class="def">suppress_garbage</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-64" class="link">Source</a></p><div class="doc"><p>Suppress gates acting on garbage wires, i.e., wires that are not in the input set. 
</p></div></div><div class="top"><p class="src"><a name="v:suppressGarbageGates" class="def">suppressGarbageGates</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-79" class="link">Source</a></p><div class="doc"><p>Like <code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:suppress_garbage">suppress_garbage</a></code>, but packaged in a manner that is friendly for composition.
</p></div></div><h1 id="g:3">Compression of wire numbering
</h1><div class="doc"><p>As the optimization process goes on, many <em>init</em> gates will end
 up being discarded. The function <code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:compressWires">compressWires</a></code> compacts the wire
 numbering scheme to make a smaller circuit.
</p></div><div class="top"><p class="src"><a name="v:getAllWires" class="def">getAllWires</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-92" class="link">Source</a></p><div class="doc"><p>Get the set of all wires used by the circuit.
</p></div></div><div class="top"><p class="src"><a name="v:getInitWires" class="def">getInitWires</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-100" class="link">Source</a></p><div class="doc"><p>Get the set of wires initialized by the circuit.
</p></div></div><div class="top"><p class="src"><a name="v:getInputWires" class="def">getInputWires</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-108" class="link">Source</a></p><div class="doc"><p>Get the set of input wires, i.e., the ones that are used but not initialized.
</p></div></div><div class="top"><p class="src"><a name="v:compressWires" class="def">compressWires</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-112" class="link">Source</a></p><div class="doc"><p>Compress the wire numbering.
</p></div></div><h1 id="g:4">A useful data structure
</h1><div class="doc"><p>When considering a particular point in a circuit (i.e., in a list
 of gates), to decide whether a given wire is used or controlled
 before or after, we keep a data-structure <code><a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a></code>.
</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:GateId" class="def">GateId</a> = <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-138" class="link">Source</a></p><div class="doc"><p>The type of gate ID's.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:GateIdSet" class="def">GateIdSet</a> = <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-141" class="link">Source</a></p><div class="doc"><p>A set of gate ID's.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:UsedWire" class="def">UsedWire</a> = <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateIdSet">GateIdSet</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-146" class="link">Source</a></p><div class="doc"><p>A map from wires to pairs of <code><a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a></code>s. The left member gives the
 ID of the first gate using the wire, and the right member gives the
 ID of the last gate using the wire.
</p></div></div><div class="top"><p class="src"><a name="v:gateIdFindMin" class="def">gateIdFindMin</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateIdSet">GateIdSet</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-149" class="link">Source</a></p><div class="doc"><p>Get the minimum of a set of gate ID's.
</p></div></div><div class="top"><p class="src"><a name="v:gateIdFindMax" class="def">gateIdFindMax</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateIdSet">GateIdSet</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-153" class="link">Source</a></p><div class="doc"><p>Get the maximum of a set of gate ID's.
</p></div></div><div class="top"><p class="src"><a name="v:pairUsedWire" class="def">pairUsedWire</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateIdSet">GateIdSet</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-157" class="link">Source</a></p><div class="doc"><p>Get the pair corresponding to the given wire.
</p></div></div><div class="top"><p class="src"><a name="v:firstUsedWire" class="def">firstUsedWire</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-161" class="link">Source</a></p><div class="doc"><p>Get the first gate using the wire in the future.
</p></div></div><div class="top"><p class="src"><a name="v:lastUsedWire" class="def">lastUsedWire</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-165" class="link">Source</a></p><div class="doc"><p>Get the last gate using the wire in the past. Return 0 if none.
</p></div></div><div class="top"><p class="src"><a name="v:nextUsedGate" class="def">nextUsedGate</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-173" class="link">Source</a></p><div class="doc"><p><code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:nextUsedGate">nextUsedGate</a></code> <em>ws</em> <em>g</em> <em>g</em>' <em>w</em>: Look for the next gate in <em>ws</em>
 corresponding to wire <em>w</em>, starting from <em>g</em>. Return <em>g</em>' if none.
</p></div></div><div class="top"><p class="src"><a name="v:circuitControlWires" class="def">circuitControlWires</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-180" class="link">Source</a></p><div class="doc"><p>For each wire, find the set of gates placing a control on it.
</p></div></div><div class="top"><p class="src"><a name="v:circuitNotWires" class="def">circuitNotWires</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-194" class="link">Source</a></p><div class="doc"><p>For each wire, find the set of gates acting on it with NOT.
</p></div></div><h1 id="g:5">Algebraic optimization method
</h1><div class="doc"><p>To each wire in a circuit, we attach a set of formulas.  At each
 iteration, the wire that gets modified is updated with its new
 value, using all the possible values, possibly together with a
 fresh variable.  At each iteration, we also strip away the
 expressions that get too large. Here, the size of an algebraic
 expression is measured by the <code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:exp_length">exp_length</a></code> function.
</p></div><div class="top"><p class="src"><a name="v:exp_length" class="def">exp_length</a> :: <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-217" class="link">Source</a></p><div class="doc"><p>Calculate the size of an algebraic expression.
</p></div></div><div class="top"><p class="src"><a name="v:exp_list_and" class="def">exp_list_and</a> :: &#91;Set <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>&#93; -&gt; Set <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-225" class="link">Source</a></p><div class="doc"><p>Given a list of sets of expressions, form the conjunction of
 every possible choice of one expression from each set. For example.
</p><pre> exp_list_and &#91;{a,b}, {c,d}, {e,f}&#93; = 
     &#91;a&amp;#x2227;c&amp;#x2227;e, a&amp;#x2227;c&amp;#x2227;f, a&amp;#x2227;d&amp;#x2227;e, a&amp;#x2227;d&amp;#x2227;f, b&amp;#x2227;c&amp;#x2227;e, b&amp;#x2227;c&amp;#x2227;f, b&amp;#x2227;d&amp;#x2227;e, b&amp;#x2227;d&amp;#x2227;f&#93;.
</pre></div></div><div class="top"><p class="src"><a name="v:expEvalCtl" class="def">expEvalCtl</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>)) -&gt; (<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; Set <a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-231" class="link">Source</a></p><div class="doc"><p>Evaluate a control with respect to a state.
</p></div></div><div class="top"><p class="src"><a name="v:expEvalGate" class="def">expEvalGate</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>)) -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>))<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-236" class="link">Source</a></p><div class="doc"><p>Evaluate a gate with respect to a state.
</p></div></div><h2 id="g:6">State of the optimization automaton
</h2><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:ExpState" class="def">ExpState</a>  <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-254" class="link">Source</a></p><div class="doc"><p>The state of the automaton. This contains in particular the
 current state, the past and future gates, and a fresh variable.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:ExpState" class="def">ExpState</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:gates_to_skip" class="def">gates_to_skip</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a></dt><dd class="doc"><p>For use with <code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:stepSwapCirc">stepSwapCirc</a></code>.
</p></dd><dt class="src"><a name="v:allWiresInCirc" class="def">allWiresInCirc</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a></dt><dd class="doc"><p>All the wires in the circuit.
</p></dd><dt class="src"><a name="v:gateId" class="def">gateId</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a></dt><dd class="doc"><p>ID of the first gate in the future (starts at 1).
</p></dd><dt class="src"><a name="v:usedControlWires" class="def">usedControlWires</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a></dt><dd class="doc"><p>Location of the controls.
</p></dd><dt class="src"><a name="v:usedNotWires" class="def">usedNotWires</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a></dt><dd class="doc"><p>Location of the NOT gates.
</p></dd><dt class="src"><a name="v:future" class="def">future</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;</dt><dd class="doc"><p>Gates left to explore.
</p></dd><dt class="src"><a name="v:past" class="def">past</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;</dt><dd class="doc"><p>Gates already explored.
</p></dd><dt class="src"><a name="v:expMap" class="def">expMap</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>))</dt><dd class="doc"><p>Algebraic state of the wires. Also contains the size of the expression, so we don't have to recompute it each time.
</p></dd><dt class="src"><a name="v:freshVar" class="def">freshVar</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integer">Integer</a></dt><dd class="doc"><p>The next fresh wire.
</p></dd><dt class="src"><a name="v:outWires" class="def">outWires</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;</dt><dd class="doc"><p>The output wires.
</p></dd><dt class="src"><a name="v:sizeCirc" class="def">sizeCirc</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a></dt><dd class="doc"><p>Size of the circuit.
</p></dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><a name="v:initExpState" class="def">initExpState</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-280" class="link">Source</a></p><div class="doc"><p>The initial state for a given set of parameters.
</p></div></div><h2 id="g:7">The state monad
</h2><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:EvalCirc" class="def">EvalCirc</a> a <a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-299" class="link">Source</a></p><div class="doc"><p>The state monad corresponding to <code><a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a></code>.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:EvalCirc" class="def">EvalCirc</a> (<a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a> -&gt; (<a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a>, a))</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:EvalCirc" class="caption collapser" onclick="toggleSection('i:EvalCirc')">Instances</p><div id="section.i:EvalCirc" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:Monad">Monad</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:Functor">Functor</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Applicative.html#t:Applicative">Applicative</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:8">Low-level access functions
</h2><div class="top"><p class="src"><a name="v:runEvalCirc" class="def">runEvalCirc</a> ::  <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a> -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> a -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-318" class="link">Source</a></p><div class="doc"><p>Construct an <code><code><a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a></code></code> out of an <code><code><a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a></code></code>.
</p></div></div><div class="top"><p class="src"><a name="v:getExpState" class="def">getExpState</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-322" class="link">Source</a></p><div class="doc"><p>Retrieve the state.
</p></div></div><div class="top"><p class="src"><a name="v:setExpState" class="def">setExpState</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:ExpState">ExpState</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-326" class="link">Source</a></p><div class="doc"><p>Set the state.
</p></div></div><h2 id="g:9">Higher-level access functions
</h2><div class="top"><p class="src"><a name="v:newFreshVar" class="def">newFreshVar</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integer">Integer</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-333" class="link">Source</a></p><div class="doc"><p>Create a fresh variable
</p></div></div><div class="top"><p class="src"><a name="v:pullNewGate" class="def">pullNewGate</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Maybe.html#t:Maybe">Maybe</a> <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>)<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-341" class="link">Source</a></p><div class="doc"><p>Pull a new gate to be analyzed out of the future.
</p></div></div><div class="top"><p class="src"><a name="v:changeFuture" class="def">changeFuture</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-350" class="link">Source</a></p><div class="doc"><p>Modify the future gates.
</p></div></div><div class="top"><p class="src"><a name="v:updateFuture" class="def">updateFuture</a> :: (<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a>)<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-359" class="link">Source</a></p><div class="doc"><p>Update the future using the given parameter function. Return two sets
 of <code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:gateId">gateId</a></code>s that got modified: the first set concerns the controls,
 the second set the NOT gates.
</p></div></div><div class="top"><p class="src"><a name="v:storeOldGate" class="def">storeOldGate</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-382" class="link">Source</a></p><div class="doc"><p>Store a gate in the past.
</p></div></div><div class="top"><p class="src"><a name="v:incrGateId" class="def">incrGateId</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-390" class="link">Source</a></p><div class="doc"><p>Increase the '@gateId@' (i.e., go forward).
</p></div></div><div class="top"><p class="src"><a name="v:getAllWiresInCirc" class="def">getAllWiresInCirc</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-397" class="link">Source</a></p><div class="doc"><p>Get the set of all wires.
</p></div></div><div class="top"><p class="src"><a name="v:setAllWiresInCirc" class="def">setAllWiresInCirc</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntSet.html#t:IntSet">IntSet</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-403" class="link">Source</a></p><div class="doc"><p>Set the set of all wires.
</p></div></div><div class="top"><p class="src"><a name="v:removeFromAllWiresInCirc" class="def">removeFromAllWiresInCirc</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-410" class="link">Source</a></p><div class="doc"><p>Remove a gate from the set of all wires.
</p></div></div><div class="top"><p class="src"><a name="v:getExpMap" class="def">getExpMap</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>)))<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-417" class="link">Source</a></p><div class="doc"><p>Get the algebraic representation of the set of wires.
</p></div></div><div class="top"><p class="src"><a name="v:setExpMap" class="def">setExpMap</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>)) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-423" class="link">Source</a></p><div class="doc"><p>Set the algebraic representation of the state of wires.
</p></div></div><div class="top"><p class="src"><a name="v:updateUsedControlWires" class="def">updateUsedControlWires</a> :: (<a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a>) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-430" class="link">Source</a></p><div class="doc"><p>Update the database recording the controlled wires.
</p></div></div><div class="top"><p class="src"><a name="v:updateUsedNotWires" class="def">updateUsedNotWires</a> :: (<a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:UsedWire">UsedWire</a>) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-438" class="link">Source</a></p><div class="doc"><p>Update the database recording the NOT gates.
</p></div></div><div class="top"><p class="src"><a name="v:updateOutWires" class="def">updateOutWires</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-446" class="link">Source</a></p><div class="doc"><p>Update the list of output wires.
</p></div></div><div class="top"><p class="src"><a name="v:addToSkipGates" class="def">addToSkipGates</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-454" class="link">Source</a></p><div class="doc"><p>Add a gate ID to the list of gates to skip.
</p></div></div><div class="top"><p class="src"><a name="v:sendEndOfTime" class="def">sendEndOfTime</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-462" class="link">Source</a></p><div class="doc"><p>Send a gate to the end of the future.
</p></div></div><div class="top"><p class="src"><a name="v:shiftGate" class="def">shiftGate</a> :: <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:GateId">GateId</a> -&gt; <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> ()<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-469" class="link">Source</a></p><div class="doc"><p>Place a gate at the given gate ID in the future.
</p></div></div><h2 id="g:10">Auxiliary functions
</h2><div class="top"><p class="src"><a name="v:pairEqualExp" class="def">pairEqualExp</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> &#91;<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>&#93; -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> &#91;<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;(<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>, <a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>)&#93;<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-482" class="link">Source</a></p><div class="doc"><p><code>pairEqualExp m1 m2 ws</code>: returns a list of pairs of wires <code>(x,y)</code>
 such that <code>m2 x = m1 x = m1 y</code>.
</p></div></div><div class="top"><p class="src"><a name="v:pruneListExp" class="def">pruneListExp</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>) -&gt; Set (<a href="QuipperLib-ClassicalOptim-AlgExp.html#t:Exp">Exp</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>)<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-493" class="link">Source</a></p><div class="doc"><p>From a set of expressions (annotated with sizes), prune the ones
 whose size is larger than <em>n</em>.
</p></div></div><h2 id="g:11">The algebraic optimization automaton          
</h2><div class="top"><p class="src"><a name="v:stepEvalCirc" class="def">stepEvalCirc</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-512" class="link">Source</a></p><div class="doc"><p>Perform a set of filters acting on one gate at a time, looking
 for:
</p><ul><li> gates having no effect;
</li><li> orphan NOT-gates (i.e. NOT gates negating an out-wire) ;
</li><li> simple copy-cats (both positive and negative) ;
</li><li> hidden copy-cats.
</li></ul><p>Return <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:False">False</a></code> when the end of the circuit is reached, <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:True">True</a></code> otherwise. 
</p></div></div><div class="top"><p class="src"><a name="v:stepSwapCirc" class="def">stepSwapCirc</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-809" class="link">Source</a></p><div class="doc"><p>Shuffle the circuit by sending the CNOT gates as far as
 possible (i.e., until they hit a control, or to the end).
 Return <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:False">False</a></code> when the end of the circuit is reached, <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:True">True</a></code> otherwise. 
</p></div></div><div class="top"><p class="src"><a name="v:stepSwapCirc_simple" class="def">stepSwapCirc_simple</a> :: <a href="QuipperLib-ClassicalOptim-Simplification.html#t:EvalCirc">EvalCirc</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-904" class="link">Source</a></p><div class="doc"><p>A more elementary version of <code><code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:stepSwapCirc">stepSwapCirc</a></code></code>: shuffle the
 circuit by sending to the end all the NOT gates that can be sent
 there. Return <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:False">False</a></code> when the end of the circuit is reached,
 <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:True">True</a></code> otherwise.
</p></div></div><h2 id="g:12">Some wrappers
</h2><div class="top"><p class="src"><a name="v:runWhile" class="def">runWhile</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Control-Monad.html#t:Monad">Monad</a> m =&gt; (a -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>) -&gt; m a -&gt; m ()<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-938" class="link">Source</a></p><div class="doc"><p>Run the monad until <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:False">False</a></code> occurs.
</p></div></div><div class="top"><p class="src"><a name="v:stripNoOp" class="def">stripNoOp</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-944" class="link">Source</a></p><div class="doc"><p>Strip the <code><a href="QuipperLib-ClassicalOptim-Circuit.html#v:NoOp">NoOp</a></code> gates from a list of gates.
</p></div></div><div class="top"><p class="src"><a name="v:alg_simplify" class="def">alg_simplify</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-948" class="link">Source</a></p><div class="doc"><p>Wrapper around <code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:stepEvalCirc">stepEvalCirc</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:alg_swap" class="def">alg_swap</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-957" class="link">Source</a></p><div class="doc"><p>Wrapper around <code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:stepSwapCirc">stepSwapCirc</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:alg_swap_simple" class="def">alg_swap_simple</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-967" class="link">Source</a></p><div class="doc"><p>Wrapper around <code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:stepSwapCirc_simple">stepSwapCirc_simple</a></code>.
</p></div></div><h1 id="g:13">Multi-pass optimization
</h1><div class="top"><p class="src"><a name="v:is_equal_list" class="def">is_equal_list</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> a =&gt; &#91;a&#93; -&gt; &#91;a&#93; -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a>)<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-980" class="link">Source</a></p><div class="doc"><p>Auxiliary function. Simultaneously compute the maximum of the
 lengths of two lists, and their point-wise equality.
</p></div></div><div class="top"><p class="src"><a name="v:get_list_init" class="def">get_list_init</a> :: &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93; -&gt; &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-987" class="link">Source</a></p><div class="doc"><p>Get the list of initialized wires from a circuit.
</p></div></div><div class="top"><p class="src"><a name="v:simplRec-39-" class="def">simplRec'</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-993" class="link">Source</a></p><div class="doc"><p>Do several passes of <code><code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:alg_simplify">alg_simplify</a></code></code> until it reaches a fixed point.
</p></div></div><div class="top"><p class="src"><a name="v:simplRec" class="def">simplRec</a> :: (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;) -&gt; (&#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Gate">Gate</a>&#93;, &#91;<a href="QuipperLib-ClassicalOptim-Circuit.html#t:Wire">Wire</a>&#93;)<a href="src/QuipperLib/ClassicalOptim/Simplification.html#line-1002" class="link">Source</a></p><div class="doc"><p>Do several passed of <code><code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:alg_swap">alg_swap</a></code></code> followed with <code><code><a href="QuipperLib-ClassicalOptim-Simplification.html#v:simplRec">simplRec</a></code></code>
 until it reaches a fixed point.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>
