<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Algorithms.TF.QWTFP</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Algorithms-TF-QWTFP.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Algorithms/TF/QWTFP.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Algorithms.TF.QWTFP</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Main TF algorithm
</a></li><li><a href="#g:2">Utility subroutines
</a><ul><li><a href="#g:3">The outer quantum walk and the standard Qram
</a></li><li><a href="#g:4">The inner quantum walk
</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides an implementation of the Quantum Walk for
 the Triangle Finding Problem. 
</p><p>The algorithm works by performing a Grover-based quantum walk on
 a larger graph <em>H</em>, called the Hamming graph associated to <em>G</em>.
 We refer to this part of the algorithm as the <em>outer</em> walk. 
 The subroutine used to check whether a triangle has been found 
 is itself a quantum walk, the <em>inner</em> walk. 
</p><p>The overall algorithm is parameterized on integers <em>l</em>, <em>n</em> and <em>r</em>
 specifying respectively the length <em>l</em> of the integers used by the
 oracle, the number 2<sup><em>n</em></sup> of nodes of <em>G</em> and the size 2<sup><em>r</em></sup>
 of Hamming graph tuples.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:a1_QWTFP">a1_QWTFP</a> :: <a href="Algorithms-TF-Definitions.html#t:QWTFP_spec">QWTFP_spec</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="Quipper-Monad.html#t:Bit">Bit</a>, <a href="Algorithms-TF-Definitions.html#t:CNode">CNode</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:CNode">CNode</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Bit">Bit</a>))</li><li class="src short"><a href="#v:a2_ZERO">a2_ZERO</a> :: <a href="Quipper-QData.html#t:QShape">QShape</a> a qa ca =&gt; a -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qa</li><li class="src short"><a href="#v:a3_INITIALIZE">a3_INITIALIZE</a> :: <a href="Quipper-QData.html#t:QShape">QShape</a> a qa ca =&gt; a -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qa</li><li class="src short"><a href="#v:a4_HADAMARD">a4_HADAMARD</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qa</li><li class="src short"><a href="#v:a5_SETUP">a5_SETUP</a> :: <a href="Algorithms-TF-Definitions.html#t:QWTFP_spec">QWTFP_spec</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>))</li><li class="src short"><a href="#v:a6_QWSH">a6_QWSH</a> :: <a href="Algorithms-TF-Definitions.html#t:QWTFP_spec">QWTFP_spec</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>))</li><li class="src short"><a href="#v:a7_DIFFUSE">a7_DIFFUSE</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qa</li><li class="src short"><a href="#v:a8_FetchT">a8_FetchT</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> qa -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> qa, qa)</li><li class="src short"><a href="#v:a9_StoreT">a9_StoreT</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> qa -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> qa, qa)</li><li class="src short"><a href="#v:a10_FetchStoreT">a10_FetchStoreT</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> qa -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> qa, qa)</li><li class="src short"><a href="#v:a11_FetchE">a11_FetchE</a> :: <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>), <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)</li><li class="src short"><a href="#v:a12_FetchStoreE">a12_FetchStoreE</a> :: <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>), <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)</li><li class="src short"><a href="#v:a13_UPDATE">a13_UPDATE</a> :: <a href="Algorithms-TF-Definitions.html#t:QWTFP_spec">QWTFP_spec</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)</li><li class="src short"><a href="#v:a14_SWAP">a14_SWAP</a> :: <a href="Quipper-QData.html#t:QCData">QCData</a> qa =&gt; qa -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (qa, qa)</li><li class="src short"><a href="#v:standard_qram">standard_qram</a> :: <a href="Algorithms-TF-Definitions.html#t:Qram">Qram</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:GCQWRegs">GCQWRegs</a> = (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)</li><li class="src short"><a href="#v:a15_TestTriangleEdges">a15_TestTriangleEdges</a> :: <a href="Algorithms-TF-Definitions.html#t:QWTFP_spec">QWTFP_spec</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>), <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)</li><li class="src short"><a href="#v:a16_TriangleTestT">a16_TriangleTestT</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>), <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)</li><li class="src short"><a href="#v:a17_TriangleTestTw">a17_TriangleTestTw</a> :: <a href="Algorithms-TF-Definitions.html#t:QWTFP_spec">QWTFP_spec</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>), <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)</li><li class="src short"><a href="#v:a18_TriangleEdgeSearch">a18_TriangleEdgeSearch</a> :: <a href="Algorithms-TF-Definitions.html#t:QWTFP_spec">QWTFP_spec</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>), <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)</li><li class="src short"><a href="#v:a19_GCQWalk">a19_GCQWalk</a> :: <a href="Algorithms-TF-Definitions.html#t:QWTFP_spec">QWTFP_spec</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>), <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>)</li><li class="src short"><a href="#v:a20_GCQWStep">a20_GCQWStep</a> :: <a href="Algorithms-TF-Definitions.html#t:QWTFP_spec">QWTFP_spec</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="Algorithms-TF-QWTFP.html#t:GCQWRegs">GCQWRegs</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>), <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="Algorithms-TF-QWTFP.html#t:GCQWRegs">GCQWRegs</a>)</li></ul></div><div id="interface"><h1 id="g:1">Main TF algorithm
</h1><div class="top"><p class="src"><a name="v:a1_QWTFP" class="def">a1_QWTFP</a> :: <a href="Algorithms-TF-Definitions.html#t:QWTFP_spec">QWTFP_spec</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="Quipper-Monad.html#t:Bit">Bit</a>, <a href="Algorithms-TF-Definitions.html#t:CNode">CNode</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:CNode">CNode</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Bit">Bit</a>))<a href="src/Algorithms/TF/QWTFP.html#line-41" class="link">Source</a></p><div class="doc"><p>Algorithm 1. Do a quantum walk on the Hamming graph associated with <em>G</em>. 
 Returns a quadruple <em>(testTMeasure, wMeasure, TMeasure, EMeasure)</em> 
 where <em>wMeasure</em> contains a node of the triangle with the 
 other two nodes in <em>TMeasure</em>. 
</p></div></div><h1 id="g:2">Utility subroutines
</h1><div class="top"><p class="src"><a name="v:a2_ZERO" class="def">a2_ZERO</a> :: <a href="Quipper-QData.html#t:QShape">QShape</a> a qa ca =&gt; a -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qa<a href="src/Algorithms/TF/QWTFP.html#line-91" class="link">Source</a></p><div class="doc"><p>Algorithm 2.
 Initialize the qubits in a register to a specified state. 
 Defined using the more generic <code><a href="Quipper-Generic.html#v:qinit">qinit</a></code>.    
</p></div></div><div class="top"><p class="src"><a name="v:a3_INITIALIZE" class="def">a3_INITIALIZE</a> :: <a href="Quipper-QData.html#t:QShape">QShape</a> a qa ca =&gt; a -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qa<a href="src/Algorithms/TF/QWTFP.html#line-101" class="link">Source</a></p><div class="doc"><p>Algorithm 3.
 Initialize to a specified state then apply a Hadamard gate to 
 the qubits in a register.  
</p></div></div><div class="top"><p class="src"><a name="v:a4_HADAMARD" class="def">a4_HADAMARD</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qa<a href="src/Algorithms/TF/QWTFP.html#line-112" class="link">Source</a></p><div class="doc"><p>Algorithm 4.
 Apply a Hadamard gate to every qubit in the given quantum data. 
 Defined using the more generic <code><a href="Quipper-Generic.html#v:map_hadamard">map_hadamard</a></code>.    
</p></div></div><div class="top"><p class="src"><a name="v:a5_SETUP" class="def">a5_SETUP</a> :: <a href="Algorithms-TF-Definitions.html#t:QWTFP_spec">QWTFP_spec</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>))<a href="src/Algorithms/TF/QWTFP.html#line-122" class="link">Source</a></p><div class="doc"><p>Algorithm 5. 
 Set up the register <em>ee</em> with the edge information 
 for the nodes contained in <em>tt</em>.
</p></div></div><h2 id="g:3">The outer quantum walk and the standard Qram
</h2><div class="top"><p class="src"><a name="v:a6_QWSH" class="def">a6_QWSH</a> :: <a href="Algorithms-TF-Definitions.html#t:QWTFP_spec">QWTFP_spec</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>))<a href="src/Algorithms/TF/QWTFP.html#line-141" class="link">Source</a></p><div class="doc"><p>Algorithm 6. 
 Do a quantum walk step on the Hamming graph.
</p></div></div><div class="top"><p class="src"><a name="v:a7_DIFFUSE" class="def">a7_DIFFUSE</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qa<a href="src/Algorithms/TF/QWTFP.html#line-170" class="link">Source</a></p><div class="doc"><p>Algorithm 7. 
 Diffuse a piece of quantum data, in the Grover search sense of 
 reflecting about the average. 
</p><p>Note: relies on <code><code>shape</code> q</code> corresponding to the &#8220;all false&#8221; state. 
</p></div></div><div class="top"><p class="src"><a name="v:a8_FetchT" class="def">a8_FetchT</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> qa -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> qa, qa)<a href="src/Algorithms/TF/QWTFP.html#line-186" class="link">Source</a></p><div class="doc"><p>Algorithm 8. 
 Perform a quantum-addressed fetch operation.
 This fetches the <em>i</em>-th element from <em>tt</em> into <em>ttd</em>.
 Precondition: <em>ttd</em> = 0. 
</p><p>This could be implemented more efficiently using the qRAM implementation 
 in <a href="Alternatives.html">Alternatives</a>.
</p></div></div><div class="top"><p class="src"><a name="v:a9_StoreT" class="def">a9_StoreT</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> qa -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> qa, qa)<a href="src/Algorithms/TF/QWTFP.html#line-206" class="link">Source</a></p><div class="doc"><p>Algorithms 9. 
 Perform a quantum-addressed store operation: 
 store <em>ttd</em> into the <em>i</em>-th element from <em>tt</em>.
 Analogous to <code><a href="Algorithms-TF-QWTFP.html#v:a8_FetchT">a8_FetchT</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:a10_FetchStoreT" class="def">a10_FetchStoreT</a> :: <a href="Quipper-QData.html#t:QData">QData</a> qa =&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> qa -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> qa, qa)<a href="src/Algorithms/TF/QWTFP.html#line-226" class="link">Source</a></p><div class="doc"><p>Algorithm 10. 
 Perform a quantum-addressed swap: 
 swap <em>ttd</em> with the <em>i</em>-th element of <em>tt</em>.
 Analogous to <code><a href="Algorithms-TF-QWTFP.html#v:a8_FetchT">a8_FetchT</a></code> and <code><a href="Algorithms-TF-QWTFP.html#v:a9_StoreT">a9_StoreT</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:a11_FetchE" class="def">a11_FetchE</a> :: <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>), <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)<a href="src/Algorithms/TF/QWTFP.html#line-241" class="link">Source</a></p><div class="doc"><p>Algorithm 11.  Perform a quantum-addressed fetch operation. This
 is a somewhat specialized addressed fetching operation.
</p></div></div><div class="top"><p class="src"><a name="v:a12_FetchStoreE" class="def">a12_FetchStoreE</a> :: <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>), <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)<a href="src/Algorithms/TF/QWTFP.html#line-260" class="link">Source</a></p><div class="doc"><p>Algorithm 12. 
 Perform a quantum-addressed swap. Analogous to <code><a href="Algorithms-TF-QWTFP.html#v:a11_FetchE">a11_FetchE</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:a13_UPDATE" class="def">a13_UPDATE</a> :: <a href="Algorithms-TF-Definitions.html#t:QWTFP_spec">QWTFP_spec</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)<a href="src/Algorithms/TF/QWTFP.html#line-284" class="link">Source</a></p><div class="doc"><p>Algorithm 13. 
 Given a list of nodes <em>tt</em>, a distinguished node <em>ttd</em>, 
 and a list of bits <em>eed</em>, either:
</p><ul><li> store the edge information for <em>(ttd,tt)</em> into <em>eed</em>, if <em>eed</em> is initially 0; or
</li><li> zero <em>eed</em>, if it initially holds the edge information. 
</li></ul></div></div><div class="top"><p class="src"><a name="v:a14_SWAP" class="def">a14_SWAP</a> :: <a href="Quipper-QData.html#t:QCData">QCData</a> qa =&gt; qa -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (qa, qa)<a href="src/Algorithms/TF/QWTFP.html#line-296" class="link">Source</a></p><div class="doc"><p>Algorithm 14.  Swap two registers of equal size. This is a
 generic function and works for any quantum data type.
</p></div></div><div class="top"><p class="src"><a name="v:standard_qram" class="def">standard_qram</a> :: <a href="Algorithms-TF-Definitions.html#t:Qram">Qram</a><a href="src/Algorithms/TF/QWTFP.html#line-304" class="link">Source</a></p><div class="doc"><p>The qRAM operations from Algorithms 8&#8211;10 wrapped into a <code><a href="Algorithms-TF-Definitions.html#t:Qram">Qram</a></code> object.
</p></div></div><h2 id="g:4">The inner quantum walk
</h2><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:GCQWRegs" class="def">GCQWRegs</a> = (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)<a href="src/Algorithms/TF/QWTFP.html#line-316" class="link">Source</a></p><div class="doc"><p>A type to hold the Graph Collision Quantum Walk Registers 
 <em>(tau, iota, sigma, eew, cTri, triTestT)</em>, used in <code><a href="Algorithms-TF-QWTFP.html#v:a20_GCQWStep">a20_GCQWStep</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:a15_TestTriangleEdges" class="def">a15_TestTriangleEdges</a><a href="src/Algorithms/TF/QWTFP.html#line-328" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Algorithms-TF-Definitions.html#t:QWTFP_spec">QWTFP_spec</a></td><td class="doc"><p>The ambient oracle.
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a></td><td class="doc"><p><em>tt</em>, an <em>R</em>-tuple of nodes.
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)</td><td class="doc"><p><em>ee</em>, a cache of the edge information between nodes in <em>tt</em>.
</p></td></tr><tr><td class="src">-&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>), <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)</td><td class="doc"><p>Return <em>(tt, ee, w, triTestT,triTestTw)</em>.
</p></td></tr></table></div><div class="doc"><p>Algorithm 15: <em>TestTriangleEdges</em>.  
 Test whether the nodes <em>tt</em> contain a pair that can be extended to a 
 triangle in the graph. Used as the test function in the outer quantum 
 walk. Seeks triangles in two different ways:
</p><ol><li> Entirely within the nodes <em>tt</em>.  If found, set qubit <em>triTestT</em>.
</li><li> With two vertices from <em>tt</em>, a third anywhere in the graph.  If found, 
 set qubit <em>triTestTw</em>, and return the third vertex as <em>w</em>.  This is 
 implemented using an &#8220;inner quantum walk&#8221; to seek <em>w</em>.
</li></ol></div></div><div class="top"><p class="src"><a name="v:a16_TriangleTestT" class="def">a16_TriangleTestT</a> :: <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>), <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)<a href="src/Algorithms/TF/QWTFP.html#line-344" class="link">Source</a></p><div class="doc"><p>Algorithm 16: <em>TriangleTestT ee triTestT</em>.
 Search exhaustively over the array <em>ee</em> of edge data, seeking a triangle. 
 Whenever one is found, flip the qubit <em>triTestT</em>.  
</p></div></div><div class="top"><p class="src"><a name="v:a17_TriangleTestTw" class="def">a17_TriangleTestTw</a><a href="src/Algorithms/TF/QWTFP.html#line-393" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Algorithms-TF-Definitions.html#t:QWTFP_spec">QWTFP_spec</a></td><td class="doc"><p>The ambient oracle.
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a></td><td class="doc"><p><em>tt</em>, an <em>R</em>-tuple of nodes.
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)</td><td class="doc"><p><em>ee</em>, a cache of the edge data for <em>T</em>.
</p></td></tr><tr><td class="src">-&gt; <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a></td><td class="doc"><p><em>w</em>, another node.
</p></td></tr><tr><td class="src">-&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>), <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)</td><td class="doc"><p>return <em>(tt,ee,w,triTestTw)</em>.
</p></td></tr></table></div><div class="doc"><p>Algorithm 17: <em>TriangleTestTw ee triTestTw</em>.
 Search exhaustively for a pair of nodes in <em>tt</em> that form a triangle with <em>w</em>.  
 Whenever a triangle found, flip qubit <em>triTestTw</em>. 
</p></div></div><div class="top"><p class="src"><a name="v:a18_TriangleEdgeSearch" class="def">a18_TriangleEdgeSearch</a><a href="src/Algorithms/TF/QWTFP.html#line-456" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Algorithms-TF-Definitions.html#t:QWTFP_spec">QWTFP_spec</a></td><td class="doc"><p>The ambient oracle.
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a></td><td class="doc"><p><em>tt</em>, an <em>R</em>-tuple of nodes.
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)</td><td class="doc"><p><em>ee</em>, a cache of edge data for <em>R</em>.
</p></td></tr><tr><td class="src">-&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a></td><td class="doc"><p><em>triTestT</em>, test qubit recording if a triangle has already been found.
</p></td></tr><tr><td class="src">-&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>), <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)</td><td class="doc"><p>Return <em>(tt, ee, w, regs)</em>.
</p></td></tr></table></div><div class="doc"><p>Algorithm 18: <em>TriangleEdgeSearch</em>.
 Use Grover search to seek a node <em>w</em> that forms a triangle with some pair of
 nodes in <em>tt</em>, unless a triangle has already been found (recorded in <em>triTestT</em>), 
 in which case do nothing. 
</p></div></div><div class="top"><p class="src"><a name="v:a19_GCQWalk" class="def">a19_GCQWalk</a><a href="src/Algorithms/TF/QWTFP.html#line-494" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Algorithms-TF-Definitions.html#t:QWTFP_spec">QWTFP_spec</a></td><td class="doc"><p>The ambient oracle.
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a></td><td class="doc"><p><em>tt</em>, an <em>R</em>-tuple of nodes.
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)</td><td class="doc"><p><em>ee</em>, a cache of the edge data for <em>tt</em>.
</p></td></tr><tr><td class="src">-&gt; <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a></td><td class="doc"><p><em>w</em>, a node.
</p></td></tr><tr><td class="src">-&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a></td><td class="doc"><p><em>triTestT</em>, test qubit to record if a triangle has already been found.
</p></td></tr><tr><td class="src">-&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>), <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>, <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>)</td><td class="doc"><p>Return <em>(tt,ee,w,triTestT,cTri)</em>.
</p></td></tr></table></div><div class="doc"><p>Algorithm 19: <em>GCQWalk</em> (&#8220;Graph Collision Quantum Walk&#8221;)
</p><p>Perform graph collision on the <em>R</em>-tuple <em>tt</em> and the node <em>w</em>, to determine
 (with high probability) whether <em>w</em> forms a triangle with some pair of nodes 
 in <em>tt</em>.
</p></div></div><div class="top"><p class="src"><a name="v:a20_GCQWStep" class="def">a20_GCQWStep</a> :: <a href="Algorithms-TF-Definitions.html#t:QWTFP_spec">QWTFP_spec</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a> -&gt; <a href="Algorithms-TF-QWTFP.html#t:GCQWRegs">GCQWRegs</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> (<a href="http://hackage.haskell.org/package/containers-0.5.0.0/docs/Data-IntMap-Strict.html#t:IntMap">IntMap</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>), <a href="Algorithms-TF-Definitions.html#t:QNode">QNode</a>, <a href="Algorithms-TF-QWTFP.html#t:GCQWRegs">GCQWRegs</a>)<a href="src/Algorithms/TF/QWTFP.html#line-590" class="link">Source</a></p><div class="doc"><p>Algorithm 20: <em>GCQWStep</em>
 Take one step in the graph collision walk (used in <code><a href="Algorithms-TF-QWTFP.html#v:a19_GCQWalk">a19_GCQWalk</a></code> above).  
 Uses many auxiliary registers.
 The arguments are, in this order:
</p><ul><li> The ambient oracle.
</li><li> <em>tt</em>, an <em>R</em>-tuple of nodes.
</li><li> <em>ee</em>, a cache of the edge data for <em>tt</em>.
</li><li> <em>w</em>, a node.
</li><li> <em>regs</em>, various workspace/output registers.
</li><li> <em>ttd</em>, <em>eed</em>, <em>taud</em>, <em>eewd</em>, and <em>eedd</em>, local ancillas.
</li></ul><p>The function returns <em>(tt, ee, w, regs)</em>.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>
