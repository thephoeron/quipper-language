<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Quipper.Circuit</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Quipper-Circuit.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Quipper/Circuit.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Quipper.Circuit</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Quantum circuit data type
</a></li><li><a href="#g:2">Basic information about gates
</a></li><li><a href="#g:3">Auxiliary functions on gates and wires
</a></li><li><a href="#g:4">Dynamic arities
</a></li><li><a href="#g:5">Circuit abstraction
</a><ul><li><a href="#g:6">Reversing low-level circuits
</a></li><li><a href="#g:7">NoControlFlag on low-level circuits
</a></li><li><a href="#g:8">Ordered circuits
</a></li><li><a href="#g:9">Annotated circuits
</a></li></ul></li><li><a href="#g:10">Boxed circuits
</a><ul><li><a href="#g:11">Ordered circuits
</a></li><li><a href="#g:12">Basic functions lifted to boxed circuits
</a></li></ul></li><li><a href="#g:13">The ReadWrite monad
</a></li><li><a href="#g:14">Dynamic boxed circuits
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Low-level quantum circuit implementation. This is our backend
 implementation of quantum circuits. Note: there is no run-time
 error checking at the moment. 
</p><p>At its heart, a circuit is a list of gates. All well-definedness
 checking (e.g. input arity, output arity, and checking that the
 intermediate gates are connected to legitimate wires) is done
 dynamically, at circuit generation time, and is not stored within
 the circuit itself. This allows circuits to be produced and
 consumed lazily.
</p><p>Implementation note: this file is in the intermediate stage of a
 code refactoring, and should be considered &quot;under renovation&quot;.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="#t:Wire">Wire</a> = <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:Wiretype">Wiretype</a> <ul class="subs"><li>= <a href="#v:Qbit">Qbit</a>  </li><li>| <a href="#v:Cbit">Cbit</a>  </li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:Arity">Arity</a> = IntMap <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:Signed">Signed</a> a = <a href="#v:Signed">Signed</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:from_signed">from_signed</a> ::  <a href="Quipper-Circuit.html#t:Signed">Signed</a> a -&gt; a</li><li class="src short"><a href="#v:get_sign">get_sign</a> ::  <a href="Quipper-Circuit.html#t:Signed">Signed</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Controls">Controls</a> = &#91;<a href="Quipper-Circuit.html#t:Signed">Signed</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;</li><li class="src short"><span class="keyword">type</span> <a href="#t:Timestep">Timestep</a> = <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:InverseFlag">InverseFlag</a> = <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:NoControlFlag">NoControlFlag</a> = <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:ControllableFlag">ControllableFlag</a> <ul class="subs"><li>= <a href="#v:NoCtl">NoCtl</a>  </li><li>| <a href="#v:AllCtl">AllCtl</a>  </li><li>| <a href="#v:OnlyClassicalCtl">OnlyClassicalCtl</a>  </li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:BoxId">BoxId</a>  = <a href="#v:BoxId">BoxId</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:RepeatFlag">RepeatFlag</a>  = <a href="#v:RepeatFlag">RepeatFlag</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:Gate">Gate</a> <ul class="subs"><li>= <a href="#v:QGate">QGate</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper-Circuit.html#t:InverseFlag">InverseFlag</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:Controls">Controls</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a>  </li><li>| <a href="#v:QRot">QRot</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper-Circuit.html#t:InverseFlag">InverseFlag</a> <a href="Quipper-Circuit.html#t:Timestep">Timestep</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:Controls">Controls</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a>  </li><li>| <a href="#v:GPhase">GPhase</a> <a href="Quipper-Circuit.html#t:Timestep">Timestep</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:Controls">Controls</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a>  </li><li>| <a href="#v:CNot">CNot</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> <a href="Quipper-Circuit.html#t:Controls">Controls</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a>  </li><li>| <a href="#v:CGate">CGate</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a>  </li><li>| <a href="#v:CGateInv">CGateInv</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a>  </li><li>| <a href="#v:CSwap">CSwap</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> <a href="Quipper-Circuit.html#t:Controls">Controls</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a>  </li><li>| <a href="#v:QPrep">QPrep</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a>  </li><li>| <a href="#v:QUnprep">QUnprep</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a>  </li><li>| <a href="#v:QInit">QInit</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a>  </li><li>| <a href="#v:CInit">CInit</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a>  </li><li>| <a href="#v:QTerm">QTerm</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a>  </li><li>| <a href="#v:CTerm">CTerm</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a>  </li><li>| <a href="#v:QMeas">QMeas</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a>  </li><li>| <a href="#v:QDiscard">QDiscard</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a>  </li><li>| <a href="#v:CDiscard">CDiscard</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a>  </li><li>| <a href="#v:DTerm">DTerm</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a>  </li><li>| <a href="#v:Subroutine">Subroutine</a> <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> <a href="Quipper-Circuit.html#t:InverseFlag">InverseFlag</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:Arity">Arity</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:Arity">Arity</a> <a href="Quipper-Circuit.html#t:Controls">Controls</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> <a href="Quipper-Circuit.html#t:ControllableFlag">ControllableFlag</a> <a href="Quipper-Circuit.html#t:RepeatFlag">RepeatFlag</a>  </li><li>| <a href="#v:Comment">Comment</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper-Circuit.html#t:InverseFlag">InverseFlag</a> &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>)&#93;  </li></ul></li><li class="src short"><a href="#v:gate_arity">gate_arity</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; (&#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93;, &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93;)</li><li class="src short"><a href="#v:gate_controls">gate_controls</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; <a href="Quipper-Circuit.html#t:Controls">Controls</a></li><li class="src short"><a href="#v:gate_ncflag">gate_ncflag</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a></li><li class="src short"><a href="#v:gate_with_ncflag">gate_with_ncflag</a> :: <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> -&gt; <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; <a href="Quipper-Circuit.html#t:Gate">Gate</a></li><li class="src short"><a href="#v:gate_reverse">gate_reverse</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; <a href="Quipper-Circuit.html#t:Gate">Gate</a></li><li class="src short"><a href="#v:wires_of_controls">wires_of_controls</a> :: <a href="Quipper-Circuit.html#t:Controls">Controls</a> -&gt; IntSet</li><li class="src short"><a href="#v:wires_of_gate">wires_of_gate</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; IntSet</li><li class="src short"><a href="#v:wirelist_of_gate">wirelist_of_gate</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;</li><li class="src short"><span class="keyword">type</span> <a href="#t:ExtArity">ExtArity</a> = <a href="Libraries-Auxiliary.html#t:XIntMap">XIntMap</a> <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a></li><li class="src short"><a href="#v:arity_append_safe">arity_append_safe</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a> -&gt; <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a></li><li class="src short"><a href="#v:arity_append_unsafe">arity_append_unsafe</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a> -&gt; <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a></li><li class="src short"><a href="#v:arity_append">arity_append</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a> -&gt; <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a></li><li class="src short"><a href="#v:arity_empty">arity_empty</a> :: <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a></li><li class="src short"><a href="#v:arity_unused_wire">arity_unused_wire</a> :: <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a> -&gt; <a href="Quipper-Circuit.html#t:Wire">Wire</a></li><li class="src short"><a href="#v:arity_unused_wires">arity_unused_wires</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a> -&gt; &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;</li><li class="src short"><a href="#v:arity_alloc">arity_alloc</a> :: <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a> -&gt; <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a> -&gt; (<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a>)</li><li class="src short"><a href="#v:arity_of_extarity">arity_of_extarity</a> :: <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a> -&gt; <a href="Quipper-Circuit.html#t:Arity">Arity</a></li><li class="src short"><a href="#v:n_of_extarity">n_of_extarity</a> :: <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Circuit">Circuit</a> = (<a href="Quipper-Circuit.html#t:Arity">Arity</a>, &#91;<a href="Quipper-Circuit.html#t:Gate">Gate</a>&#93;, <a href="Quipper-Circuit.html#t:Arity">Arity</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>)</li><li class="src short"><a href="#v:wirelist_of_circuit">wirelist_of_circuit</a> :: <a href="Quipper-Circuit.html#t:Circuit">Circuit</a> -&gt; &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;</li><li class="src short"><a href="#v:reverse_gatelist">reverse_gatelist</a> :: &#91;<a href="Quipper-Circuit.html#t:Gate">Gate</a>&#93; -&gt; &#91;<a href="Quipper-Circuit.html#t:Gate">Gate</a>&#93;</li><li class="src short"><a href="#v:reverse_circuit">reverse_circuit</a> :: <a href="Quipper-Circuit.html#t:Circuit">Circuit</a> -&gt; <a href="Quipper-Circuit.html#t:Circuit">Circuit</a></li><li class="src short"><a href="#v:circuit_to_nocontrol">circuit_to_nocontrol</a> :: <a href="Quipper-Circuit.html#t:Circuit">Circuit</a> -&gt; <a href="Quipper-Circuit.html#t:Circuit">Circuit</a></li><li class="src short"><span class="keyword">newtype</span>  <a href="#t:OCircuit">OCircuit</a>  = <a href="#v:OCircuit">OCircuit</a> (&#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;, <a href="Quipper-Circuit.html#t:Circuit">Circuit</a>, &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;)</li><li class="src short"><a href="#v:reverse_ocircuit">reverse_ocircuit</a> :: <a href="Quipper-Circuit.html#t:OCircuit">OCircuit</a> -&gt; <a href="Quipper-Circuit.html#t:OCircuit">OCircuit</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:CircuitTypeStructure">CircuitTypeStructure</a> a = <a href="#v:CircuitTypeStructure">CircuitTypeStructure</a> (a -&gt; (&#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;, <a href="Quipper-Circuit.html#t:Arity">Arity</a>)) ((&#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;, <a href="Quipper-Circuit.html#t:Arity">Arity</a>) -&gt; a)</li><li class="src short"><a href="#v:id_CircuitTypeStructure">id_CircuitTypeStructure</a> :: <a href="Quipper-Circuit.html#t:CircuitTypeStructure">CircuitTypeStructure</a> (&#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;, <a href="Quipper-Circuit.html#t:Arity">Arity</a>)</li><li class="src short"><a href="#v:destructure_with">destructure_with</a> ::  <a href="Quipper-Circuit.html#t:CircuitTypeStructure">CircuitTypeStructure</a> a -&gt; a -&gt; (&#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;, <a href="Quipper-Circuit.html#t:Arity">Arity</a>)</li><li class="src short"><a href="#v:structure_with">structure_with</a> ::  <a href="Quipper-Circuit.html#t:CircuitTypeStructure">CircuitTypeStructure</a> a -&gt; (&#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;, <a href="Quipper-Circuit.html#t:Arity">Arity</a>) -&gt; a</li><li class="src short"><span class="keyword">data</span>  <a href="#t:TypedSubroutine">TypedSubroutine</a>  = <span class="keyword">forall</span> a b . (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> b) =&gt; <a href="#v:TypedSubroutine">TypedSubroutine</a> <a href="Quipper-Circuit.html#t:OCircuit">OCircuit</a> (<a href="Quipper-Circuit.html#t:CircuitTypeStructure">CircuitTypeStructure</a> a) (<a href="Quipper-Circuit.html#t:CircuitTypeStructure">CircuitTypeStructure</a> b) <a href="Quipper-Circuit.html#t:ControllableFlag">ControllableFlag</a></li><li class="src short"><a href="#v:circuit_of_typedsubroutine">circuit_of_typedsubroutine</a> :: <a href="Quipper-Circuit.html#t:TypedSubroutine">TypedSubroutine</a> -&gt; <a href="Quipper-Circuit.html#t:Circuit">Circuit</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Namespace">Namespace</a> = Map <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> <a href="Quipper-Circuit.html#t:TypedSubroutine">TypedSubroutine</a></li><li class="src short"><a href="#v:namespace_empty">namespace_empty</a> :: <a href="Quipper-Circuit.html#t:Namespace">Namespace</a></li><li class="src short"><a href="#v:showNames">showNames</a> :: <a href="Quipper-Circuit.html#t:Namespace">Namespace</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:BCircuit">BCircuit</a> = (<a href="Quipper-Circuit.html#t:Circuit">Circuit</a>, <a href="Quipper-Circuit.html#t:Namespace">Namespace</a>)</li><li class="src short"><span class="keyword">type</span> <a href="#t:OBCircuit">OBCircuit</a> = (<a href="Quipper-Circuit.html#t:OCircuit">OCircuit</a>, <a href="Quipper-Circuit.html#t:Namespace">Namespace</a>)</li><li class="src short"><a href="#v:ob_circuit">ob_circuit</a> :: &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; -&gt; <a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a> -&gt; &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; -&gt; <a href="Quipper-Circuit.html#t:OBCircuit">OBCircuit</a></li><li class="src short"><a href="#v:reverse_bcircuit">reverse_bcircuit</a> :: <a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a> -&gt; <a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:ReadWrite">ReadWrite</a> a<ul class="subs"><li>= <a href="#v:RW_Return">RW_Return</a> a  </li><li>| <a href="#v:RW_Write">RW_Write</a> !<a href="Quipper-Circuit.html#t:Gate">Gate</a> (<a href="Quipper-Circuit.html#t:ReadWrite">ReadWrite</a> a)  </li><li>| <a href="#v:RW_Read">RW_Read</a> !<a href="Quipper-Circuit.html#t:Wire">Wire</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Quipper-Circuit.html#t:ReadWrite">ReadWrite</a> a)  </li><li>| <a href="#v:RW_Subroutine">RW_Subroutine</a> <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> <a href="Quipper-Circuit.html#t:TypedSubroutine">TypedSubroutine</a> (<a href="Quipper-Circuit.html#t:ReadWrite">ReadWrite</a> a)  </li></ul></li><li class="src short"><a href="#v:readwrite_wrap">readwrite_wrap</a> ::  <a href="Quipper-Circuit.html#t:ReadWrite">ReadWrite</a> a -&gt; <a href="Quipper-Circuit.html#t:ReadWrite">ReadWrite</a> (&#91;<a href="Quipper-Circuit.html#t:Gate">Gate</a>&#93;, a)</li><li class="src short"><a href="#v:readwrite_unwind_static">readwrite_unwind_static</a> ::  <a href="Libraries-Auxiliary.html#t:ErrMsg">ErrMsg</a> -&gt; <a href="Quipper-Circuit.html#t:ReadWrite">ReadWrite</a> a -&gt; a</li><li class="src short"><a href="#v:gatelist_of_readwrite">gatelist_of_readwrite</a> ::  <a href="Libraries-Auxiliary.html#t:ErrMsg">ErrMsg</a> -&gt; <a href="Quipper-Circuit.html#t:ReadWrite">ReadWrite</a> a -&gt; <a href="Quipper-Circuit.html#t:Namespace">Namespace</a> -&gt; (&#91;<a href="Quipper-Circuit.html#t:Gate">Gate</a>&#93;, <a href="Quipper-Circuit.html#t:Namespace">Namespace</a>, a)</li><li class="src short"><span class="keyword">type</span> <a href="#t:DBCircuit">DBCircuit</a> a = (<a href="Quipper-Circuit.html#t:Arity">Arity</a>, <a href="Quipper-Circuit.html#t:ReadWrite">ReadWrite</a> (<a href="Quipper-Circuit.html#t:Arity">Arity</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, a))</li><li class="src short"><a href="#v:bcircuit_of_static_dbcircuit">bcircuit_of_static_dbcircuit</a> ::  <a href="Libraries-Auxiliary.html#t:ErrMsg">ErrMsg</a> -&gt; <a href="Quipper-Circuit.html#t:DBCircuit">DBCircuit</a> a -&gt; (<a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a>, a)</li><li class="src short"><a href="#v:dbcircuit_of_bcircuit">dbcircuit_of_bcircuit</a> ::  <a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a> -&gt; a -&gt; <a href="Quipper-Circuit.html#t:DBCircuit">DBCircuit</a> a</li></ul></div><div id="interface"><h1 id="g:1">Quantum circuit data type
</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Wire" class="def">Wire</a> = <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a><a href="src/Quipper/Circuit.html#line-47" class="link">Source</a></p><div class="doc"><p>Wire identifier. Wires are currently identified by an integer,
 but the users of this interface should be oblivious to this.
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Wiretype" class="def">Wiretype</a>  <a href="src/Quipper/Circuit.html#line-50" class="link">Source</a></p><div class="doc"><p>Wire type. A wire is either quantum or classical.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Qbit" class="def">Qbit</a></td><td class="doc"><p>Quantum wire. 
</p></td></tr><tr><td class="src"><a name="v:Cbit" class="def">Cbit</a></td><td class="doc"><p>Classical wire.
</p></td></tr></table></div><div class="subs instances"><p id="control.i:Wiretype" class="caption collapser" onclick="toggleSection('i:Wiretype')">Instances</p><div id="section.i:Wiretype" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Arity" class="def">Arity</a> = IntMap <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a><a href="src/Quipper/Circuit.html#line-56" class="link">Source</a></p><div class="doc"><p>An arity, also known as a typing context, is a map from a finite
 set of wires to wire types.
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Signed" class="def">Signed</a> a <a href="src/Quipper/Circuit.html#line-64" class="link">Source</a></p><div class="doc"><p>A signed item of type <em>a</em>. <code><a href="Quipper-Circuit.html#t:Signed">Signed</a></code> <em>x</em> <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code> represents a
 positive item, and <code><a href="Quipper-Circuit.html#t:Signed">Signed</a></code> <em>x</em> <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:False">False</a></code> represents a negative item.
</p><p>When used with wires in a circuit, a positive sign is used to
 represent a positive control, i.e., a filled dot, and a negative
 sign is used to represent a negative control, i.e., an empty dot.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Signed" class="def">Signed</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Signed" class="caption collapser" onclick="toggleSection('i:Signed')">Instances</p><div id="section.i:Signed" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Typeable-Internal.html#t:Typeable1">Typeable1</a> <a href="Quipper-Circuit.html#t:Signed">Signed</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Quipper-Circuit.html#t:Signed">Signed</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-Control.html#t:ControlSource">ControlSource</a> (<a href="Quipper-Circuit.html#t:Signed">Signed</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper-Control.html#t:ControlSource">ControlSource</a> (<a href="Quipper-Circuit.html#t:Signed">Signed</a> a), <a href="Quipper-Control.html#t:ControlSource">ControlSource</a> (<a href="Quipper-Circuit.html#t:Signed">Signed</a> b)) =&gt; <a href="Quipper-Control.html#t:ControlSource">ControlSource</a> (<a href="Quipper-Circuit.html#t:Signed">Signed</a> (<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-Control.html#t:ControlSource">ControlSource</a> (<a href="Quipper-Circuit.html#t:Signed">Signed</a> <a href="Quipper-Monad.html#t:Bit">Bit</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-Control.html#t:ControlSource">ControlSource</a> (<a href="Quipper-Circuit.html#t:Signed">Signed</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-QData.html#t:QCData">QCData</a> a =&gt; <a href="Quipper-QData.html#t:QCData">QCData</a> (<a href="Quipper-Circuit.html#t:Signed">Signed</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-Labels.html#t:Labelable">Labelable</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> =&gt; <a href="Quipper-Labels.html#t:Labelable">Labelable</a> (<a href="Quipper-Circuit.html#t:Signed">Signed</a> a) <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-Labels.html#t:Labelable">Labelable</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> =&gt; <a href="Quipper-Labels.html#t:Labelable">Labelable</a> (<a href="Quipper-Circuit.html#t:Signed">Signed</a> a) (<a href="Quipper-Circuit.html#t:Signed">Signed</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:from_signed" class="def">from_signed</a> ::  <a href="Quipper-Circuit.html#t:Signed">Signed</a> a -&gt; a<a href="src/Quipper/Circuit.html#line-68" class="link">Source</a></p><div class="doc"><p>Extract the underlying item of a signed item.
</p></div></div><div class="top"><p class="src"><a name="v:get_sign" class="def">get_sign</a> ::  <a href="Quipper-Circuit.html#t:Signed">Signed</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a><a href="src/Quipper/Circuit.html#line-73" class="link">Source</a></p><div class="doc"><p>Extract the sign of a signed item: <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code> is positive, and
 <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:False">False</a></code> is negative.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Controls" class="def">Controls</a> = &#91;<a href="Quipper-Circuit.html#t:Signed">Signed</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;<a href="src/Quipper/Circuit.html#line-77" class="link">Source</a></p><div class="doc"><p>A list of controlled wires, possibly empty.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Timestep" class="def">Timestep</a> = <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a><a href="src/Quipper/Circuit.html#line-82" class="link">Source</a></p><div class="doc"><p>A time step is a small floating point number used as a
 parameter to certain gates, such as rotation gates or the
 <i>e</i><sup>&#8722;<em>iZt</em></sup> gate.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:InverseFlag" class="def">InverseFlag</a> = <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a><a href="src/Quipper/Circuit.html#line-85" class="link">Source</a></p><div class="doc"><p>A flag that, if <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code>, indicates that the gate is inverted.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:NoControlFlag" class="def">NoControlFlag</a> = <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a><a href="src/Quipper/Circuit.html#line-94" class="link">Source</a></p><div class="doc"><p>A flag that, if <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code>, indicates that the gate is controllable,
 but any further controls on the gate should be ignored. This is
 used, e.g., for circuits consisting of a basis change, some
 operation, and the inverse basis change. When controlling such a
 circuit, it is sufficient to control the middle operation, so the
 gates belonging to the basis change and its inverse will have the
 NoControlFlag set.
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:ControllableFlag" class="def">ControllableFlag</a>  <a href="src/Quipper/Circuit.html#line-98" class="link">Source</a></p><div class="doc"><p>A flag, to specify if the corresponding subroutine can be controlled.
 Either no control allowed, or all controls, or only classical.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:NoCtl" class="def">NoCtl</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:AllCtl" class="def">AllCtl</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:OnlyClassicalCtl" class="def">OnlyClassicalCtl</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:ControllableFlag" class="caption collapser" onclick="toggleSection('i:ControllableFlag')">Instances</p><div id="section.i:ControllableFlag" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Quipper-Circuit.html#t:ControllableFlag">ControllableFlag</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a> <a href="Quipper-Circuit.html#t:ControllableFlag">ControllableFlag</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Quipper-Circuit.html#t:ControllableFlag">ControllableFlag</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:BoxId" class="def">BoxId</a>  <a href="src/Quipper/Circuit.html#line-109" class="link">Source</a></p><div class="doc"><p>An identifier for a subroutine. A boxed subroutine is currently
 identified by a pair of: the user-defined name of the subroutine;
 and a value uniquely identifying the type and shape of the argument.
</p><p>For now, we represent the shape as a string, because this gives an
 easy total <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a></code> instance, needed for <a href="http://hackage.haskell.org/packages/archive/containers/0.4.2.1/doc/html/Data-Map.html">Data.Map</a>. However, in
 principle, one could also use a pair of a type representation and a
 shape term. The implementation of this may change later.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:BoxId" class="def">BoxId</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:BoxId" class="caption collapser" onclick="toggleSection('i:BoxId')">Instances</p><div id="section.i:BoxId" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Quipper-Circuit.html#t:BoxId">BoxId</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a> <a href="Quipper-Circuit.html#t:BoxId">BoxId</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Quipper-Circuit.html#t:BoxId">BoxId</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:RepeatFlag" class="def">RepeatFlag</a>  <a href="src/Quipper/Circuit.html#line-115" class="link">Source</a></p><div class="doc"><p>A flag that indicates how many times a particular subroutine
 should be repeated. If non-zero, it implies some constraints on
 the type of the subroutine.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:RepeatFlag" class="def">RepeatFlag</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:RepeatFlag" class="caption collapser" onclick="toggleSection('i:RepeatFlag')">Instances</p><div id="section.i:RepeatFlag" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Quipper-Circuit.html#t:RepeatFlag">RepeatFlag</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a> <a href="Quipper-Circuit.html#t:RepeatFlag">RepeatFlag</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Quipper-Circuit.html#t:RepeatFlag">RepeatFlag</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Gate" class="def">Gate</a>  <a href="src/Quipper/Circuit.html#line-125" class="link">Source</a></p><div class="doc"><p>The low-level representation of gates.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:QGate" class="def">QGate</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper-Circuit.html#t:InverseFlag">InverseFlag</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:Controls">Controls</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a></td><td class="doc"><p>A named reversible quantum gate: <code><code><a href="Quipper-Circuit.html#v:Qbit">Qbit</a></code>^(m+n) -&gt;
 <code><a href="Quipper-Circuit.html#v:Qbit">Qbit</a></code>^(m+n)</code>.  The second <code>&#91;<code><a href="Quipper-Circuit.html#t:Wire">Wire</a></code>&#93;</code> argument should be
 &quot;generalized controls&quot;, i.e. wires not modified by the
 gate. The gate type is uniquely determined by: the name, the
 number of inputs, and the number of generalized controls. Gates
 that differ in one of these respects should be regarded as
 different gates.
</p></td></tr><tr><td class="src"><a name="v:QRot" class="def">QRot</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper-Circuit.html#t:InverseFlag">InverseFlag</a> <a href="Quipper-Circuit.html#t:Timestep">Timestep</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:Controls">Controls</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a></td><td class="doc"><p>A named reversible quantum gate that also depends on a real
 parameter. This is typically used for phase and rotation
 gates. The gate name can contain '%' as a place holder for
 the parameter, e.g., <code>&quot;exp(-i%Z)&quot;</code>. The remaining arguments
 are as for <code><a href="Quipper-Circuit.html#v:QGate">QGate</a></code>.
</p></td></tr><tr><td class="src"><a name="v:GPhase" class="def">GPhase</a> <a href="Quipper-Circuit.html#t:Timestep">Timestep</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:Controls">Controls</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a></td><td class="doc"><p>Global phase gate: <code>'1' -&gt; '1'</code>. The list of wires is just a hint for graphical rendering.
</p></td></tr><tr><td class="src"><a name="v:CNot" class="def">CNot</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> <a href="Quipper-Circuit.html#t:Controls">Controls</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a></td><td class="doc"><p>Classical not: <code><code><a href="Quipper-Circuit.html#v:Cbit">Cbit</a></code> -&gt; <code><a href="Quipper-Circuit.html#v:Cbit">Cbit</a></code></code>.
</p></td></tr><tr><td class="src"><a name="v:CGate" class="def">CGate</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a></td><td class="doc"><p>Generic classical gate <code>1 -&gt; <code><a href="Quipper-Circuit.html#v:Cbit">Cbit</a></code></code>.
</p></td></tr><tr><td class="src"><a name="v:CGateInv" class="def">CGateInv</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a></td><td class="doc"><p>Uncompute classical gate <code><code><a href="Quipper-Circuit.html#v:Cbit">Cbit</a></code> -&gt; 1</code>, asserting that the
 classical bit is in the state specified by the corresponding
 <code><a href="Quipper-Circuit.html#v:CGate">CGate</a></code>.
</p></td></tr><tr><td class="src"><a name="v:CSwap" class="def">CSwap</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> <a href="Quipper-Circuit.html#t:Controls">Controls</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a></td><td class="doc"><p>Classical swap gate: <code><code><a href="Quipper-Circuit.html#v:Cbit">Cbit</a></code> * <code><a href="Quipper-Circuit.html#v:Cbit">Cbit</a></code> -&gt; <code><a href="Quipper-Circuit.html#v:Cbit">Cbit</a></code> * <code><a href="Quipper-Circuit.html#v:Cbit">Cbit</a></code></code>.
</p></td></tr><tr><td class="src"><a name="v:QPrep" class="def">QPrep</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a></td><td class="doc"><p>Initialization: <code><code><a href="Quipper-Circuit.html#v:Cbit">Cbit</a></code> -&gt; <code><a href="Quipper-Circuit.html#v:Qbit">Qbit</a></code></code>.
</p></td></tr><tr><td class="src"><a name="v:QUnprep" class="def">QUnprep</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a></td><td class="doc"><p>Measurement <code><code><a href="Quipper-Circuit.html#v:Qbit">Qbit</a></code> -&gt; <code><a href="Quipper-Circuit.html#v:Cbit">Cbit</a></code></code> with an assertion that the
 qubit is already in a computational basis state. This kind of
 measurement loses no information, and is formally the inverse
 of <code><a href="Quipper-Circuit.html#v:QPrep">QPrep</a></code>.
</p></td></tr><tr><td class="src"><a name="v:QInit" class="def">QInit</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a></td><td class="doc"><p>Initialization: <code><code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></code> -&gt; <code><a href="Quipper-Circuit.html#v:Qbit">Qbit</a></code></code>. 
</p></td></tr><tr><td class="src"><a name="v:CInit" class="def">CInit</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a></td><td class="doc"><p>Initialization: <code><code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></code> -&gt; <code><a href="Quipper-Circuit.html#v:Cbit">Cbit</a></code></code>. 
</p></td></tr><tr><td class="src"><a name="v:QTerm" class="def">QTerm</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a></td><td class="doc"><p>Termination of a <code><a href="Quipper-Circuit.html#v:Qbit">Qbit</a></code> wire with assertion
 that the qubit is in the specified state:
 <code><code><a href="Quipper-Circuit.html#v:Qbit">Qbit</a></code> * <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></code> -&gt; 1</code>.
</p></td></tr><tr><td class="src"><a name="v:CTerm" class="def">CTerm</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a></td><td class="doc"><p>Termination of a <code><a href="Quipper-Circuit.html#v:Cbit">Cbit</a></code> wire with assertion
 that the bit is in the specified state:
 <code><code><a href="Quipper-Circuit.html#v:Cbit">Cbit</a></code> * <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></code> -&gt; 1</code>.
</p></td></tr><tr><td class="src"><a name="v:QMeas" class="def">QMeas</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a></td><td class="doc"><p>Measurement: <code><code><a href="Quipper-Circuit.html#v:Qbit">Qbit</a></code> -&gt; <code><a href="Quipper-Circuit.html#v:Cbit">Cbit</a></code></code>.
</p></td></tr><tr><td class="src"><a name="v:QDiscard" class="def">QDiscard</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a></td><td class="doc"><p>Termination of a <code><a href="Quipper-Circuit.html#v:Qbit">Qbit</a></code> wire without
 assertion: <code><code><a href="Quipper-Circuit.html#v:Qbit">Qbit</a></code> -&gt; 1</code>
</p></td></tr><tr><td class="src"><a name="v:CDiscard" class="def">CDiscard</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a></td><td class="doc"><p>Termination of a <code><a href="Quipper-Circuit.html#v:Cbit">Cbit</a></code> wire without
 assertion: <code><code><a href="Quipper-Circuit.html#v:Cbit">Cbit</a></code> -&gt; 1</code>
</p></td></tr><tr><td class="src"><a name="v:DTerm" class="def">DTerm</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a></td><td class="doc"><p>Termination of a <code><a href="Quipper-Circuit.html#v:Cbit">Cbit</a></code> wire, with a comment indicating what
 the observed state of that wire was. This is typically inserted
 in a circuit after a dynamic lifting is performed. Unlike
 <code><a href="Quipper-Circuit.html#v:CTerm">CTerm</a></code>, this is in no way an assertion, but simply a record of
 observed behavior during a particular run of the algorithm.
</p></td></tr><tr><td class="src"><a name="v:Subroutine" class="def">Subroutine</a> <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> <a href="Quipper-Circuit.html#t:InverseFlag">InverseFlag</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:Arity">Arity</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:Arity">Arity</a> <a href="Quipper-Circuit.html#t:Controls">Controls</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> <a href="Quipper-Circuit.html#t:ControllableFlag">ControllableFlag</a> <a href="Quipper-Circuit.html#t:RepeatFlag">RepeatFlag</a></td><td class="doc"><p>Reference to a subroutine, assumed to be bound to another
 circuit. Arbitrary input and output arities. The domain of <em>a1</em>
 must include the range of <em>ws1</em>, and similarly for <em>a2</em> and <em>ws2</em>.
</p></td></tr><tr><td class="src"><a name="v:Comment" class="def">Comment</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper-Circuit.html#t:InverseFlag">InverseFlag</a> &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>)&#93;</td><td class="doc"><p>A comment. Does nothing, but can be useful for marking a
 location or some wires in a circuit.
</p></td></tr></table></div><div class="subs instances"><p id="control.i:Gate" class="caption collapser" onclick="toggleSection('i:Gate')">Instances</p><div id="section.i:Gate" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Quipper-Circuit.html#t:Gate">Gate</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:2">Basic information about gates
</h1><div class="top"><p class="src"><a name="v:gate_arity" class="def">gate_arity</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; (&#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93;, &#91;(<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a>)&#93;)<a href="src/Quipper/Circuit.html#line-227" class="link">Source</a></p><div class="doc"><p>Compute the incoming and outgoing wires of a given gate
 (excluding controls, comments, and anchors). This essentially
 encodes the type information of the basic gates. If a wire is used
 multiple times as an input or output, then <code><a href="Quipper-Circuit.html#v:gate_arity">gate_arity</a></code> also
 returns it multiple times; this enables run-time type checking.
</p><p>Note that <code><a href="Quipper-Circuit.html#v:gate_arity">gate_arity</a></code> returns the <em>logical</em> wires, and therefore
 excludes things like labels, comments, and graphical anchors. This
 is in contrast to <code><a href="Quipper-Circuit.html#v:wires_of_gate">wires_of_gate</a></code>, which returns the <em>syntactic</em>
 set of wires used by the gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_controls" class="def">gate_controls</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; <a href="Quipper-Circuit.html#t:Controls">Controls</a><a href="src/Quipper/Circuit.html#line-253" class="link">Source</a></p><div class="doc"><p>Return the controls of a gate (or an empty list if the gate has
 no controls).
</p></div></div><div class="top"><p class="src"><a name="v:gate_ncflag" class="def">gate_ncflag</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a><a href="src/Quipper/Circuit.html#line-275" class="link">Source</a></p><div class="doc"><p>Return the <code><a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a></code> of a gate, or <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:False">False</a></code> if it doesn't have one.
</p></div></div><div class="top"><p class="src"><a name="v:gate_with_ncflag" class="def">gate_with_ncflag</a> :: <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> -&gt; <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; <a href="Quipper-Circuit.html#t:Gate">Gate</a><a href="src/Quipper/Circuit.html#line-304" class="link">Source</a></p><div class="doc"><p>Apply the given <code><a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a></code> to the given <code><a href="Quipper-Circuit.html#t:Gate">Gate</a></code>. This means,
 if the first parameter is <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code>, set the gate's <code><a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a></code>,
 otherwise do nothing. Throw an error if attempting to set the
 <code><a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a></code> on a gate that can't support this flag.
</p></div></div><div class="top"><p class="src"><a name="v:gate_reverse" class="def">gate_reverse</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; <a href="Quipper-Circuit.html#t:Gate">Gate</a><a href="src/Quipper/Circuit.html#line-334" class="link">Source</a></p><div class="doc"><p>Reverse a gate. Throw an error if the gate is not reversible.
</p></div></div><h1 id="g:3">Auxiliary functions on gates and wires
</h1><div class="top"><p class="src"><a name="v:wires_of_controls" class="def">wires_of_controls</a> :: <a href="Quipper-Circuit.html#t:Controls">Controls</a> -&gt; IntSet<a href="src/Quipper/Circuit.html#line-362" class="link">Source</a></p><div class="doc"><p>Return the set of wires used by a list of controls.
</p></div></div><div class="top"><p class="src"><a name="v:wires_of_gate" class="def">wires_of_gate</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; IntSet<a href="src/Quipper/Circuit.html#line-372" class="link">Source</a></p><div class="doc"><p>Return the set of wires used by a gate (including controls,
 labels, and anchors). 
</p><p>Unlike <code><a href="Quipper-Circuit.html#v:gate_arity">gate_arity</a></code>, the function <code><a href="Quipper-Circuit.html#v:wires_of_gate">wires_of_gate</a></code> is used for
 printing, and therefore returns all wires that are syntactically
 used by the gate, irrespective of whether they have a logical
 meaning.
</p></div></div><div class="top"><p class="src"><a name="v:wirelist_of_gate" class="def">wirelist_of_gate</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;<a href="src/Quipper/Circuit.html#line-385" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper-Circuit.html#v:wires_of_gate">wires_of_gate</a></code>, except return a list of wires.
</p></div></div><h1 id="g:4">Dynamic arities
</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:ExtArity" class="def">ExtArity</a> = <a href="Libraries-Auxiliary.html#t:XIntMap">XIntMap</a> <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a><a href="src/Quipper/Circuit.html#line-397" class="link">Source</a></p><div class="doc"><p>Recall that an <code><a href="Quipper-Circuit.html#t:Arity">Arity</a></code> is a set of typed wires, and it determines
 the external interfaces at which circuits and gates can be
 connected.  The type <code><a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a></code> stores the same information as the
 type <code><a href="Quipper-Circuit.html#t:Arity">Arity</a></code>, but in a format that is more optimized for efficient
 updating. Additionally, it also stores the set of wires ever used.
</p></div></div><div class="top"><p class="src"><a name="v:arity_append_safe" class="def">arity_append_safe</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a> -&gt; <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a><a href="src/Quipper/Circuit.html#line-417" class="link">Source</a></p><div class="doc"><p>Check whether the given gate is well-formed and can be legally
 applied in the context of the given arity. If successful, return
 the updated arity resulting from the gate application. If
 unsuccessful, raise an error. Properties checked are:
</p><ul><li> that each gate has non-overlapping inputs, including controls;
</li><li> that each gate has non-overlapping outputs, including controls;
</li><li> that the inputs of the gate (including controls) are actually
 present in the current arity; 
</li><li> that the types of the inputs (excluding controls) match those of
 the current arity;
</li><li> that the outputs of the gate (excluding controls) don't conflict
 with any wires already existing in the current arity.
</li></ul></div></div><div class="top"><p class="src"><a name="v:arity_append_unsafe" class="def">arity_append_unsafe</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a> -&gt; <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a><a href="src/Quipper/Circuit.html#line-449" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper-Circuit.html#v:arity_append">arity_append</a></code>, but without type checking. This is
 potentially faster, but should only used in applications that have
 already been thoroughly tested or type-checked.
</p></div></div><div class="top"><p class="src"><a name="v:arity_append" class="def">arity_append</a> :: <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a> -&gt; <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a><a href="src/Quipper/Circuit.html#line-459" class="link">Source</a></p><div class="doc"><p>For now, we disable run-time type checking, because we have not
 yet implemented run-time types properly. Therefore, we define
 <code><a href="Quipper-Circuit.html#v:arity_append">arity_append</a></code> to be a synonym for <code><a href="Quipper-Circuit.html#v:arity_append_unsafe">arity_append_unsafe</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:arity_empty" class="def">arity_empty</a> :: <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a><a href="src/Quipper/Circuit.html#line-463" class="link">Source</a></p><div class="doc"><p>Return an empty arity.
</p></div></div><div class="top"><p class="src"><a name="v:arity_unused_wire" class="def">arity_unused_wire</a> :: <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a> -&gt; <a href="Quipper-Circuit.html#t:Wire">Wire</a><a href="src/Quipper/Circuit.html#line-467" class="link">Source</a></p><div class="doc"><p>Return a wire unused in the current arity.
</p></div></div><div class="top"><p class="src"><a name="v:arity_unused_wires" class="def">arity_unused_wires</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a> -&gt; &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;<a href="src/Quipper/Circuit.html#line-471" class="link">Source</a></p><div class="doc"><p>Return the next <em>k</em> wires unused in the current arity.
</p></div></div><div class="top"><p class="src"><a name="v:arity_alloc" class="def">arity_alloc</a> :: <a href="Quipper-Circuit.html#t:Wiretype">Wiretype</a> -&gt; <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a> -&gt; (<a href="Quipper-Circuit.html#t:Wire">Wire</a>, <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a>)<a href="src/Quipper/Circuit.html#line-476" class="link">Source</a></p><div class="doc"><p>Add a new typed wire to the current arity. This returns a new
 wire and the updated arity.
</p></div></div><div class="top"><p class="src"><a name="v:arity_of_extarity" class="def">arity_of_extarity</a> :: <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a> -&gt; <a href="Quipper-Circuit.html#t:Arity">Arity</a><a href="src/Quipper/Circuit.html#line-482" class="link">Source</a></p><div class="doc"><p>Convert an extended arity to an ordinary arity.
</p></div></div><div class="top"><p class="src"><a name="v:n_of_extarity" class="def">n_of_extarity</a> :: <a href="Quipper-Circuit.html#t:ExtArity">ExtArity</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a><a href="src/Quipper/Circuit.html#line-486" class="link">Source</a></p><div class="doc"><p>Return the smallest wire id nowhere used in the circuit.
</p></div></div><h1 id="g:5">Circuit abstraction
</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Circuit" class="def">Circuit</a> = (<a href="Quipper-Circuit.html#t:Arity">Arity</a>, &#91;<a href="Quipper-Circuit.html#t:Gate">Gate</a>&#93;, <a href="Quipper-Circuit.html#t:Arity">Arity</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>)<a href="src/Quipper/Circuit.html#line-497" class="link">Source</a></p><div class="doc"><p>A completed circuit <em>(a1,gs,a2,n)</em> has an input arity <em>a1</em>, a
 list of gates <em>gs</em>, and an output arity <em>a2</em>.  We also record <em>n</em>,
 the total number of wires used by the circuit. Because wires are
 allocated consecutively, this means that the wire id's used are
 &#91;0..<em>n</em>-1&#93;.
</p></div></div><div class="top"><p class="src"><a name="v:wirelist_of_circuit" class="def">wirelist_of_circuit</a> :: <a href="Quipper-Circuit.html#t:Circuit">Circuit</a> -&gt; &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;<a href="src/Quipper/Circuit.html#line-500" class="link">Source</a></p><div class="doc"><p>Return the set of all the wires in a circuit.
</p></div></div><h2 id="g:6">Reversing low-level circuits
</h2><div class="top"><p class="src"><a name="v:reverse_gatelist" class="def">reverse_gatelist</a> :: &#91;<a href="Quipper-Circuit.html#t:Gate">Gate</a>&#93; -&gt; &#91;<a href="Quipper-Circuit.html#t:Gate">Gate</a>&#93;<a href="src/Quipper/Circuit.html#line-507" class="link">Source</a></p><div class="doc"><p>Reverse a gate list.
</p></div></div><div class="top"><p class="src"><a name="v:reverse_circuit" class="def">reverse_circuit</a> :: <a href="Quipper-Circuit.html#t:Circuit">Circuit</a> -&gt; <a href="Quipper-Circuit.html#t:Circuit">Circuit</a><a href="src/Quipper/Circuit.html#line-511" class="link">Source</a></p><div class="doc"><p>Reverse a circuit. Throw an error if the circuit is not reversible.
</p></div></div><h2 id="g:7">NoControlFlag on low-level circuits
</h2><div class="top"><p class="src"><a name="v:circuit_to_nocontrol" class="def">circuit_to_nocontrol</a> :: <a href="Quipper-Circuit.html#t:Circuit">Circuit</a> -&gt; <a href="Quipper-Circuit.html#t:Circuit">Circuit</a><a href="src/Quipper/Circuit.html#line-518" class="link">Source</a></p><div class="doc"><p>Set the <code><a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a></code> on all gates of a circuit.
</p></div></div><h2 id="g:8">Ordered circuits
</h2><div class="top"><p class="src"><span class="keyword">newtype</span>  <a name="t:OCircuit" class="def">OCircuit</a>  <a href="src/Quipper/Circuit.html#line-533" class="link">Source</a></p><div class="doc"><p>An ordered circuit is a <code><a href="Quipper-Circuit.html#t:Circuit">Circuit</a></code> together with an ordering on
 (usually all, but potentially a subset of) the input and output
 endpoints.
</p><p>This extra information is required when a circuit is used within a
 larger circuit (e.g. via a <code><a href="Quipper-Circuit.html#v:Subroutine">Subroutine</a></code> gate), to identify which wires
 of the sub-circuit should be bound to which wires of the surrounding 
 circuit.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:OCircuit" class="def">OCircuit</a> (&#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;, <a href="Quipper-Circuit.html#t:Circuit">Circuit</a>, &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;)</td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:reverse_ocircuit" class="def">reverse_ocircuit</a> :: <a href="Quipper-Circuit.html#t:OCircuit">OCircuit</a> -&gt; <a href="Quipper-Circuit.html#t:OCircuit">OCircuit</a><a href="src/Quipper/Circuit.html#line-536" class="link">Source</a></p><div class="doc"><p>Reverse an <code><a href="Quipper-Circuit.html#t:OCircuit">OCircuit</a></code>. Throw an error if the circuit is not reversible.
</p></div></div><h2 id="g:9">Annotated circuits
</h2><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:CircuitTypeStructure" class="def">CircuitTypeStructure</a> a <a href="src/Quipper/Circuit.html#line-556" class="link">Source</a></p><div class="doc"><p>One often wants to consider the inputs and outputs of a circuit as
 more structured<em>typed than just lists of bits</em>qubits; for instance,
 a list of six qubits could be structured as a pair of triples, or a 
 triple of pairs, or a six-bit <code>QDInt</code>.
</p><p>While for the most part this typing information is not included in 
 low-level circuits, we need to consider it in hierarchical circuits,
 so that the information stored in a subroutine is sufficient to call
 the subroutine in a typed context.
</p><p>Specifically, the extra information needed consists of functions to
 destructure the input/output data as a list of typed wires, and 
 restructure such a list of wires into a piece of data of the appropriate
 type. 
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:CircuitTypeStructure" class="def">CircuitTypeStructure</a> (a -&gt; (&#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;, <a href="Quipper-Circuit.html#t:Arity">Arity</a>)) ((&#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;, <a href="Quipper-Circuit.html#t:Arity">Arity</a>) -&gt; a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:CircuitTypeStructure" class="caption collapser" onclick="toggleSection('i:CircuitTypeStructure')">Instances</p><div id="section.i:CircuitTypeStructure" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Typeable-Internal.html#t:Typeable1">Typeable1</a> <a href="Quipper-Circuit.html#t:CircuitTypeStructure">CircuitTypeStructure</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:id_CircuitTypeStructure" class="def">id_CircuitTypeStructure</a> :: <a href="Quipper-Circuit.html#t:CircuitTypeStructure">CircuitTypeStructure</a> (&#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;, <a href="Quipper-Circuit.html#t:Arity">Arity</a>)<a href="src/Quipper/Circuit.html#line-560" class="link">Source</a></p><div class="doc"><p>The trivial <code><a href="Quipper-Circuit.html#t:CircuitTypeStructure">CircuitTypeStructure</a></code> on <code>(&#91;<code><a href="Quipper-Circuit.html#t:Wire">Wire</a></code>&#93;,<code><a href="Quipper-Circuit.html#t:Arity">Arity</a></code>)</code>.
</p></div></div><div class="top"><p class="src"><a name="v:destructure_with" class="def">destructure_with</a> ::  <a href="Quipper-Circuit.html#t:CircuitTypeStructure">CircuitTypeStructure</a> a -&gt; a -&gt; (&#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;, <a href="Quipper-Circuit.html#t:Arity">Arity</a>)<a href="src/Quipper/Circuit.html#line-565" class="link">Source</a></p><div class="doc"><p>Use a <code><a href="Quipper-Circuit.html#t:CircuitTypeStructure">CircuitTypeStructure</a></code> to destructure a piece of (suitably
 typed) data into a list of typed wires.
</p></div></div><div class="top"><p class="src"><a name="v:structure_with" class="def">structure_with</a> ::  <a href="Quipper-Circuit.html#t:CircuitTypeStructure">CircuitTypeStructure</a> a -&gt; (&#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;, <a href="Quipper-Circuit.html#t:Arity">Arity</a>) -&gt; a<a href="src/Quipper/Circuit.html#line-570" class="link">Source</a></p><div class="doc"><p>Use a <code><a href="Quipper-Circuit.html#t:CircuitTypeStructure">CircuitTypeStructure</a></code> to structure a list of typed wires 
 (of the appropriate length/arity) into a piece of structured data.
</p></div></div><h1 id="g:10">Boxed circuits
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:TypedSubroutine" class="def">TypedSubroutine</a>  <a href="src/Quipper/Circuit.html#line-585" class="link">Source</a></p><div class="doc"><p>A typed subroutine consists of:
</p><ul><li> a low-level circuit, ordered to allow binding of incoming and outgoing wires;
</li><li> functions for structuring/destructuring the inputs and outputs to and 
 from lists of wires (these functions being dynamically typed, since the 
 input/output type may vary between subroutines);
</li><li> a <code><a href="Quipper-Circuit.html#t:ControllableFlag">ControllableFlag</a></code>, recording whether the circuit is controllable.
</li></ul></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><span class="keyword">forall</span> a b . (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> b) =&gt; <a name="v:TypedSubroutine" class="def">TypedSubroutine</a> <a href="Quipper-Circuit.html#t:OCircuit">OCircuit</a> (<a href="Quipper-Circuit.html#t:CircuitTypeStructure">CircuitTypeStructure</a> a) (<a href="Quipper-Circuit.html#t:CircuitTypeStructure">CircuitTypeStructure</a> b) <a href="Quipper-Circuit.html#t:ControllableFlag">ControllableFlag</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div><div class="top"><p class="src"><a name="v:circuit_of_typedsubroutine" class="def">circuit_of_typedsubroutine</a> :: <a href="Quipper-Circuit.html#t:TypedSubroutine">TypedSubroutine</a> -&gt; <a href="Quipper-Circuit.html#t:Circuit">Circuit</a><a href="src/Quipper/Circuit.html#line-589" class="link">Source</a></p><div class="doc"><p>Extract just the <code><a href="Quipper-Circuit.html#t:Circuit">Circuit</a></code> from a <code><a href="Quipper-Circuit.html#t:TypedSubroutine">TypedSubroutine</a></code>.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Namespace" class="def">Namespace</a> = Map <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> <a href="Quipper-Circuit.html#t:TypedSubroutine">TypedSubroutine</a><a href="src/Quipper/Circuit.html#line-596" class="link">Source</a></p><div class="doc"><p>A name space is a map from names to subroutine bindings.  These
 subroutines can reference each other; it is the programmer&#8217;s
 responsibility to ensure there is no circular dependency, and no
 clash of names.
</p></div></div><div class="top"><p class="src"><a name="v:namespace_empty" class="def">namespace_empty</a> :: <a href="Quipper-Circuit.html#t:Namespace">Namespace</a><a href="src/Quipper/Circuit.html#line-599" class="link">Source</a></p><div class="doc"><p>The empty namespace.
</p></div></div><div class="top"><p class="src"><a name="v:showNames" class="def">showNames</a> :: <a href="Quipper-Circuit.html#t:Namespace">Namespace</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a><a href="src/Quipper/Circuit.html#line-603" class="link">Source</a></p><div class="doc"><p>A function to display the names of all the subroutines in a <code><a href="Quipper-Circuit.html#t:Namespace">Namespace</a></code>.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:BCircuit" class="def">BCircuit</a> = (<a href="Quipper-Circuit.html#t:Circuit">Circuit</a>, <a href="Quipper-Circuit.html#t:Namespace">Namespace</a>)<a href="src/Quipper/Circuit.html#line-607" class="link">Source</a></p><div class="doc"><p>A boxed circuit is a distinguished simple circuit (analogous to a &#8220;main&#8221; function) together with a namespace. 
</p></div></div><h2 id="g:11">Ordered circuits
</h2><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:OBCircuit" class="def">OBCircuit</a> = (<a href="Quipper-Circuit.html#t:OCircuit">OCircuit</a>, <a href="Quipper-Circuit.html#t:Namespace">Namespace</a>)<a href="src/Quipper/Circuit.html#line-615" class="link">Source</a></p><div class="doc"><p>An ordered boxed circuit is a <code><a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a></code> together with an
 ordering on the input and output endpoints, or equivalently, an
 <code><a href="Quipper-Circuit.html#t:OCircuit">OCircuit</a></code> together with a namespace.
</p></div></div><div class="top"><p class="src"><a name="v:ob_circuit" class="def">ob_circuit</a> :: &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; -&gt; <a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a> -&gt; &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; -&gt; <a href="Quipper-Circuit.html#t:OBCircuit">OBCircuit</a><a href="src/Quipper/Circuit.html#line-619" class="link">Source</a></p><div class="doc"><p>Construct an <code><a href="Quipper-Circuit.html#t:OBCircuit">OBCircuit</a></code> from a <code><a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a></code> and an ordering on the
 input and output endpoints.
</p></div></div><h2 id="g:12">Basic functions lifted to boxed circuits
</h2><div class="top"><p class="src"><a name="v:reverse_bcircuit" class="def">reverse_bcircuit</a> :: <a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a> -&gt; <a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a><a href="src/Quipper/Circuit.html#line-629" class="link">Source</a></p><div class="doc"><p>Reverse a simple boxed circuit, or throw an error if not reversible.
</p></div></div><h1 id="g:13">The ReadWrite monad
</h1><div class="doc"><p>The <code><a href="Quipper-Circuit.html#t:ReadWrite">ReadWrite</a></code> monad encapsulates the interaction with a (real
 or simulated) low-level quantum device.
</p></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:ReadWrite" class="def">ReadWrite</a> a <a href="src/Quipper/Circuit.html#line-649" class="link">Source</a></p><div class="doc"><p>The <code><a href="Quipper-Circuit.html#t:ReadWrite">ReadWrite</a></code> monad describes a standard read-write computation,
 here specialized to the case where writes are <code><a href="Quipper-Circuit.html#t:Gate">Gate</a></code>s, prompts are
 <code>Bit</code>s, and reads are <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></code>s. Thus, a read-write computation can
 do three things:
</p><ul><li> terminate with a result. This is the case <code><a href="Quipper-Circuit.html#v:RW_Return">RW_Return</a></code>.
</li><li> write a single <code><a href="Quipper-Circuit.html#t:Gate">Gate</a></code> and continue. This is the case <code><a href="Quipper-Circuit.html#v:RW_Write">RW_Write</a></code>.
</li><li> issue a prompt, which is a <code><a href="Quipper-Circuit.html#t:Wire">Wire</a></code>, then read a <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></code>, then
 continue. This is the case <code><a href="Quipper-Circuit.html#v:RW_Read">RW_Read</a></code>.
</li></ul></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:RW_Return" class="def">RW_Return</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:RW_Write" class="def">RW_Write</a> !<a href="Quipper-Circuit.html#t:Gate">Gate</a> (<a href="Quipper-Circuit.html#t:ReadWrite">ReadWrite</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:RW_Read" class="def">RW_Read</a> !<a href="Quipper-Circuit.html#t:Wire">Wire</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Quipper-Circuit.html#t:ReadWrite">ReadWrite</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:RW_Subroutine" class="def">RW_Subroutine</a> <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> <a href="Quipper-Circuit.html#t:TypedSubroutine">TypedSubroutine</a> (<a href="Quipper-Circuit.html#t:ReadWrite">ReadWrite</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:ReadWrite" class="caption collapser" onclick="toggleSection('i:ReadWrite')">Instances</p><div id="section.i:ReadWrite" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> <a href="Quipper-Circuit.html#t:ReadWrite">ReadWrite</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:readwrite_wrap" class="def">readwrite_wrap</a> ::  <a href="Quipper-Circuit.html#t:ReadWrite">ReadWrite</a> a -&gt; <a href="Quipper-Circuit.html#t:ReadWrite">ReadWrite</a> (&#91;<a href="Quipper-Circuit.html#t:Gate">Gate</a>&#93;, a)<a href="src/Quipper/Circuit.html#line-668" class="link">Source</a></p><div class="doc"><p>Transforms a read-write computation into one that behaves identically,
 but also returns the list of gates generated.
</p><p>This is used as a building block, for example to allow a read-write
 computation to be run in a simulator while simultaneously using a
 static backend to print the list of generated gates.
</p></div></div><div class="top"><p class="src"><a name="v:readwrite_unwind_static" class="def">readwrite_unwind_static</a> ::  <a href="Libraries-Auxiliary.html#t:ErrMsg">ErrMsg</a> -&gt; <a href="Quipper-Circuit.html#t:ReadWrite">ReadWrite</a> a -&gt; a<a href="src/Quipper/Circuit.html#line-684" class="link">Source</a></p><div class="doc"><p>Extract the contents of a static <code><a href="Quipper-Circuit.html#t:ReadWrite">ReadWrite</a></code> computation. A
 <code><a href="Quipper-Circuit.html#t:ReadWrite">ReadWrite</a></code> computation is said to be static if it contains no
 <code><a href="Quipper-Circuit.html#v:RW_Read">RW_Read</a></code> instructions, or in other words, no dynamic lifting.  If
 an <code><a href="Quipper-Circuit.html#v:RW_Read">RW_Read</a></code> instruction is encountered, issue an error message
 using the given stub.
</p></div></div><div class="top"><p class="src"><a name="v:gatelist_of_readwrite" class="def">gatelist_of_readwrite</a> ::  <a href="Libraries-Auxiliary.html#t:ErrMsg">ErrMsg</a> -&gt; <a href="Quipper-Circuit.html#t:ReadWrite">ReadWrite</a> a -&gt; <a href="Quipper-Circuit.html#t:Namespace">Namespace</a> -&gt; (&#91;<a href="Quipper-Circuit.html#t:Gate">Gate</a>&#93;, <a href="Quipper-Circuit.html#t:Namespace">Namespace</a>, a)<a href="src/Quipper/Circuit.html#line-708" class="link">Source</a></p><div class="doc"><p>Turn a static read-write computation into a list of gates, while
 also updating a namespace. &quot;Static&quot; means that the computation
 may not contain any <code><a href="Quipper-Circuit.html#v:RW_Read">RW_Read</a></code> operations. If it does, the message
 &quot;dynamic lifting&quot; is passed to the given error handler.
</p><p>Important usage note: This function returns a triple (<em>gates</em>,
 <em>ns</em>, <em>x</em>). The list of gates is generated lazily, and can be
 consumed one gate at a time. However, the values <em>ns</em> and <em>x</em> are
 only computed at the end of the computation. Any function using
 them should not apply a strict pattern match to <em>ns</em> or <em>x</em>, or
 else the whole list of gates will be generated in memory. For
 example, the following will blow up the memory:
</p><pre> (gates, ns, (a, n, x)) = gatelist_of_readwrite errmsg comp
</pre><p>whereas the following will work as intended:
</p><pre> (gates, ns, ~(a, n, x)) = gatelist_of_readwrite errmsg comp
</pre></div></div><h1 id="g:14">Dynamic boxed circuits
</h1><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:DBCircuit" class="def">DBCircuit</a> a = (<a href="Quipper-Circuit.html#t:Arity">Arity</a>, <a href="Quipper-Circuit.html#t:ReadWrite">ReadWrite</a> (<a href="Quipper-Circuit.html#t:Arity">Arity</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, a))<a href="src/Quipper/Circuit.html#line-731" class="link">Source</a></p><div class="doc"><p>The type of dynamic boxed circuits. The type <code><a href="Quipper-Circuit.html#t:DBCircuit">DBCircuit</a></code> <em>a</em> is
 the appropriate generalization of (<code><a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a></code>, <em>a</em>), in a setting
 that is dynamic rather than static (i.e., with dynamic lifting or
 &quot;interactive measurement&quot;).
</p></div></div><div class="top"><p class="src"><a name="v:bcircuit_of_static_dbcircuit" class="def">bcircuit_of_static_dbcircuit</a> ::  <a href="Libraries-Auxiliary.html#t:ErrMsg">ErrMsg</a> -&gt; <a href="Quipper-Circuit.html#t:DBCircuit">DBCircuit</a> a -&gt; (<a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a>, a)<a href="src/Quipper/Circuit.html#line-738" class="link">Source</a></p><div class="doc"><p>Convert a dynamic boxed circuit to a static boxed circuit. The
 dynamic boxed circuit may not contain any dynamic liftings, since
 these cannot be performed in a static setting. In case any output
 liftings are encountered, try to issue a meaningful error via the
 given stub error message.
</p></div></div><div class="top"><p class="src"><a name="v:dbcircuit_of_bcircuit" class="def">dbcircuit_of_bcircuit</a> ::  <a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a> -&gt; a -&gt; <a href="Quipper-Circuit.html#t:DBCircuit">DBCircuit</a> a<a href="src/Quipper/Circuit.html#line-747" class="link">Source</a></p><div class="doc"><p>Convert a boxed circuit to a dynamic boxed circuit. The latter,
 of course, contains no <code><a href="Quipper-Circuit.html#v:RW_Read">RW_Read</a></code> instructions.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.11.0</p></div></body></html>
