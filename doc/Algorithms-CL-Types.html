<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Algorithms.CL.Types</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Algorithms-CL-Types.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Algorithms/CL/Types.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Algorithms.CL.Types</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Type synonyms
</a></li><li><a href="#g:2">Algebraic number fields
</a><ul><li><a href="#g:3">Discriminants
</a></li><li><a href="#g:4">Field elements
</a></li></ul></li><li><a href="#g:5">Ideals
</a><ul><li><a href="#g:6">Trivial access functions
</a></li><li><a href="#g:7">Assertions, coercions
</a></li><li><a href="#g:8">Bounds on coefficient sizes
</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module defines the specialized datatypes of the Class Number algorithm, and basic utility functions on these types.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">type</span> <a href="#t:CLInt">CLInt</a> = <a href="QuipperLib-Arith.html#t:IntM">IntM</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:CLIntP">CLIntP</a> = <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integer">Integer</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:CLRational">CLRational</a> = <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Rational">Rational</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:CLReal">CLReal</a> = <a href="QuipperLib-FPReal.html#t:FPReal">FPReal</a></li><li class="src short"><a href="#v:bigD_of_d">bigD_of_d</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; a</li><li class="src short"><a href="#v:d_of_bigD">d_of_bigD</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; a</li><li class="src short"><a href="#v:is_valid_d">is_valid_d</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:is_valid_bigD">is_valid_bigD</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:all_small_ds">all_small_ds</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> int =&gt; &#91;int&#93;</li><li class="src short"><a href="#v:all_bigDs">all_bigDs</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> int =&gt; &#91;int&#93;</li><li class="src short"><span class="keyword">data</span>  <a href="#t:AlgNumGen">AlgNumGen</a> a<ul class="subs"><li>= <a href="#v:AlgNum">AlgNum</a> a a <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a>  </li><li>| <a href="#v:AlgNum_indet">AlgNum_indet</a> a  </li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:AlgNum">AlgNum</a> = <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> <a href="Algorithms-CL-Types.html#t:CLRational">CLRational</a></li><li class="src short"><a href="#v:fst_AlgNum">fst_AlgNum</a> ::  <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a -&gt; a</li><li class="src short"><a href="#v:snd_AlgNum">snd_AlgNum</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a> a =&gt; <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a -&gt; a</li><li class="src short"><a href="#v:pretty_show_AlgNum">pretty_show_AlgNum</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Show.html#t:Show">Show</a> a =&gt; <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a></li><li class="src short"><a href="#v:floating_of_AlgNum">floating_of_AlgNum</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Real">Real</a> a, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> b) =&gt; <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a -&gt; b</li><li class="src short"><a href="#v:number_promote">number_promote</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a> a =&gt; <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a -&gt; <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> b -&gt; <a href="Libraries-Auxiliary.html#t:ErrMsg">ErrMsg</a> -&gt; <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a</li><li class="src short"><a href="#v:conjugate">conjugate</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a> a =&gt; <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a -&gt; <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a</li><li class="src short"><a href="#v:is_alg_int">is_alg_int</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> a, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:RealFrac">RealFrac</a> a) =&gt; <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:is_unit">is_unit</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> a, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:RealFrac">RealFrac</a> a) =&gt; <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:omega_of_bigD">omega_of_bigD</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Algorithms-CL-Types.html#t:AlgNum">AlgNum</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:IdealX">IdealX</a> x = <a href="#v:Ideal">Ideal</a> <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> (<a href="QuipperLib-Arith.html#t:XInt">XInt</a> x) (<a href="QuipperLib-Arith.html#t:XInt">XInt</a> x) (<a href="QuipperLib-Arith.html#t:XInt">XInt</a> x) (<a href="QuipperLib-Arith.html#t:XInt">XInt</a> x)</li><li class="src short"><span class="keyword">type</span> <a href="#t:Ideal">Ideal</a> = <a href="Algorithms-CL-Types.html#t:IdealX">IdealX</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:IdealQ">IdealQ</a> = <a href="Algorithms-CL-Types.html#t:IdealX">IdealX</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:IdealC">IdealC</a> = <a href="Algorithms-CL-Types.html#t:IdealX">IdealX</a> <a href="Quipper-Monad.html#t:Bit">Bit</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:IdealRedX">IdealRedX</a> x = <a href="#v:IdealRed">IdealRed</a> <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> (<a href="QuipperLib-Arith.html#t:XInt">XInt</a> x) (<a href="QuipperLib-Arith.html#t:XInt">XInt</a> x)</li><li class="src short"><span class="keyword">type</span> <a href="#t:IdealRed">IdealRed</a> = <a href="Algorithms-CL-Types.html#t:IdealRedX">IdealRedX</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:IdealRedQ">IdealRedQ</a> = <a href="Algorithms-CL-Types.html#t:IdealRedX">IdealRedX</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:IdealRedC">IdealRedC</a> = <a href="Algorithms-CL-Types.html#t:IdealRedX">IdealRedX</a> <a href="Quipper-Monad.html#t:Bit">Bit</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:IdDist">IdDist</a> = (<a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a>, <a href="QuipperLib-FPReal.html#t:FPReal">FPReal</a>)</li><li class="src short"><span class="keyword">type</span> <a href="#t:IdDistQ">IdDistQ</a> = (<a href="Algorithms-CL-Types.html#t:IdealQ">IdealQ</a>, <a href="QuipperLib-FPReal.html#t:FPRealQ">FPRealQ</a>)</li><li class="src short"><span class="keyword">type</span> <a href="#t:IdRedDist">IdRedDist</a> = (<a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a>, <a href="QuipperLib-FPReal.html#t:FPReal">FPReal</a>)</li><li class="src short"><span class="keyword">type</span> <a href="#t:IdRedDistQ">IdRedDistQ</a> = (<a href="Algorithms-CL-Types.html#t:IdealRedQ">IdealRedQ</a>, <a href="QuipperLib-FPReal.html#t:FPRealQ">FPRealQ</a>)</li><li class="src short"><a href="#v:d_of_Ideal">d_of_Ideal</a> ::  <a href="Algorithms-CL-Types.html#t:IdealX">IdealX</a> a -&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a></li><li class="src short"><a href="#v:d_of_IdealRed">d_of_IdealRed</a> ::  <a href="Algorithms-CL-Types.html#t:IdealRedX">IdealRedX</a> a -&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a></li><li class="src short"><a href="#v:bigD_of_Ideal">bigD_of_Ideal</a> ::  <a href="Algorithms-CL-Types.html#t:IdealX">IdealX</a> a -&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a></li><li class="src short"><a href="#v:bigD_of_IdealRed">bigD_of_IdealRed</a> ::  <a href="Algorithms-CL-Types.html#t:IdealRedX">IdealRedX</a> a -&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a></li><li class="src short"><a href="#v:delta">delta</a> :: <a href="Algorithms-CL-Types.html#t:IdDist">IdDist</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a></li><li class="src short"><a href="#v:tau">tau</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> int, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> int') =&gt; int' -&gt; int -&gt; int -&gt; int</li><li class="src short"><a href="#v:is_standard">is_standard</a> :: <a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:is_reduced">is_reduced</a> :: <a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:is_really_reduced">is_really_reduced</a> :: <a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:forget_reduced">forget_reduced</a> :: <a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a> -&gt; <a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a></li><li class="src short"><a href="#v:to_reduced">to_reduced</a> :: <a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a> -&gt; <a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a></li><li class="src short"><a href="#v:assert_reduced">assert_reduced</a> ::  <a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a> -&gt; a -&gt; a</li><li class="src short"><a href="#v:assert_really_reduced">assert_really_reduced</a> ::  <a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a> -&gt; a -&gt; a</li><li class="src short"><a href="#v:q_tau">q_tau</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>)</li><li class="src short"><a href="#v:q_is_reduced">q_is_reduced</a> :: <a href="Algorithms-CL-Types.html#t:IdealQ">IdealQ</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="Algorithms-CL-Types.html#t:IdealQ">IdealQ</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)</li><li class="src short"><a href="#v:q_is_really_reduced">q_is_really_reduced</a> :: <a href="Algorithms-CL-Types.html#t:IdealRedQ">IdealRedQ</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="Algorithms-CL-Types.html#t:IdealRedQ">IdealRedQ</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)</li><li class="src short"><a href="#v:q_forget_reduced">q_forget_reduced</a> :: <a href="Algorithms-CL-Types.html#t:IdealRedQ">IdealRedQ</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Algorithms-CL-Types.html#t:IdealQ">IdealQ</a></li><li class="src short"><a href="#v:q_assert_reduced">q_assert_reduced</a> :: <a href="Algorithms-CL-Types.html#t:IdealQ">IdealQ</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Algorithms-CL-Types.html#t:IdealRedQ">IdealRedQ</a></li><li class="src short"><a href="#v:q_assert_really_reduced">q_assert_really_reduced</a> :: <a href="Algorithms-CL-Types.html#t:IdealRedQ">IdealRedQ</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Algorithms-CL-Types.html#t:IdealRedQ">IdealRedQ</a></li><li class="src short"><a href="#v:length_for_ab">length_for_ab</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:length_for_ml">length_for_ml</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:n_of_bigD">n_of_bigD</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> int =&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; int</li><li class="src short"><a href="#v:precision_for_fN">precision_for_fN</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:fix_sizes_Ideal">fix_sizes_Ideal</a> :: <a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a> -&gt; <a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a></li><li class="src short"><a href="#v:fix_sizes_IdealRed">fix_sizes_IdealRed</a> :: <a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a> -&gt; <a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a></li></ul></div><div id="interface"><h1 id="g:1">Type synonyms
</h1><div class="doc"><p>First, we define some type synonyms for arithmetic types, selecting which will be used in the functions for the Class Number algorithm.
</p><p>We use three different integer types.  For interfacing with quantum computation, we use <code><a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a></code> := <code><a href="QuipperLib-Arith.html#t:IntM">IntM</a></code>.  For efficient classical (i.e. circuit-generation time) computation on potentially large integers, we use <code><a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a></code> := <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integer">Integer</a></code>, Haskell&#8217;s arbitrary-precision integers.  (&#916;, for instance, is taken to be a <code><a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a></code>).  For small classical integers (typically for register sizes), we use <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a></code>, Haskell&#8217;s bounded-precision integers.
</p><p>For the first two of these, we define type synonyms, so that they can be swapped out to other types if desired (they are to a large extent modular).  For <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a></code> we do not, since we make un-coerced use of built-in Haskell functions like <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-List.html#v:length">length</a></code> which give it specifically.
</p><p>Where not dictated by these conventions, integer types are generalized, i.e., <code>(Integral a) =&gt;</code> &#8230;
</p><p>Rational and real numbers have not yet been similarly stratified.
</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:CLInt" class="def">CLInt</a> = <a href="QuipperLib-Arith.html#t:IntM">IntM</a><a href="src/Algorithms/CL/Types.html#line-36" class="link">Source</a></p><div class="doc"><p>Integers that may be passed into or received out of quantum computations.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:CLIntP" class="def">CLIntP</a> = <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integer">Integer</a><a href="src/Algorithms/CL/Types.html#line-39" class="link">Source</a></p><div class="doc"><p>Integers that will be used for parameter computation only, potentially large.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:CLRational" class="def">CLRational</a> = <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Rational">Rational</a><a href="src/Algorithms/CL/Types.html#line-42" class="link">Source</a></p><div class="doc"><p>Rational numbers for the Class Number code.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:CLReal" class="def">CLReal</a> = <a href="QuipperLib-FPReal.html#t:FPReal">FPReal</a><a href="src/Algorithms/CL/Types.html#line-45" class="link">Source</a></p><div class="doc"><p>Real numbers for the Class Number code.
</p></div></div><h1 id="g:2">Algebraic number fields
</h1><h2 id="g:3">Discriminants
</h2><div class="doc"><p>The functions of this subsection are needed only for circuit-generation-time classical computation, not for quantum circuit computation.
</p></div><div class="top"><p class="src"><a name="v:bigD_of_d" class="def">bigD_of_d</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; a<a href="src/Algorithms/CL/Types.html#line-57" class="link">Source</a></p><div class="doc"><p>Compute &#916;, given <em>d</em>.
 (See &#91;Jozsa 2003&#93;, Prop. 6 et seq.  We use &#916;, or in code <code>bigD</code>, where Jozsa uses <em>D</em>.)
</p></div></div><div class="top"><p class="src"><a name="v:d_of_bigD" class="def">d_of_bigD</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; a<a href="src/Algorithms/CL/Types.html#line-64" class="link">Source</a></p><div class="doc"><p>Compute <em>d</em>, given &#916;.
 (Again, see &#91;Jozsa 2003&#93;, Prop. 6 et seq.)
</p></div></div><div class="top"><p class="src"><a name="v:is_valid_d" class="def">is_valid_d</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/Algorithms/CL/Types.html#line-71" class="link">Source</a></p><div class="doc"><p>Check if <em>d</em> is a valid input to Hallgren&#8217;s algorithm,
 i.e. correctly defines a real quadratic number field.
</p></div></div><div class="top"><p class="src"><a name="v:is_valid_bigD" class="def">is_valid_bigD</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> a =&gt; a -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/Algorithms/CL/Types.html#line-77" class="link">Source</a></p><div class="doc"><p>Check if <em>&amp;#x0394;</em> is a valid input to Hallgren&#8217;s algorithm,
 i.e. is the discriminant of a real quadratic number field.
 (Cf. <a href="http://en.wikipedia.org/wiki/Fundamental_discriminant">http://en.wikipedia.org/wiki/Fundamental_discriminant</a>)
</p></div></div><div class="top"><p class="src"><a name="v:all_small_ds" class="def">all_small_ds</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> int =&gt; &#91;int&#93;<a href="src/Algorithms/CL/Types.html#line-86" class="link">Source</a></p><div class="doc"><p>The (infinite, lazy) list of all valid inputs <em>d</em>, 
 i.e. of all square-free integers above 2.
</p></div></div><div class="top"><p class="src"><a name="v:all_bigDs" class="def">all_bigDs</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> int =&gt; &#91;int&#93;<a href="src/Algorithms/CL/Types.html#line-91" class="link">Source</a></p><div class="doc"><p>The (infinite, lazy) list of all valid inputs &#916;, 
 i.e. of all discriminants of real quadratic number fields.
</p></div></div><h2 id="g:4">Field elements
</h2><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:AlgNumGen" class="def">AlgNumGen</a> a <a href="src/Algorithms/CL/Types.html#line-113" class="link">Source</a></p><div class="doc"><p>A data type describing a number in the algebraic number field K = &#8474;&#91;&#8730;&#916;&#93;: <code><code><a href="Algorithms-CL-Types.html#t:AlgNum">AlgNum</a></code> <em>a</em> <em>b</em> &#916;</code> represents <em>a</em> + <em>b</em>&#8730;&#916;.
</p><p>In general, the type of coefficients may be any type of (classical or quantum)
 numbers, i.e. an instance of the <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a></code> or <code><a href="QuipperLib-Arith.html#t:QNum">QNum</a></code> class.
 Given this, the algebraic numbers with a fixed &#916; will in turn be an instance
 of <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a></code> or <code><a href="QuipperLib-Arith.html#t:QNum">QNum</a></code>.
</p><p>A value <code><em>a</em> :: <em>x</em></code> may also be used as an <code><code><a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a></code> <em>x</em></code>,
 with no &#916; specified, to represent simply <em>a</em> + 0&#8730;&#916;; this can be considered polymorphic
 over all possible values of &#916;. 
</p><p>This is similar to the use of <code><a href="QuipperLib-Arith.html#t:IntM">IntM</a></code>s or <code><a href="QuipperLib-FPReal.html#t:FPReal">FPReal</a></code>s of indeterminate size, although
 unlike for them, we do not restrict this to the classical case.  However, the
 question of whether an <code>AlgNumQ</code> has specified &#8730;&#916; is (like e.g. the length of
 a list) is a parameter property, known at circuit generation time, not a purely 
 quantum property.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:AlgNum" class="def">AlgNum</a> a a <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:AlgNum_indet" class="def">AlgNum_indet</a> a</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:AlgNumGen" class="caption collapser" onclick="toggleSection('i:AlgNumGen')">Instances</p><div id="section.i:AlgNumGen" class="show"><table><tr><td class="src">(<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> a, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a> a) =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> (<a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> a, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Fractional">Fractional</a> a) =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Fractional">Fractional</a> (<a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> a, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a> a) =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a> (<a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> a, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a> a) =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> (<a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Real">Real</a> a =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Real">Real</a> (<a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:RealFrac">RealFrac</a> a =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:RealFrac">RealFrac</a> (<a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Show.html#t:Show">Show</a> a =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Show.html#t:Show">Show</a> (<a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:AlgNum" class="def">AlgNum</a> = <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> <a href="Algorithms-CL-Types.html#t:CLRational">CLRational</a><a href="src/Algorithms/CL/Types.html#line-116" class="link">Source</a></p><div class="doc"><p>The specific instance of <code><a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a></code> used for classical (parameter) computation.
</p></div></div><div class="top"><p class="src"><a name="v:fst_AlgNum" class="def">fst_AlgNum</a> ::  <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a -&gt; a<a href="src/Algorithms/CL/Types.html#line-119" class="link">Source</a></p><div class="doc"><p>Extract the first co-ordinate of an <code><a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a></code>
</p></div></div><div class="top"><p class="src"><a name="v:snd_AlgNum" class="def">snd_AlgNum</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a> a =&gt; <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a -&gt; a<a href="src/Algorithms/CL/Types.html#line-124" class="link">Source</a></p><div class="doc"><p>Extract the second co-ordinate of an <code><a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a></code>
</p></div></div><div class="top"><p class="src"><a name="v:pretty_show_AlgNum" class="def">pretty_show_AlgNum</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Show.html#t:Show">Show</a> a =&gt; <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a><a href="src/Algorithms/CL/Types.html#line-137" class="link">Source</a></p><div class="doc"><p>Print a <code>Number</code> in human-readable (though not Haskell-readable) format, as e.g. 
</p></div></div><div class="top"><p class="src"><a name="v:floating_of_AlgNum" class="def">floating_of_AlgNum</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Real">Real</a> a, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a> b) =&gt; <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a -&gt; b<a href="src/Algorithms/CL/Types.html#line-142" class="link">Source</a></p><div class="doc"><p>Realize an algebraic number as a real number (of any <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Floating">Floating</a></code> type).
</p></div></div><div class="top"><p class="src"><a name="v:number_promote" class="def">number_promote</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a> a =&gt; <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a -&gt; <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> b -&gt; <a href="Libraries-Auxiliary.html#t:ErrMsg">ErrMsg</a> -&gt; <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a<a href="src/Algorithms/CL/Types.html#line-147" class="link">Source</a></p><div class="doc"><p>Coerce one algebraic number into the field of a second, if possible.  If not possible (i.e. if their &#916;&#8217;s mismatch), throw an error.
</p></div></div><div class="top"><p class="src"><a name="v:conjugate" class="def">conjugate</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a> a =&gt; <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a -&gt; <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a<a href="src/Algorithms/CL/Types.html#line-216" class="link">Source</a></p><div class="doc"><p>The algebraic conjugate: sends <em>a</em> + <em>b</em> &#8730;&#916; to <em>a</em> - <em>b</em> &#8730;&#916;.
</p></div></div><div class="top"><p class="src"><a name="v:is_alg_int" class="def">is_alg_int</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> a, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:RealFrac">RealFrac</a> a) =&gt; <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/Algorithms/CL/Types.html#line-224" class="link">Source</a></p><div class="doc"><p>Test whether an algebraic number is an algebraic integer.
</p><p>(A number is an algebraic integer iff it can be written in the form <em>m</em> + <em>n</em>(&#916; + &#8730;&#916;)/2, where <em>m</em>, <em>n</em> are integers.
 See &#91;Jozsa 2003&#93;, proof of Prop. 14.)
</p></div></div><div class="top"><p class="src"><a name="v:is_unit" class="def">is_unit</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Ord.html#t:Ord">Ord</a> a, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:RealFrac">RealFrac</a> a) =&gt; <a href="Algorithms-CL-Types.html#t:AlgNumGen">AlgNumGen</a> a -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/Algorithms/CL/Types.html#line-233" class="link">Source</a></p><div class="doc"><p>Test whether an algebraic number is a unit of the ring of algebraic integers.
</p></div></div><div class="top"><p class="src"><a name="v:omega_of_bigD" class="def">omega_of_bigD</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Algorithms-CL-Types.html#t:AlgNum">AlgNum</a><a href="src/Algorithms/CL/Types.html#line-237" class="link">Source</a></p><div class="doc"><p>The number &#969; associated to the field <em>K</em>.
</p></div></div><h1 id="g:5">Ideals
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:IdealX" class="def">IdealX</a> x <a href="src/Algorithms/CL/Types.html#line-263" class="link">Source</a></p><div class="doc"><p>Data specifying an ideal in an algebraic number field.  An ideal is described by a tuple
 (&#916;,<em>m</em>,<em>l</em>,<em>a</em>,<em>b</em>), representing the ideal
</p><p><em>m</em>/<em>l</em> (<em>aZ</em> + (<em>b</em>+&#8730;&#916;)/2 <em>Z</em>),
</p><p>where moreover we assume and ensure always that the ideal is in <em>standard form</em> (&#91;Jozsa 2003&#93;, p.11, Prop. 16).  Specifically,
</p><ul><li> <em>a</em>,<em>k</em>,<em>l</em> &gt; 0;
</li><li> 4<em>a</em> | <em>b</em><sup>2</sup> &#8211; &#916;; 
</li><li> <em>b</em> = &#964;(<em>a</em>,<em>b</em>);
</li><li> gcd(<em>k</em>,<em>l</em>) = 1
</li></ul><p>In particular, this gives us bounds on the size of <em>a</em> and <em>b</em>, 
 and hence tells us the sizes needed for these registers (see <code><a href="Algorithms-CL-Types.html#v:length_for_ab">length_for_ab</a></code> below).
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Ideal" class="def">Ideal</a> <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> (<a href="QuipperLib-Arith.html#t:XInt">XInt</a> x) (<a href="QuipperLib-Arith.html#t:XInt">XInt</a> x) (<a href="QuipperLib-Arith.html#t:XInt">XInt</a> x) (<a href="QuipperLib-Arith.html#t:XInt">XInt</a> x)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:IdealX" class="caption collapser" onclick="toggleSection('i:IdealX')">Instances</p><div id="section.i:IdealX" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> <a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Show.html#t:Show">Show</a> <a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Typeable-Internal.html#t:Typeable1">Typeable1</a> <a href="Algorithms-CL-Types.html#t:IdealX">IdealX</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-Labels.html#t:Labelable">Labelable</a> <a href="Algorithms-CL-Types.html#t:IdealQ">IdealQ</a> (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> x =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> (<a href="Algorithms-CL-Types.html#t:IdealX">IdealX</a> x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Show.html#t:Show">Show</a> x =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Show.html#t:Show">Show</a> (<a href="Algorithms-CL-Types.html#t:IdealX">IdealX</a> x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-QData.html#t:QCLeaf">QCLeaf</a> x =&gt; <a href="Quipper-QData.html#t:QCData">QCData</a> (<a href="Algorithms-CL-Types.html#t:IdealX">IdealX</a> x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-QData.html#t:QCLeaf">QCLeaf</a> x =&gt; <a href="Quipper-Labels.html#t:Labelable">Labelable</a> (<a href="Algorithms-CL-Types.html#t:IdealX">IdealX</a> x) <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Ideal" class="def">Ideal</a> = <a href="Algorithms-CL-Types.html#t:IdealX">IdealX</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/Algorithms/CL/Types.html#line-267" class="link">Source</a></p><div class="doc"><p>Classical parameter specifying an ideal.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:IdealQ" class="def">IdealQ</a> = <a href="Algorithms-CL-Types.html#t:IdealX">IdealX</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a><a href="src/Algorithms/CL/Types.html#line-270" class="link">Source</a></p><div class="doc"><p>Quantum circuit-type counterpart of <code><a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a></code>.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:IdealC" class="def">IdealC</a> = <a href="Algorithms-CL-Types.html#t:IdealX">IdealX</a> <a href="Quipper-Monad.html#t:Bit">Bit</a><a href="src/Algorithms/CL/Types.html#line-273" class="link">Source</a></p><div class="doc"><p>Classical circuit-type counterpart of <code><a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a></code>.
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:IdealRedX" class="def">IdealRedX</a> x <a href="src/Algorithms/CL/Types.html#line-348" class="link">Source</a></p><div class="doc"><p>Data specifying a reduced ideal, by a tuple (&#916;,<em>a</em>,<em>b</em>); this 
 corresponds to the ideal specified by (&#916;,1,<em>a</em>,<em>a</em>,<em>b</em>), i.e.,
 <em>Z</em> + (<em>b</em>+&#8730;&#916;)/2<em>a</em> <em>Z</em>.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:IdealRed" class="def">IdealRed</a> <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> (<a href="QuipperLib-Arith.html#t:XInt">XInt</a> x) (<a href="QuipperLib-Arith.html#t:XInt">XInt</a> x)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:IdealRedX" class="caption collapser" onclick="toggleSection('i:IdealRedX')">Instances</p><div id="section.i:IdealRedX" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Eq.html#t:Eq">Eq</a> <a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Show.html#t:Show">Show</a> <a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Typeable-Internal.html#t:Typeable1">Typeable1</a> <a href="Algorithms-CL-Types.html#t:IdealRedX">IdealRedX</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Show.html#t:Show">Show</a> x =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Text-Show.html#t:Show">Show</a> (<a href="Algorithms-CL-Types.html#t:IdealRedX">IdealRedX</a> x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-QData.html#t:QCLeaf">QCLeaf</a> x =&gt; <a href="Quipper-QData.html#t:QCData">QCData</a> (<a href="Algorithms-CL-Types.html#t:IdealRedX">IdealRedX</a> x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-QData.html#t:QCLeaf">QCLeaf</a> x =&gt; <a href="Quipper-Labels.html#t:Labelable">Labelable</a> (<a href="Algorithms-CL-Types.html#t:IdealRedX">IdealRedX</a> x) <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-QData.html#t:QCLeaf">QCLeaf</a> x =&gt; <a href="Quipper-Labels.html#t:Labelable">Labelable</a> (<a href="Algorithms-CL-Types.html#t:IdealRedX">IdealRedX</a> x) (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-String.html#t:String">String</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:IdealRed" class="def">IdealRed</a> = <a href="Algorithms-CL-Types.html#t:IdealRedX">IdealRedX</a> <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/Algorithms/CL/Types.html#line-352" class="link">Source</a></p><div class="doc"><p>Classical parameter specifying a reduced ideal.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:IdealRedQ" class="def">IdealRedQ</a> = <a href="Algorithms-CL-Types.html#t:IdealRedX">IdealRedX</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a><a href="src/Algorithms/CL/Types.html#line-355" class="link">Source</a></p><div class="doc"><p>Quantum circuit-type counterpart of <code><a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a></code>.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:IdealRedC" class="def">IdealRedC</a> = <a href="Algorithms-CL-Types.html#t:IdealRedX">IdealRedX</a> <a href="Quipper-Monad.html#t:Bit">Bit</a><a href="src/Algorithms/CL/Types.html#line-358" class="link">Source</a></p><div class="doc"><p>Classical circuit-type counterpart of <code><a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a></code>.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:IdDist" class="def">IdDist</a> = (<a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a>, <a href="QuipperLib-FPReal.html#t:FPReal">FPReal</a>)<a href="src/Algorithms/CL/Types.html#line-421" class="link">Source</a></p><div class="doc"><p>An ideal <em>I</em>, together with a distance &#948; for it &#8212; that is, <em>some</em> representative, mod <em>R</em>, for &#948;(<em>I</em>) as defined on <em>G</em> p.4.  
 Most functions described as acting on ideals need in fact to be seen as a pair of an ideal and a distance for it. 
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:IdDistQ" class="def">IdDistQ</a> = (<a href="Algorithms-CL-Types.html#t:IdealQ">IdealQ</a>, <a href="QuipperLib-FPReal.html#t:FPRealQ">FPRealQ</a>)<a href="src/Algorithms/CL/Types.html#line-424" class="link">Source</a></p><div class="doc"><p>Quantum analogue of <code><a href="Algorithms-CL-Types.html#t:IdDist">IdDist</a></code>. 
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:IdRedDist" class="def">IdRedDist</a> = (<a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a>, <a href="QuipperLib-FPReal.html#t:FPReal">FPReal</a>)<a href="src/Algorithms/CL/Types.html#line-427" class="link">Source</a></p><div class="doc"><p>A reduced ideal <em>I</em>, together with a distance &#948; for it.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:IdRedDistQ" class="def">IdRedDistQ</a> = (<a href="Algorithms-CL-Types.html#t:IdealRedQ">IdealRedQ</a>, <a href="QuipperLib-FPReal.html#t:FPRealQ">FPRealQ</a>)<a href="src/Algorithms/CL/Types.html#line-430" class="link">Source</a></p><div class="doc"><p>Quantum analogue of <code><a href="Algorithms-CL-Types.html#t:IdRedDist">IdRedDist</a></code>. 
</p></div></div><h2 id="g:6">Trivial access functions
</h2><div class="top"><p class="src"><a name="v:d_of_Ideal" class="def">d_of_Ideal</a> ::  <a href="Algorithms-CL-Types.html#t:IdealX">IdealX</a> a -&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a><a href="src/Algorithms/CL/Types.html#line-436" class="link">Source</a></p><div class="doc"><p>Extract the <em>d</em> component from an <code><a href="Algorithms-CL-Types.html#t:IdealQ">IdealQ</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:d_of_IdealRed" class="def">d_of_IdealRed</a> ::  <a href="Algorithms-CL-Types.html#t:IdealRedX">IdealRedX</a> a -&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a><a href="src/Algorithms/CL/Types.html#line-440" class="link">Source</a></p><div class="doc"><p>Extract the <em>d</em> component from an <code><a href="Algorithms-CL-Types.html#t:IdealRedQ">IdealRedQ</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:bigD_of_Ideal" class="def">bigD_of_Ideal</a> ::  <a href="Algorithms-CL-Types.html#t:IdealX">IdealX</a> a -&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a><a href="src/Algorithms/CL/Types.html#line-444" class="link">Source</a></p><div class="doc"><p>Extract &#916; from an <code><a href="Algorithms-CL-Types.html#t:IdealQ">IdealQ</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:bigD_of_IdealRed" class="def">bigD_of_IdealRed</a> ::  <a href="Algorithms-CL-Types.html#t:IdealRedX">IdealRedX</a> a -&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a><a href="src/Algorithms/CL/Types.html#line-448" class="link">Source</a></p><div class="doc"><p>Extract &#916; from an <code><a href="Algorithms-CL-Types.html#t:IdealRedQ">IdealRedQ</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:delta" class="def">delta</a> :: <a href="Algorithms-CL-Types.html#t:IdDist">IdDist</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a><a href="src/Algorithms/CL/Types.html#line-452" class="link">Source</a></p><div class="doc"><p>Extract the delta part from an ideal/distance pair.
</p></div></div><h2 id="g:7">Assertions, coercions
</h2><div class="doc"><p>Elements of the types <code><a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a></code>, <code><a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a></code>, etc are assumed to satisfy certain extra conditions.  
 This section includes functions for checking that these conditions are satisfied, and for safely 
 coercing between these types. 
</p></div><div class="top"><p class="src"><a name="v:tau" class="def">tau</a> :: (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> int, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> int') =&gt; int' -&gt; int -&gt; int -&gt; int<a href="src/Algorithms/CL/Types.html#line-465" class="link">Source</a></p><div class="doc"><p><code><code><a href="Algorithms-CL-Types.html#v:tau">tau</a></code> &#916; <em>b</em> <em>a</em></code>: the function &#964;(<em>b</em>,<em>a</em>).  Gives the representative for <em>b</em> mod <em>2a</em>, in a range dependent on <em>a</em> and &#8730;&#916;.  
</p><p>(This doesn't quite belong here, but is included as a prerequisite of the assertions).
</p></div></div><div class="top"><p class="src"><a name="v:is_standard" class="def">is_standard</a> :: <a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/Algorithms/CL/Types.html#line-472" class="link">Source</a></p><div class="doc"><p>Return <code><a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#v:True">True</a></code> if the given ideal is in standard form.  (Functions should <em>always</em> keep ideals in standard form).
</p></div></div><div class="top"><p class="src"><a name="v:is_reduced" class="def">is_reduced</a> :: <a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/Algorithms/CL/Types.html#line-479" class="link">Source</a></p><div class="doc"><p>Test whether an <code><a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a></code> is reduced.  (An ideal &lt;<em>m</em>,<em>l</em>,<em>a</em>,<em>b</em>&gt; is reduced iff <em>m</em> = 1, <em>l</em> = <em>a</em>, <em>b</em> &#8805; 0 and <em>b</em> + &#8730;&#916; &gt; 2<em>a</em> (&#91;Jozsa 2003&#93;, Prop. 20)). 
</p></div></div><div class="top"><p class="src"><a name="v:is_really_reduced" class="def">is_really_reduced</a> :: <a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a><a href="src/Algorithms/CL/Types.html#line-484" class="link">Source</a></p><div class="doc"><p>Test whether an <code><a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a></code> is really reduced.  (An ideal &lt;1,<em>a</em>,<em>a</em>,<em>b</em>&gt; is reduced iff <em>b</em> &#8805; 0 and <em>b</em> + &#8730;&#916; &gt; 2<em>a</em> (&#91;Jozsa 2003&#93;, Prop. 20)). 
</p></div></div><div class="top"><p class="src"><a name="v:forget_reduced" class="def">forget_reduced</a> :: <a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a> -&gt; <a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a><a href="src/Algorithms/CL/Types.html#line-489" class="link">Source</a></p><div class="doc"><p>Coerce an <code><a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a></code> to an <code><a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:to_reduced" class="def">to_reduced</a> :: <a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a> -&gt; <a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a><a href="src/Algorithms/CL/Types.html#line-493" class="link">Source</a></p><div class="doc"><p>Coerce an <code><a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a></code> to an <code><a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a></code>, if it is reduced, or throw an error otherwise.  Cf. &#91;Jozsa 2003&#93;, Prop. 20.
</p></div></div><div class="top"><p class="src"><a name="v:assert_reduced" class="def">assert_reduced</a> ::  <a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a> -&gt; a -&gt; a<a href="src/Algorithms/CL/Types.html#line-499" class="link">Source</a></p><div class="doc"><p>Throw an error if an <code><a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a></code> is not reduced; otherwise, the identity function.
</p></div></div><div class="top"><p class="src"><a name="v:assert_really_reduced" class="def">assert_really_reduced</a> ::  <a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a> -&gt; a -&gt; a<a href="src/Algorithms/CL/Types.html#line-504" class="link">Source</a></p><div class="doc"><p>Throw an error if an <code><a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a></code> is not really reduced; otherwise, the identity function.
</p></div></div><div class="top"><p class="src"><a name="v:q_tau" class="def">q_tau</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>, <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>)<a href="src/Algorithms/CL/Types.html#line-509" class="link">Source</a></p><div class="doc"><p>Quantum analogue of <code><a href="Algorithms-CL-Types.html#v:tau">tau</a></code>.  <code><code><a href="Algorithms-CL-Types.html#v:q_tau">q_tau</a></code> &#916; <em>qb</em> <em>qa</em></code>: compute the representative for <em>qb</em> mod 2<em>qa</em>, in a range dependent on <em>qa</em> and &#8730;&#916;.
</p></div></div><div class="top"><p class="src"><a name="v:q_is_reduced" class="def">q_is_reduced</a> :: <a href="Algorithms-CL-Types.html#t:IdealQ">IdealQ</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="Algorithms-CL-Types.html#t:IdealQ">IdealQ</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)<a href="src/Algorithms/CL/Types.html#line-525" class="link">Source</a></p><div class="doc"><p>Test whether a given <code><a href="Algorithms-CL-Types.html#t:IdealQ">IdealQ</a></code> is reduced.  &lt;<em>m</em>,<em>l</em>,<em>a</em>,<em>b</em>&gt; is reduced iff <em>m</em> = 1, <em>l</em> = <em>a</em>, <em>b</em> &#8805; 0 and <em>b</em> + &#8730;&#916; &gt; 2<em>a</em> (&#91;Jozsa 2003&#93;, Prop. 20).  
</p></div></div><div class="top"><p class="src"><a name="v:q_is_really_reduced" class="def">q_is_really_reduced</a> :: <a href="Algorithms-CL-Types.html#t:IdealRedQ">IdealRedQ</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="Algorithms-CL-Types.html#t:IdealRedQ">IdealRedQ</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>)<a href="src/Algorithms/CL/Types.html#line-544" class="link">Source</a></p><div class="doc"><p>Test whether a given <code><a href="Algorithms-CL-Types.html#t:IdealQ">IdealQ</a></code> is really reduced (as it should always be, if code is written correctly).  An ideal &lt;1,<em>a</em>,<em>a</em>,<em>b</em>&gt; is reduced iff <em>b</em> &#8805; 0 and <em>b</em> + &#8730;&#916; &gt; 2<em>a</em> (&#91;Jozsa 2003&#93;, Prop. 20). 
</p></div></div><div class="top"><p class="src"><a name="v:q_forget_reduced" class="def">q_forget_reduced</a> :: <a href="Algorithms-CL-Types.html#t:IdealRedQ">IdealRedQ</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Algorithms-CL-Types.html#t:IdealQ">IdealQ</a><a href="src/Algorithms/CL/Types.html#line-560" class="link">Source</a></p><div class="doc"><p>Coerce an <code><a href="Algorithms-CL-Types.html#t:IdealRedQ">IdealRedQ</a></code> to an <code><a href="Algorithms-CL-Types.html#t:IdealQ">IdealQ</a></code>, initializing the extra components appropriately.
</p></div></div><div class="top"><p class="src"><a name="v:q_assert_reduced" class="def">q_assert_reduced</a> :: <a href="Algorithms-CL-Types.html#t:IdealQ">IdealQ</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Algorithms-CL-Types.html#t:IdealRedQ">IdealRedQ</a><a href="src/Algorithms/CL/Types.html#line-570" class="link">Source</a></p><div class="doc"><p>Coerce an <code><a href="Algorithms-CL-Types.html#t:IdealQ">IdealQ</a></code> to an <code><a href="Algorithms-CL-Types.html#t:IdealRedQ">IdealRedQ</a></code>, assertively terminating the extra components 
 (and hence throwing an error at quantum runtime if the input is not reduced).
</p></div></div><div class="top"><p class="src"><a name="v:q_assert_really_reduced" class="def">q_assert_really_reduced</a> :: <a href="Algorithms-CL-Types.html#t:IdealRedQ">IdealRedQ</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Algorithms-CL-Types.html#t:IdealRedQ">IdealRedQ</a><a href="src/Algorithms/CL/Types.html#line-578" class="link">Source</a></p><div class="doc"><p>Throw a (quantum-runtime) error if an <code><a href="Algorithms-CL-Types.html#t:IdealRedQ">IdealRedQ</a></code> is not really reduced; otherwise, do nothing.
</p><p>Compare <code><a href="Algorithms-CL-Types.html#v:assert_reduced">assert_reduced</a></code>, <code><a href="Algorithms-CL-Types.html#v:q_is_really_reduced">q_is_really_reduced</a></code> in <a href="Algorithms-CL-RegulatorQuantum.html">Algorithms.CL.RegulatorQuantum</a>, and &#91;Jozsa 2003&#93; Prop. 20.
</p></div></div><h2 id="g:8">Bounds on coefficient sizes
</h2><div class="doc"><p>Given &#916;, how much space should be allocated for the coefficients of ideals?  Most of these bounds are currently missing or uncertain, as documented below.  Note these bounds are intended to be sufficient for the calculations occurring in this algorithm, <em>not</em> for representing arbitrary ideals.
</p></div><div class="top"><p class="src"><a name="v:length_for_ab" class="def">length_for_ab</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a><a href="src/Algorithms/CL/Types.html#line-592" class="link">Source</a></p><div class="doc"><p>Given &#916;, return the size of integers to be used for the coefficients <em>a</em>, <em>b</em> of reduced ideals.
</p><p>Note: can we bound this more carefully?  In reduced ideals, we always have 0 &#8804; <em>a</em>,<em>b</em> &#8804; &#8730;&#916; (see notes on <code><a href="Algorithms-CL-Types.html#v:is_standard">is_standard</a></code>, <code><a href="Algorithms-CL-Types.html#v:is_reduced">is_reduced</a></code>), and the outputs of &#961;, &#961;<sup>&#8211;1</sup> and dot-products of reduced ideals always keep |<em>a</em>| &#8804; &#916;.  However, intermediate calculations may involve larger values, so we allocate a little more space.  For now, this padding is a seat-of-the-pants estimate.  
</p></div></div><div class="top"><p class="src"><a name="v:length_for_ml" class="def">length_for_ml</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a><a href="src/Algorithms/CL/Types.html#line-598" class="link">Source</a></p><div class="doc"><p>Given &#916;, return the size of integers to be used for the coefficients <em>m</em>, <em>l</em> of general ideals.
</p><p>TODO: bound this!  Neither Hallgren nor &#91;Jozsa 2003&#93; discusses bounds on the values of <em>m</em> and <em>l</em> that will appear, and we do not yet have a bound.  For now we use the same length as for <em>a</em> and <em>b</em>, for convenience; this should be considered a dummy bound, quite possibly not sufficient in general.
</p></div></div><div class="top"><p class="src"><a name="v:n_of_bigD" class="def">n_of_bigD</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Integral">Integral</a> int =&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; int<a href="src/Algorithms/CL/Types.html#line-607" class="link">Source</a></p><div class="doc"><p>Given &#916;, return the precision <em>n</em> = log<sub>2</sub><em>N</em> to be used for
 discretizing the quasi-periodic function <em>f</em> to <em>f</em><sub><em>N</em></sub>.
</p><p>(&#8220;Precision&#8221; here means the number of binary digits after the point).
</p><p>Taken to ensure 1/<em>N</em> &lt; 3/(32 &#916; log &#916;).  (Cf. &#91;Jozsa 2003&#93;, Prop. 36 (iii).)
</p></div></div><div class="top"><p class="src"><a name="v:precision_for_fN" class="def">precision_for_fN</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a><a href="src/Algorithms/CL/Types.html#line-615" class="link">Source</a></p><div class="doc"><p>Given &#916;, <em>n</em>, <em>l</em> (as for <code>fN</code>, <code>q_fN</code>), return the precision required
 for intermediate distance calculations during the computation of <em>f</em><sub><em>N</em></sub>.
</p><p>TODO: bound this more carefully.  &#91;Jozsa 2003&#93; asks for the final output to be precision <em>n</em>, but does not discuss intermediate precision, and we have not yet got a confident answer.  For now, just a back-of-the-envelope estimate, which should be sufficient and <em>O</em>(correct), but is almost certainly rather larger than necessary.
</p></div></div><div class="top"><p class="src"><a name="v:fix_sizes_Ideal" class="def">fix_sizes_Ideal</a> :: <a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a> -&gt; <a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a><a href="src/Algorithms/CL/Types.html#line-619" class="link">Source</a></p><div class="doc"><p>Set the <code><a href="QuipperLib-Arith.html#t:IntM">IntM</a></code> coefficients of an <code><a href="Algorithms-CL-Types.html#t:Ideal">Ideal</a></code> to the standard lengths, if they are not already fixed incompatibly.  The standard lengths are determined by <code><a href="Algorithms-CL-Types.html#v:length_for_ml">length_for_ml</a></code>, <code><a href="Algorithms-CL-Types.html#v:length_for_ab">length_for_ab</a></code>.   (Compare <code><a href="QuipperLib-Arith.html#v:intm_promote">intm_promote</a></code>, etc.)
</p></div></div><div class="top"><p class="src"><a name="v:fix_sizes_IdealRed" class="def">fix_sizes_IdealRed</a> :: <a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a> -&gt; <a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a><a href="src/Algorithms/CL/Types.html#line-626" class="link">Source</a></p><div class="doc"><p>Set the <code><a href="QuipperLib-Arith.html#t:IntM">IntM</a></code> coefficients of an <code><a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a></code> to the standard lengths, if they are not already fixed incompatibly.  The standard lengths are determined by <code><a href="Algorithms-CL-Types.html#v:length_for_ml">length_for_ml</a></code>, <code><a href="Algorithms-CL-Types.html#v:length_for_ab">length_for_ab</a></code>.   (Compare <code><a href="QuipperLib-Arith.html#v:intm_promote">intm_promote</a></code>, etc.)
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>
