<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Quipper</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Quipper.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Quipper.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Quipper</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">The Circ monad  
</a></li><li><a href="#g:2">Basic types
</a></li><li><a href="#g:3">Basic gates
</a><ul><li><a href="#g:4">Reversible gates in functional style
</a></li><li><a href="#g:5">Reversible gates in imperative style 
</a></li><li><a href="#g:6">Gates for state preparation and termination
</a></li><li><a href="#g:7">Gates for classical circuits
</a></li><li><a href="#g:8">User-defined gates
</a></li><li><a href="#g:9">Dynamic lifting
</a></li></ul></li><li><a href="#g:10">Other circuit-building functions
</a></li><li><a href="#g:11">Notation for controls
</a></li><li><a href="#g:12">Signed items
</a></li><li><a href="#g:13">Comments and labelling
</a></li><li><a href="#g:14">Hierarchical circuits
</a></li><li><a href="#g:15">Block structure
</a><ul><li><a href="#g:16">Ancillas
</a></li><li><a href="#g:17">Automatic uncomputing
</a></li><li><a href="#g:18">Controls
</a></li><li><a href="#g:19">Loops
</a></li></ul></li><li><a href="#g:20">Operations on circuits
</a><ul><li><a href="#g:21">Reversing
</a></li><li><a href="#g:22">Printing
</a></li><li><a href="#g:23">Classical circuits  
</a></li><li><a href="#g:24">Ancilla uncomputation
</a></li></ul></li><li><a href="#g:25">Circuit transformers
</a><ul><li><a href="#g:26">User-definable transformers
</a></li><li><a href="#g:27">Pre-defined transformers
</a></li><li><a href="#g:28">An example transformer
</a></li><li><a href="#g:29">Applying transformers to circuits
</a></li><li><a href="#g:30">Auxiliary type definitions
</a></li></ul></li><li><a href="#g:31">Automatic circuit generation from classical code
</a></li><li><a href="#g:32">Extended quantum data types
</a><ul><li><a href="#g:33">Homogeneous quantum data types
</a></li><li><a href="#g:34">Heterogeneous quantum data types
</a></li><li><a href="#g:35">Shape-related operations
</a></li><li><a href="#g:36">Quantum type classes
</a></li></ul></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This is the main export module for Quipper, collecting everything
 that Quipper applications need. This is Quipper's &quot;public&quot;
 interface.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span>  <a href="#t:Circ">Circ</a> a</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Qubit">Qubit</a> </li><li class="src short"><span class="keyword">data</span>  <a href="#t:Bit">Bit</a> </li><li class="src short"><span class="keyword">type</span> <a href="#t:Qulist">Qulist</a> = &#91;<a href="Quipper.html#t:Qubit">Qubit</a>&#93;</li><li class="src short"><span class="keyword">type</span> <a href="#t:Bitlist">Bitlist</a> = &#91;<a href="Quipper.html#t:Bit">Bit</a>&#93;</li><li class="src short"><span class="keyword">type</span> <a href="#t:Timestep">Timestep</a> = <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></li><li class="src short"><a href="#v:qnot">qnot</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:hadamard">hadamard</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:gate_H">gate_H</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:gate_X">gate_X</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:gate_Y">gate_Y</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:gate_Z">gate_Z</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:gate_S">gate_S</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:gate_S_inv">gate_S_inv</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:gate_T">gate_T</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:gate_T_inv">gate_T_inv</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:gate_E">gate_E</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:gate_E_inv">gate_E_inv</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:gate_omega">gate_omega</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:gate_V">gate_V</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:gate_V_inv">gate_V_inv</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:expZt">expZt</a> :: <a href="Quipper.html#t:Timestep">Timestep</a> -&gt; <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:rGate">rGate</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:gate_W">gate_W</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> (<a href="Quipper.html#t:Qubit">Qubit</a>, <a href="Quipper.html#t:Qubit">Qubit</a>)</li><li class="src short"><a href="#v:gate_iX">gate_iX</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:global_phase">global_phase</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:global_phase_anchored">global_phase_anchored</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:qmultinot">qmultinot</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa</li><li class="src short"><a href="#v:cnot">cnot</a> :: <a href="Quipper.html#t:Bit">Bit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:swap">swap</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qc, qc)</li><li class="src short"><a href="#v:qnot_at">qnot_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:hadamard_at">hadamard_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:gate_H_at">gate_H_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:gate_X_at">gate_X_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:gate_Y_at">gate_Y_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:gate_Z_at">gate_Z_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:gate_S_at">gate_S_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:gate_S_inv_at">gate_S_inv_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:gate_T_at">gate_T_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:gate_T_inv_at">gate_T_inv_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:gate_E_at">gate_E_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:gate_E_inv_at">gate_E_inv_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:gate_omega_at">gate_omega_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:gate_V_at">gate_V_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:gate_V_inv_at">gate_V_inv_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:expZt_at">expZt_at</a> :: <a href="Quipper.html#t:Timestep">Timestep</a> -&gt; <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:rGate_at">rGate_at</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:gate_W_at">gate_W_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:gate_iX_at">gate_iX_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:qmultinot_at">qmultinot_at</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:cnot_at">cnot_at</a> :: <a href="Quipper.html#t:Bit">Bit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:swap_at">swap_at</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:qinit">qinit</a> :: <a href="Quipper.html#t:QShape">QShape</a> ba qa ca =&gt; ba -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa</li><li class="src short"><a href="#v:qterm">qterm</a> :: <a href="Quipper.html#t:QShape">QShape</a> ba qa ca =&gt; ba -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:qdiscard">qdiscard</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:cinit">cinit</a> :: <a href="Quipper.html#t:QShape">QShape</a> ba qa ca =&gt; ba -&gt; <a href="Quipper.html#t:Circ">Circ</a> ca</li><li class="src short"><a href="#v:cterm">cterm</a> :: <a href="Quipper.html#t:QShape">QShape</a> ba qa ca =&gt; ba -&gt; ca -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:cdiscard">cdiscard</a> :: <a href="Quipper.html#t:CData">CData</a> ca =&gt; ca -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:qc_init">qc_init</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; <a href="Quipper-QData.html#t:BType">BType</a> qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> qc</li><li class="src short"><a href="#v:qc_init_with_shape">qc_init_with_shape</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> qc</li><li class="src short"><a href="#v:qc_term">qc_term</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; <a href="Quipper-QData.html#t:BType">BType</a> qc -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:qc_discard">qc_discard</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:measure">measure</a> :: <a href="Quipper.html#t:QShape">QShape</a> ba qa ca =&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> ca</li><li class="src short"><a href="#v:prepare">prepare</a> :: <a href="Quipper.html#t:QShape">QShape</a> ba qa ca =&gt; ca -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa</li><li class="src short"><a href="#v:qc_measure">qc_measure</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper.html#t:Bit">Bit</a> <a href="Quipper.html#t:Bit">Bit</a> qc)</li><li class="src short"><a href="#v:qc_prepare">qc_prepare</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper.html#t:Qubit">Qubit</a> <a href="Quipper.html#t:Qubit">Qubit</a> qc)</li><li class="src short"><a href="#v:cgate_xor">cgate_xor</a> :: &#91;<a href="Quipper.html#t:Bit">Bit</a>&#93; -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:cgate_eq">cgate_eq</a> :: <a href="Quipper.html#t:Bit">Bit</a> -&gt; <a href="Quipper.html#t:Bit">Bit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:cgate_not">cgate_not</a> :: <a href="Quipper.html#t:Bit">Bit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:cgate_and">cgate_and</a> :: &#91;<a href="Quipper.html#t:Bit">Bit</a>&#93; -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:cgate_or">cgate_or</a> :: &#91;<a href="Quipper.html#t:Bit">Bit</a>&#93; -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:cgate_if">cgate_if</a> :: <a href="Quipper.html#t:CData">CData</a> ca =&gt; <a href="Quipper.html#t:Bit">Bit</a> -&gt; ca -&gt; ca -&gt; <a href="Quipper.html#t:Circ">Circ</a> ca</li><li class="src short"><a href="#v:circ_if">circ_if</a> :: <a href="Quipper.html#t:CData">CData</a> ca =&gt; <a href="Quipper.html#t:Bit">Bit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ca -&gt; <a href="Quipper.html#t:Circ">Circ</a> ca -&gt; <a href="Quipper.html#t:Circ">Circ</a> ca</li><li class="src short"><a href="#v:named_gate">named_gate</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa</li><li class="src short"><a href="#v:named_gate_at">named_gate_at</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:named_rotation">named_rotation</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; <a href="Quipper.html#t:Timestep">Timestep</a> -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa</li><li class="src short"><a href="#v:named_rotation_at">named_rotation_at</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; <a href="Quipper.html#t:Timestep">Timestep</a> -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:extended_named_gate">extended_named_gate</a> :: (<a href="Quipper.html#t:QData">QData</a> qa, <a href="Quipper.html#t:QData">QData</a> qb) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; qa -&gt; qb -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa</li><li class="src short"><a href="#v:extended_named_gate_at">extended_named_gate_at</a> :: (<a href="Quipper.html#t:QData">QData</a> qa, <a href="Quipper.html#t:QData">QData</a> qb) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; qa -&gt; qb -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:dynamic_lift">dynamic_lift</a> :: <a href="Quipper.html#t:QShape">QShape</a> ba qa ca =&gt; ca -&gt; <a href="Quipper.html#t:Circ">Circ</a> ba</li><li class="src short"><a href="#v:qinit_plusminus">qinit_plusminus</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:qinit_of_char">qinit_of_char</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Char.html#t:Char">Char</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:qinit_of_string">qinit_of_string</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> &#91;<a href="Quipper.html#t:Qubit">Qubit</a>&#93;</li><li class="src short"><a href="#v:map_hadamard">map_hadamard</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa</li><li class="src short"><a href="#v:map_hadamard_at">map_hadamard_at</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:controlled_not">controlled_not</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qc, qc)</li><li class="src short"><a href="#v:controlled_not_at">controlled_not_at</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:bool_controlled_not">bool_controlled_not</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> qc</li><li class="src short"><a href="#v:bool_controlled_not_at">bool_controlled_not_at</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:qc_copy">qc_copy</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> qc</li><li class="src short"><a href="#v:qc_uncopy">qc_uncopy</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:qc_copy_fun">qc_copy_fun</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qc, qc)</li><li class="src short"><a href="#v:qc_uncopy_fun">qc_uncopy_fun</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> qc</li><li class="src short"><a href="#v:mapUnary">mapUnary</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; (<a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a>) -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa</li><li class="src short"><a href="#v:mapBinary">mapBinary</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; (<a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> (<a href="Quipper.html#t:Qubit">Qubit</a>, <a href="Quipper.html#t:Qubit">Qubit</a>)) -&gt; qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qa, qa)</li><li class="src short"><a href="#v:mapBinary_c">mapBinary_c</a> :: <a href="Quipper.html#t:QShape">QShape</a> ba qa ca =&gt; (<a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Bit">Bit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> (<a href="Quipper.html#t:Qubit">Qubit</a>, <a href="Quipper.html#t:Bit">Bit</a>)) -&gt; qa -&gt; ca -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qa, ca)</li><li class="src short"><a href="#v:qc_mapBinary">qc_mapBinary</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; (<a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> (<a href="Quipper.html#t:Qubit">Qubit</a>, <a href="Quipper.html#t:Qubit">Qubit</a>)) -&gt; (<a href="Quipper.html#t:Bit">Bit</a> -&gt; <a href="Quipper.html#t:Bit">Bit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> (<a href="Quipper.html#t:Bit">Bit</a>, <a href="Quipper.html#t:Bit">Bit</a>)) -&gt; qc -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qc, qc)</li><li class="src short"><span class="keyword">class</span>  <a href="#t:ControlSource">ControlSource</a> a  <span class="keyword">where</span><ul class="subs"><li><a href="#v:to_control">to_control</a> :: a -&gt; <a href="Quipper.html#t:ControlList">ControlList</a></li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:ControlList">ControlList</a> </li><li class="src short"><a href="#v:.-38--38-.">(.&amp;&amp;.)</a> :: (<a href="Quipper.html#t:ControlSource">ControlSource</a> a, <a href="Quipper.html#t:ControlSource">ControlSource</a> b) =&gt; a -&gt; b -&gt; <a href="Quipper.html#t:ControlList">ControlList</a></li><li class="src short"><a href="#v:.-61--61-.">(.==.)</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qc -&gt; <a href="Quipper.html#t:ControlList">ControlList</a></li><li class="src short"><a href="#v:.-47--61-.">(./=.)</a> :: <a href="Quipper-QData.html#t:QCLeaf">QCLeaf</a> q =&gt; q -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Quipper.html#t:ControlList">ControlList</a></li><li class="src short"><a href="#v:controlled">controlled</a> :: <a href="Quipper.html#t:ControlSource">ControlSource</a> c =&gt; <a href="Quipper.html#t:Circ">Circ</a> a -&gt; c -&gt; <a href="Quipper.html#t:Circ">Circ</a> a</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Signed">Signed</a> a = <a href="#v:Signed">Signed</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:from_signed">from_signed</a> ::  <a href="Quipper.html#t:Signed">Signed</a> a -&gt; a</li><li class="src short"><a href="#v:get_sign">get_sign</a> ::  <a href="Quipper.html#t:Signed">Signed</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:comment">comment</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:label">label</a> :: <a href="Quipper.html#t:Labelable">Labelable</a> qa labels =&gt; qa -&gt; labels -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:comment_with_label">comment_with_label</a> :: <a href="Quipper.html#t:Labelable">Labelable</a> qa labels =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; qa -&gt; labels -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:without_comments">without_comments</a> ::  <a href="Quipper.html#t:Circ">Circ</a> a -&gt; <a href="Quipper.html#t:Circ">Circ</a> a</li><li class="src short"><span class="keyword">class</span>  <a href="#t:Labelable">Labelable</a> a s </li><li class="src short"><a href="#v:box">box</a> :: (<a href="Quipper.html#t:QCData">QCData</a> qa, <a href="Quipper.html#t:QCData">QCData</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qa_qb qa qb) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; qa_qb -&gt; qa_qb</li><li class="src short"><a href="#v:nbox">nbox</a> :: <a href="Quipper.html#t:QCData">QCData</a> qa =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; (qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa) -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa</li><li class="src short"><a href="#v:box_loopM">box_loopM</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integral">Integral</a> int, <a href="Quipper.html#t:QCData">QCData</a> qa) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; int -&gt; qa -&gt; (qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa) -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa</li><li class="src short"><a href="#v:loopM_boxed_if">loopM_boxed_if</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integral">Integral</a> int, <a href="Quipper.html#t:QCData">QCData</a> qa) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; int -&gt; qa -&gt; (qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa) -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa</li><li class="src short"><a href="#v:with_ancilla">with_ancilla</a> ::  (<a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> a) -&gt; <a href="Quipper.html#t:Circ">Circ</a> a</li><li class="src short"><a href="#v:with_ancilla_list">with_ancilla_list</a> ::  <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; (<a href="Quipper.html#t:Qulist">Qulist</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> a) -&gt; <a href="Quipper.html#t:Circ">Circ</a> a</li><li class="src short"><a href="#v:with_ancilla_init">with_ancilla_init</a> :: <a href="Quipper.html#t:QShape">QShape</a> a qa ca =&gt; a -&gt; (qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> b) -&gt; <a href="Quipper.html#t:Circ">Circ</a> b</li><li class="src short"><a href="#v:with_computed_fun">with_computed_fun</a> :: (<a href="Quipper.html#t:QCData">QCData</a> x, <a href="Quipper.html#t:QCData">QCData</a> y) =&gt; x -&gt; (x -&gt; <a href="Quipper.html#t:Circ">Circ</a> y) -&gt; (y -&gt; <a href="Quipper.html#t:Circ">Circ</a> (y, b)) -&gt; <a href="Quipper.html#t:Circ">Circ</a> (x, b)</li><li class="src short"><a href="#v:with_computed">with_computed</a> :: <a href="Quipper.html#t:QCData">QCData</a> x =&gt; <a href="Quipper.html#t:Circ">Circ</a> x -&gt; (x -&gt; <a href="Quipper.html#t:Circ">Circ</a> b) -&gt; <a href="Quipper.html#t:Circ">Circ</a> b</li><li class="src short"><a href="#v:with_basis_change">with_basis_change</a> ::  <a href="Quipper.html#t:Circ">Circ</a> () -&gt; <a href="Quipper.html#t:Circ">Circ</a> b -&gt; <a href="Quipper.html#t:Circ">Circ</a> b</li><li class="src short"><a href="#v:with_controls">with_controls</a> :: <a href="Quipper.html#t:ControlSource">ControlSource</a> c =&gt; c -&gt; <a href="Quipper.html#t:Circ">Circ</a> a -&gt; <a href="Quipper.html#t:Circ">Circ</a> a</li><li class="src short"><a href="#v:with_classical_control">with_classical_control</a> :: <a href="Quipper.html#t:QCData">QCData</a> qa =&gt; <a href="Quipper.html#t:Bit">Bit</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; qa -&gt; (qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa) -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa</li><li class="src short"><a href="#v:without_controls">without_controls</a> ::  <a href="Quipper.html#t:Circ">Circ</a> a -&gt; <a href="Quipper.html#t:Circ">Circ</a> a</li><li class="src short"><a href="#v:without_controls_if">without_controls_if</a> ::  <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> a -&gt; <a href="Quipper.html#t:Circ">Circ</a> a</li><li class="src short"><a href="#v:for">for</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; m ()) -&gt; m ()</li><li class="src short"><a href="#v:endfor">endfor</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; m ()</li><li class="src short"><a href="#v:foreach">foreach</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; &#91;a&#93; -&gt; (a -&gt; m b) -&gt; m ()</li><li class="src short"><a href="#v:loop">loop</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> int, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Num">Num</a> int) =&gt; int -&gt; t -&gt; (t -&gt; t) -&gt; t</li><li class="src short"><a href="#v:loop_with_index">loop_with_index</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> int, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Num">Num</a> int) =&gt; int -&gt; t -&gt; (int -&gt; t -&gt; t) -&gt; t</li><li class="src short"><a href="#v:loopM">loopM</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> int, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Num">Num</a> int, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m) =&gt; int -&gt; t -&gt; (t -&gt; m t) -&gt; m t</li><li class="src short"><a href="#v:loop_with_indexM">loop_with_indexM</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> int, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Num">Num</a> int, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m) =&gt; int -&gt; t -&gt; (int -&gt; t -&gt; m t) -&gt; m t</li><li class="src short"><a href="#v:reverse_generic">reverse_generic</a> :: (<a href="Quipper.html#t:QCData">QCData</a> x, <a href="Quipper.html#t:QCData">QCData</a> y, <a href="Libraries-Tuple.html#t:TupleOrUnary">TupleOrUnary</a> xt x, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> x_y x y, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> x_y_xt x (y -&gt; <a href="Quipper.html#t:Circ">Circ</a> xt)) =&gt; x_y -&gt; x_y_xt</li><li class="src short"><a href="#v:reverse_simple">reverse_simple</a> :: (<a href="Quipper-QData.html#t:QCData_Simple">QCData_Simple</a> x, <a href="Quipper.html#t:QCData">QCData</a> y, <a href="Libraries-Tuple.html#t:TupleOrUnary">TupleOrUnary</a> xt x, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> x_y x y) =&gt; x_y -&gt; y -&gt; <a href="Quipper.html#t:Circ">Circ</a> xt</li><li class="src short"><a href="#v:reverse_generic_endo">reverse_generic_endo</a> :: (<a href="Quipper.html#t:QCData">QCData</a> x, <a href="Libraries-Tuple.html#t:TupleOrUnary">TupleOrUnary</a> xt x, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> x_xt x xt) =&gt; x_xt -&gt; x_xt</li><li class="src short"><a href="#v:reverse_generic_imp">reverse_generic_imp</a> :: (<a href="Quipper.html#t:QCData">QCData</a> x, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> x__ x ()) =&gt; x__ -&gt; x__</li><li class="src short"><a href="#v:reverse_generic_curried">reverse_generic_curried</a> :: (<a href="Quipper.html#t:QCData">QCData</a> x, <a href="Quipper.html#t:QCData">QCData</a> y, <a href="Libraries-Tuple.html#t:TupleOrUnary">TupleOrUnary</a> xt x, <a href="Libraries-Tuple.html#t:Tuple">Tuple</a> yt y, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> x_yt x yt, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> y_xt y xt, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> x_y_xt x y_xt) =&gt; x_yt -&gt; x_y_xt</li><li class="src short"><a href="#v:reverse_simple_curried">reverse_simple_curried</a> :: (<a href="Quipper-QData.html#t:QCData_Simple">QCData_Simple</a> x, <a href="Quipper.html#t:QCData">QCData</a> y, <a href="Libraries-Tuple.html#t:TupleOrUnary">TupleOrUnary</a> xt x, <a href="Libraries-Tuple.html#t:Tuple">Tuple</a> yt y, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> x_yt x yt, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> y_xt y xt) =&gt; x_yt -&gt; y_xt</li><li class="src short"><a href="#v:reverse_endo_if">reverse_endo_if</a> :: (<a href="Quipper.html#t:QCData">QCData</a> x, <a href="Libraries-Tuple.html#t:TupleOrUnary">TupleOrUnary</a> xt x, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> x_xt x xt) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; x_xt -&gt; x_xt</li><li class="src short"><a href="#v:reverse_imp_if">reverse_imp_if</a> :: (<a href="Quipper.html#t:QCData">QCData</a> qa, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> fun qa ()) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; fun -&gt; fun</li><li class="src short"><span class="keyword">data</span>  <a href="#t:Format">Format</a> <ul class="subs"><li>= <a href="#v:EPS">EPS</a>  </li><li>| <a href="#v:PDF">PDF</a>  </li><li>| <a href="#v:PS">PS</a>  </li><li>| <a href="#v:ASCII">ASCII</a>  </li><li>| <a href="#v:Preview">Preview</a>  </li><li>| <a href="#v:GateCount">GateCount</a>  </li><li>| <a href="#v:CustomStyle">CustomStyle</a> <a href="Quipper.html#t:FormatStyle">FormatStyle</a>  </li></ul></li><li class="src short"><span class="keyword">data</span>  <a href="#t:FormatStyle">FormatStyle</a>  = <a href="#v:FormatStyle">FormatStyle</a> {<ul class="subs"><li><a href="#v:renderformat">renderformat</a> :: <a href="Libraries-Render.html#t:RenderFormat">RenderFormat</a></li><li><a href="#v:backgroundcolor">backgroundcolor</a> :: <a href="Libraries-Render.html#t:Color">Color</a></li><li><a href="#v:foregroundcolor">foregroundcolor</a> :: <a href="Libraries-Render.html#t:Color">Color</a></li><li><a href="#v:linewidth">linewidth</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></li><li><a href="#v:coffs">coffs</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></li><li><a href="#v:dotradius">dotradius</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></li><li><a href="#v:oplusradius">oplusradius</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></li><li><a href="#v:xoff">xoff</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></li><li><a href="#v:gatepad">gatepad</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></li><li><a href="#v:gateheight">gateheight</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></li><li><a href="#v:crossradius">crossradius</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></li><li><a href="#v:stringbase">stringbase</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></li><li><a href="#v:barwidth">barwidth</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></li><li><a href="#v:barheight">barheight</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></li><li><a href="#v:dwidth">dwidth</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></li><li><a href="#v:dheight">dheight</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></li><li><a href="#v:maxgatelabelwidth">maxgatelabelwidth</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></li><li><a href="#v:maxlabelwidth">maxlabelwidth</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></li><li><a href="#v:maxnumberwidth">maxnumberwidth</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></li><li><a href="#v:gatefont">gatefont</a> :: <a href="Libraries-Render.html#t:Font">Font</a></li><li><a href="#v:commentfont">commentfont</a> :: <a href="Libraries-Render.html#t:Font">Font</a></li><li><a href="#v:commentcolor">commentcolor</a> :: <a href="Libraries-Render.html#t:Color">Color</a></li><li><a href="#v:labelfont">labelfont</a> :: <a href="Libraries-Render.html#t:Font">Font</a></li><li><a href="#v:labelcolor">labelcolor</a> :: <a href="Libraries-Render.html#t:Color">Color</a></li><li><a href="#v:numberfont">numberfont</a> :: <a href="Libraries-Render.html#t:Font">Font</a></li><li><a href="#v:numbercolor">numbercolor</a> :: <a href="Libraries-Render.html#t:Color">Color</a></li><li><a href="#v:subroutineshape">subroutineshape</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li></ul>}</li><li class="src short"><a href="#v:format_enum">format_enum</a> :: &#91;(<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Format">Format</a>)&#93;</li><li class="src short"><a href="#v:print_unary">print_unary</a> :: <a href="Quipper.html#t:QCData">QCData</a> qa =&gt; <a href="Quipper.html#t:Format">Format</a> -&gt; (qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> b) -&gt; qa -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:print_generic">print_generic</a> :: (<a href="Quipper.html#t:QCData">QCData</a> qa, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa b, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> fun qa (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ())) =&gt; <a href="Quipper.html#t:Format">Format</a> -&gt; qfun -&gt; fun</li><li class="src short"><a href="#v:print_simple">print_simple</a> :: (<a href="Quipper.html#t:QCData">QCData</a> qa, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa b, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> fun qa (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ()), <a href="Quipper-QData.html#t:QCData_Simple">QCData_Simple</a> qa) =&gt; <a href="Quipper.html#t:Format">Format</a> -&gt; qfun -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:print_of_document">print_of_document</a> ::  <a href="Quipper.html#t:Format">Format</a> -&gt; <a href="Libraries-Render.html#t:Document">Document</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> a</li><li class="src short"><a href="#v:print_of_document_custom">print_of_document_custom</a> ::  <a href="Libraries-Render.html#t:Custom">Custom</a> -&gt; <a href="Quipper.html#t:Format">Format</a> -&gt; <a href="Libraries-Render.html#t:Document">Document</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> a</li><li class="src short"><a href="#v:classical_to_cnot">classical_to_cnot</a> :: (<a href="Quipper.html#t:QCData">QCData</a> qa, <a href="Quipper.html#t:QCData">QCData</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb) =&gt; qfun -&gt; qfun</li><li class="src short"><a href="#v:classical_to_quantum">classical_to_quantum</a> :: (<a href="Quipper.html#t:QCData">QCData</a> qa, <a href="Quipper.html#t:QCData">QCData</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun' (<a href="Quipper-QData.html#t:QType">QType</a> qa) (<a href="Quipper-QData.html#t:QType">QType</a> qb)) =&gt; qfun -&gt; qfun'</li><li class="src short"><a href="#v:classical_to_reversible">classical_to_reversible</a> :: (<a href="Quipper.html#t:QCData">QCData</a> qa, <a href="Quipper.html#t:QCData">QCData</a> qb) =&gt; (qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qb) -&gt; (qa, qb) -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qa, qb)</li><li class="src short"><span class="keyword">type</span> <a href="#t:Transformer">Transformer</a> m a b = <span class="keyword">forall</span> x.  <a href="Quipper.html#t:T_Gate">T_Gate</a> m a b x -&gt; x</li><li class="src short"><span class="keyword">data</span>  <a href="#t:T_Gate">T_Gate</a> m a b x<ul class="subs"><li>= <a href="#v:T_QGate">T_QGate</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="Quipper.html#t:InverseFlag">InverseFlag</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((&#91;a&#93; -&gt; &#91;a&#93; -&gt; <a href="Quipper.html#t:Ctrls">Ctrls</a> a b -&gt; m (&#91;a&#93;, &#91;a&#93;, <a href="Quipper.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)  </li><li>| <a href="#v:T_QRot">T_QRot</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="Quipper.html#t:InverseFlag">InverseFlag</a> <a href="Quipper.html#t:Timestep">Timestep</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((&#91;a&#93; -&gt; &#91;a&#93; -&gt; <a href="Quipper.html#t:Ctrls">Ctrls</a> a b -&gt; m (&#91;a&#93;, &#91;a&#93;, <a href="Quipper.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)  </li><li>| <a href="#v:T_GPhase">T_GPhase</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((&#91;<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b&#93; -&gt; <a href="Quipper.html#t:Ctrls">Ctrls</a> a b -&gt; m (<a href="Quipper.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)  </li><li>| <a href="#v:T_CNot">T_CNot</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((b -&gt; <a href="Quipper.html#t:Ctrls">Ctrls</a> a b -&gt; m (b, <a href="Quipper.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)  </li><li>| <a href="#v:T_CGate">T_CGate</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((&#91;b&#93; -&gt; m (b, &#91;b&#93;)) -&gt; x)  </li><li>| <a href="#v:T_CGateInv">T_CGateInv</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((b -&gt; &#91;b&#93; -&gt; m &#91;b&#93;) -&gt; x)  </li><li>| <a href="#v:T_CSwap">T_CSwap</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((b -&gt; b -&gt; <a href="Quipper.html#t:Ctrls">Ctrls</a> a b -&gt; m (b, b, <a href="Quipper.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)  </li><li>| <a href="#v:T_QPrep">T_QPrep</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((b -&gt; m a) -&gt; x)  </li><li>| <a href="#v:T_QUnprep">T_QUnprep</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((a -&gt; m b) -&gt; x)  </li><li>| <a href="#v:T_QInit">T_QInit</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> (m a -&gt; x)  </li><li>| <a href="#v:T_CInit">T_CInit</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> (m b -&gt; x)  </li><li>| <a href="#v:T_QTerm">T_QTerm</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((a -&gt; m ()) -&gt; x)  </li><li>| <a href="#v:T_CTerm">T_CTerm</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((b -&gt; m ()) -&gt; x)  </li><li>| <a href="#v:T_QMeas">T_QMeas</a> ((a -&gt; m b) -&gt; x)  </li><li>| <a href="#v:T_QDiscard">T_QDiscard</a> ((a -&gt; m ()) -&gt; x)  </li><li>| <a href="#v:T_CDiscard">T_CDiscard</a> ((b -&gt; m ()) -&gt; x)  </li><li>| <a href="#v:T_DTerm">T_DTerm</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> ((b -&gt; m ()) -&gt; x)  </li><li>| <a href="#v:T_Subroutine">T_Subroutine</a> <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> <a href="Quipper.html#t:InverseFlag">InverseFlag</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> <a href="Quipper-Circuit.html#t:ControllableFlag">ControllableFlag</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:Arity">Arity</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:Arity">Arity</a> <a href="Quipper-Circuit.html#t:RepeatFlag">RepeatFlag</a> ((<a href="Quipper-Circuit.html#t:Namespace">Namespace</a> -&gt; &#91;<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b&#93; -&gt; <a href="Quipper.html#t:Ctrls">Ctrls</a> a b -&gt; m (&#91;<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b&#93;, <a href="Quipper.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)  </li><li>| <a href="#v:T_Comment">T_Comment</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper.html#t:InverseFlag">InverseFlag</a> ((&#91;(<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>)&#93; -&gt; m ()) -&gt; x)  </li></ul></li><li class="src short"><a href="#v:identity_transformer">identity_transformer</a> :: <a href="Quipper.html#t:Transformer">Transformer</a> <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a> <a href="Quipper.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:transform_generic">transform_generic</a> :: (<a href="Quipper.html#t:QCData">QCData</a> x, <a href="Quipper.html#t:QCData">QCData</a> y, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun x y) =&gt; <a href="Quipper.html#t:Transformer">Transformer</a> <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a> <a href="Quipper.html#t:Bit">Bit</a> -&gt; qfun -&gt; qfun</li><li class="src short"><a href="#v:transform_generic_shape">transform_generic_shape</a> :: (<a href="Quipper.html#t:QCData">QCData</a> x, <a href="Quipper.html#t:QCData">QCData</a> y, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun x y, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' x' (m y'), <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun'' x qfun', x' ~ <a href="Quipper-QData.html#t:QCType">QCType</a> a b x, y' ~ <a href="Quipper-QData.html#t:QCType">QCType</a> a b y, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m) =&gt; <a href="Quipper.html#t:Transformer">Transformer</a> m a b -&gt; qfun -&gt; qfun''</li><li class="src short"><span class="keyword">type</span> <a href="#t:InverseFlag">InverseFlag</a> = <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:NoControlFlag">NoControlFlag</a> = <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><span class="keyword">data</span>  <a href="#t:B_Endpoint">B_Endpoint</a> a b<ul class="subs"><li>= <a href="#v:Endpoint_Qubit">Endpoint_Qubit</a> a  </li><li>| <a href="#v:Endpoint_Bit">Endpoint_Bit</a> b  </li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:Endpoint">Endpoint</a> = <a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> <a href="Quipper.html#t:Qubit">Qubit</a> <a href="Quipper.html#t:Bit">Bit</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Ctrls">Ctrls</a> a b = &#91;<a href="Quipper.html#t:Signed">Signed</a> (<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b)&#93;</li><li class="src short">module <a href="Quipper-CircLifting.html">Quipper.CircLifting</a></li><li class="src short">module <a href="Libraries-Template.html">Libraries.Template</a></li><li class="src short"><span class="keyword">class</span> (<a href="Quipper.html#t:QData">QData</a> qa, <a href="Quipper-QData.html#t:CType">CType</a> qa ~ ca, <a href="Quipper-QData.html#t:BType">BType</a> qa ~ ba) =&gt; <a href="#t:QShape">QShape</a> ba qa ca | ba -&gt; qa, qa -&gt; ca, ca -&gt; ba</li><li class="src short"><span class="keyword">class</span> (qa ~ <a href="Quipper-QData.html#t:QType">QType</a> (<a href="Quipper-QData.html#t:CType">CType</a> qa), qa ~ <a href="Quipper-QData.html#t:QTypeB">QTypeB</a> (<a href="Quipper-QData.html#t:BType">BType</a> qa), qa ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> qa, qa ~ <a href="Quipper-QData.html#t:QType">QType</a> qa, <a href="Quipper.html#t:QCData">QCData</a> qa, <a href="Quipper.html#t:QCData">QCData</a> (<a href="Quipper-QData.html#t:CType">CType</a> qa)) =&gt; <a href="#t:QData">QData</a> qa </li><li class="src short"><span class="keyword">class</span> (<a href="Quipper.html#t:QData">QData</a> (<a href="Quipper-QData.html#t:QType">QType</a> ca), <a href="Quipper-QData.html#t:CType">CType</a> (<a href="Quipper-QData.html#t:QType">QType</a> ca) ~ ca) =&gt; <a href="#t:CData">CData</a> ca </li><li class="src short"><span class="keyword">class</span> (<a href="Quipper.html#t:QData">QData</a> (<a href="Quipper-QData.html#t:QTypeB">QTypeB</a> ba), <a href="Quipper-QData.html#t:BType">BType</a> (<a href="Quipper-QData.html#t:QTypeB">QTypeB</a> ba) ~ ba) =&gt; <a href="#t:BData">BData</a> ba </li><li class="src short"><span class="keyword">class</span> (<a href="Quipper.html#t:Labelable">Labelable</a> qc <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> qc, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> qc, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Quipper-QData.html#t:LType">LType</a> qc), qc ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper.html#t:Qubit">Qubit</a> <a href="Quipper.html#t:Bit">Bit</a> qc, <a href="Quipper-QData.html#t:CType">CType</a> (<a href="Quipper-QData.html#t:QType">QType</a> qc) ~ <a href="Quipper-QData.html#t:CType">CType</a> qc, <a href="Quipper-QData.html#t:BType">BType</a> (<a href="Quipper-QData.html#t:CType">CType</a> qc) ~ <a href="Quipper-QData.html#t:BType">BType</a> qc, <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:CType">CType</a> qc) ~ <a href="Quipper-QData.html#t:BType">BType</a> qc) =&gt; <a href="#t:QCData">QCData</a> qc </li><li class="src short"><span class="keyword">class</span> (<a href="Quipper.html#t:QCData">QCData</a> qc, <a href="Quipper.html#t:QData">QData</a> (<a href="Quipper-QData.html#t:QType">QType</a> qc)) =&gt; <a href="#t:QCDataPlus">QCDataPlus</a> qc </li><li class="src short"><a href="#v:bit">bit</a> :: <a href="Quipper.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:qubit">qubit</a> :: <a href="Quipper.html#t:Qubit">Qubit</a></li><li class="src short"><a href="#v:qshape">qshape</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa -&gt; qa</li><li class="src short"><a href="#v:qc_false">qc_false</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qc</li><li class="src short"><span class="keyword">class</span> <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; <a href="#t:QEq">QEq</a> qc  <span class="keyword">where</span><ul class="subs"><li><a href="#v:q_is_equal">q_is_equal</a> :: qc -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qc, qc, <a href="Quipper.html#t:Qubit">Qubit</a>)</li><li><a href="#v:q_is_not_equal">q_is_not_equal</a> :: qc -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qc, qc, <a href="Quipper.html#t:Qubit">Qubit</a>)</li></ul></li><li class="src short"><span class="keyword">class</span> (<a href="Quipper.html#t:QEq">QEq</a> qa, <a href="Quipper.html#t:QData">QData</a> qa) =&gt; <a href="#t:QOrd">QOrd</a> qa  <span class="keyword">where</span><ul class="subs"><li><a href="#v:q_less">q_less</a> :: qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li><a href="#v:q_greater">q_greater</a> :: qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li><a href="#v:q_leq">q_leq</a> :: qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li><a href="#v:q_geq">q_geq</a> :: qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a></li><li><a href="#v:q_max">q_max</a> :: qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa</li><li><a href="#v:q_min">q_min</a> :: qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa</li></ul></li><li class="src short"><a href="#v:q_lt">q_lt</a> :: <a href="Quipper.html#t:QOrd">QOrd</a> qa =&gt; qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qa, qa, <a href="Quipper.html#t:Qubit">Qubit</a>)</li><li class="src short"><a href="#v:q_gt">q_gt</a> :: <a href="Quipper.html#t:QOrd">QOrd</a> qa =&gt; qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qa, qa, <a href="Quipper.html#t:Qubit">Qubit</a>)</li><li class="src short"><a href="#v:q_le">q_le</a> :: <a href="Quipper.html#t:QOrd">QOrd</a> qa =&gt; qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qa, qa, <a href="Quipper.html#t:Qubit">Qubit</a>)</li><li class="src short"><a href="#v:q_ge">q_ge</a> :: <a href="Quipper.html#t:QOrd">QOrd</a> qa =&gt; qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qa, qa, <a href="Quipper.html#t:Qubit">Qubit</a>)</li></ul></div><div id="interface"><h1 id="g:1">The Circ monad  
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Circ" class="def">Circ</a> a <a href="src/Quipper/Monad.html#line-267" class="link">Source</a></p><div class="doc"><p>The <code><a href="Quipper.html#t:Circ">Circ</a></code> monad encapsulates the type of quantum operations. For
 example, a quantum operation that inputs two <code><a href="Quipper.html#t:Qubit">Qubit</a></code>s and outputs a
 <code><a href="Quipper.html#t:Qubit">Qubit</a></code> and a <code><a href="Quipper.html#t:Bit">Bit</a></code> has the following type:
</p><pre> (Qubit, Qubit) -&gt; Circ (Qubit, Bit)
</pre></div><div class="subs instances"><p id="control.i:Circ" class="caption collapser" onclick="toggleSection('i:Circ')">Instances</p><div id="section.i:Circ" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> <a href="Quipper.html#t:Circ">Circ</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Functor">Functor</a> <a href="Quipper.html#t:Circ">Circ</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-Generic.html#t:QCurry">QCurry</a> (<a href="Quipper.html#t:Circ">Circ</a> b) () b</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-CircLifting.html#t:CircLiftingUnpack">CircLiftingUnpack</a> (<a href="Quipper.html#t:Circ">Circ</a> &#91;a&#93;) (<a href="Quipper.html#t:Circ">Circ</a> &#91;a&#93;)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-CircLifting.html#t:CircLiftingUnpack">CircLiftingUnpack</a> (<a href="Quipper.html#t:Circ">Circ</a> ()) (<a href="Quipper.html#t:Circ">Circ</a> ())</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-CircLifting.html#t:CircLiftingUnpack">CircLiftingUnpack</a> (<a href="Quipper.html#t:Circ">Circ</a> (a, b)) (<a href="Quipper.html#t:Circ">Circ</a> (a, b))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-CircLifting.html#t:CircLiftingUnpack">CircLiftingUnpack</a> (<a href="Quipper.html#t:Circ">Circ</a> (a, b, c)) (<a href="Quipper.html#t:Circ">Circ</a> (a, b, c))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-CircLifting.html#t:CircLiftingUnpack">CircLiftingUnpack</a> (<a href="Quipper.html#t:Circ">Circ</a> (a, b, c, d)) (<a href="Quipper.html#t:Circ">Circ</a> (a, b, c, d))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-CircLifting.html#t:CircLiftingUnpack">CircLiftingUnpack</a> (<a href="Quipper.html#t:Circ">Circ</a> (a, b, c, d, e)) (<a href="Quipper.html#t:Circ">Circ</a> (a, b, c, d, e))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-CircLifting.html#t:CircLiftingUnpack">CircLiftingUnpack</a> (<a href="Quipper.html#t:Circ">Circ</a> (a, b, c, d, e, f)) (<a href="Quipper.html#t:Circ">Circ</a> (a, b, c, d, e, f))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-CircLifting.html#t:CircLiftingUnpack">CircLiftingUnpack</a> (<a href="Quipper.html#t:Circ">Circ</a> (a, b, c, d, e, f, g)) (<a href="Quipper.html#t:Circ">Circ</a> (a, b, c, d, e, f, g))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-CircLifting.html#t:CircLiftingUnpack">CircLiftingUnpack</a> (<a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a>) (<a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-CircLifting.html#t:CircLiftingUnpack">CircLiftingUnpack</a> (<a href="Quipper.html#t:Circ">Circ</a> b) b' =&gt; <a href="Quipper-CircLifting.html#t:CircLiftingUnpack">CircLiftingUnpack</a> (<a href="Quipper.html#t:Circ">Circ</a> (a -&gt; <a href="Quipper.html#t:Circ">Circ</a> b)) (a -&gt; b')</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:2">Basic types
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Qubit" class="def">Qubit</a>  <a href="src/Quipper/Monad.html#line-417" class="link">Source</a></p><div class="doc"><p>The type of qubits.
</p></div><div class="subs instances"><p id="control.i:Qubit" class="caption collapser" onclick="toggleSection('i:Qubit')">Instances</p><div id="section.i:Qubit" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Quipper.html#t:Qubit">Qubit</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a> <a href="Quipper.html#t:Qubit">Qubit</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Quipper.html#t:Qubit">Qubit</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> <a href="Quipper.html#t:Qubit">Qubit</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:ControlSource">ControlSource</a> <a href="Quipper.html#t:Qubit">Qubit</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-QData.html#t:QCLeaf">QCLeaf</a> <a href="Quipper.html#t:Qubit">Qubit</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-QData.html#t:SimpleType">SimpleType</a> <a href="Quipper.html#t:Qubit">Qubit</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:QCData">QCData</a> <a href="Quipper.html#t:Qubit">Qubit</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:Labelable">Labelable</a> <a href="Quipper.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:ControlSource">ControlSource</a> (<a href="Quipper.html#t:Signed">Signed</a> <a href="Quipper.html#t:Qubit">Qubit</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-CircLifting.html#t:CircLiftingUnpack">CircLiftingUnpack</a> (<a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a>) (<a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Bit" class="def">Bit</a>  <a href="src/Quipper/Monad.html#line-422" class="link">Source</a></p><div class="doc"><p>The type of run-time classical bits (i.e., boolean wires in a
 circuit).
</p></div><div class="subs instances"><p id="control.i:Bit" class="caption collapser" onclick="toggleSection('i:Bit')">Instances</p><div id="section.i:Bit" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> <a href="Quipper.html#t:Bit">Bit</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a> <a href="Quipper.html#t:Bit">Bit</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Quipper.html#t:Bit">Bit</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> <a href="Quipper.html#t:Bit">Bit</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:ControlSource">ControlSource</a> <a href="Quipper.html#t:Bit">Bit</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-QData.html#t:QCLeaf">QCLeaf</a> <a href="Quipper.html#t:Bit">Bit</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper-QData.html#t:SimpleType">SimpleType</a> <a href="Quipper.html#t:Bit">Bit</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:QCData">QCData</a> <a href="Quipper.html#t:Bit">Bit</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:Labelable">Labelable</a> <a href="Quipper.html#t:Bit">Bit</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:ControlSource">ControlSource</a> (<a href="Quipper.html#t:Signed">Signed</a> <a href="Quipper.html#t:Bit">Bit</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Qulist" class="def">Qulist</a> = &#91;<a href="Quipper.html#t:Qubit">Qubit</a>&#93;<a href="src/Quipper/Monad.html#line-435" class="link">Source</a></p><div class="doc"><p>Synonym for a qubit list, for convenience.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Bitlist" class="def">Bitlist</a> = &#91;<a href="Quipper.html#t:Bit">Bit</a>&#93;<a href="src/Quipper/Monad.html#line-438" class="link">Source</a></p><div class="doc"><p>Synonym for a bit list, for convenience.
</p></div></div><h1 id="g:3">Basic gates
</h1><div class="doc"><p>This section contains various elementary gates that can be used as
 building blocks for constructing circuits.
</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Timestep" class="def">Timestep</a> = <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a><a href="src/Quipper/Circuit.html#line-82" class="link">Source</a></p><div class="doc"><p>A time step is a small floating point number used as a
 parameter to certain gates, such as rotation gates or the
 <i>e</i><sup>&#8722;<em>iZt</em></sup> gate.
</p></div></div><div class="doc"><p><a name="Reversible gates in functional style"></a>
</p></div><h2 id="g:4">Reversible gates in functional style
</h2><div class="doc"><p>The gates in this section are in &quot;functional&quot; style, which means
 that they return something. For example, the <code><a href="Quipper.html#v:qnot">qnot</a></code> gate consumes a
 <code><a href="Quipper.html#t:Qubit">Qubit</a></code>, performs an operation, and outputs a new <code><a href="Quipper.html#t:Qubit">Qubit</a></code>. The
 gates should be used like this:
</p><pre> output &lt;- qnot input
</pre><p>or, for a binary gate:
</p><pre> (out0, out1) &lt;- gate_W in0 in1
</pre><p>For each of these gates, we also provide a version in imperative
 style, see <a href="#Reversible gates in imperative style">#Reversible gates in imperative style</a> below.
</p></div><div class="top"><p class="src"><a name="v:qnot" class="def">qnot</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/Monad.html#line-610" class="link">Source</a></p><div class="doc"><p>Apply a NOT gate to a qubit.
</p></div></div><div class="top"><p class="src"><a name="v:hadamard" class="def">hadamard</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/Monad.html#line-616" class="link">Source</a></p><div class="doc"><p>Apply a Hadamard gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_H" class="def">gate_H</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/Monad.html#line-622" class="link">Source</a></p><div class="doc"><p>An alternate name for the Hadamard gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_X" class="def">gate_X</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/Monad.html#line-643" class="link">Source</a></p><div class="doc"><p>Apply a Pauli <em>X</em> gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_Y" class="def">gate_Y</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/Monad.html#line-649" class="link">Source</a></p><div class="doc"><p>Apply a Pauli <em>Y</em> gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_Z" class="def">gate_Z</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/Monad.html#line-655" class="link">Source</a></p><div class="doc"><p>Apply a Pauli <em>Z</em> gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_S" class="def">gate_S</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/Monad.html#line-661" class="link">Source</a></p><div class="doc"><p>Apply a Clifford <em>S</em>-gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_S_inv" class="def">gate_S_inv</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/Monad.html#line-667" class="link">Source</a></p><div class="doc"><p>Apply the inverse of an <em>S</em>-gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_T" class="def">gate_T</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/Monad.html#line-673" class="link">Source</a></p><div class="doc"><p>Apply a <em>T</em> = &#8730;<em>S</em> gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_T_inv" class="def">gate_T_inv</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/Monad.html#line-679" class="link">Source</a></p><div class="doc"><p>Apply the inverse of a <em>T</em>-gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_E" class="def">gate_E</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/Monad.html#line-697" class="link">Source</a></p><div class="doc"><p>Apply a Clifford <em>E</em> = <em>H</em><em>S</em><sup>3</sup>&#969;<sup>3</sup> gate. 
</p><p><img src="images/E.png">
</p><p>This gate is the unique Clifford operator with the properties <em>E</em>&#179;
 = <em>I</em>, <em>EXE</em>&#8315;&#185; = <em>Y</em>, <em>EYE</em>&#8315;&#185; = <em>Z</em>, and <em>EZE</em>&#8315;&#185; = <em>X</em>. It is a
 convenient gate for calculations. For example, every Clifford
 operator can be uniquely written of the form
</p><ul><li> <em>E</em><sup><em>a</em></sup><em>X</em><sup><em>b</em></sup><em>S</em><sup><em>c</em></sup>&#969;<sup><em>d</em></sup>,
</li></ul><p>where <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> are taken modulo 3, 2, 4, and 8,
 respectively.
</p></div></div><div class="top"><p class="src"><a name="v:gate_E_inv" class="def">gate_E_inv</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/Monad.html#line-703" class="link">Source</a></p><div class="doc"><p>Apply the inverse of an <em>E</em>-gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_omega" class="def">gate_omega</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/Monad.html#line-709" class="link">Source</a></p><div class="doc"><p>Apply the scalar &#969; = <i>e</i><sup><em>i</em>&#960;/4</sup>, as a single-qubit gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_V" class="def">gate_V</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/Monad.html#line-718" class="link">Source</a></p><div class="doc"><p>Apply a <em>V</em> = &#8730;<em>X</em> gate. This is by definition the following gate
 (see also Nielsen and Chuang, p.182):
</p><p><img src="images/V.png">
</p></div></div><div class="top"><p class="src"><a name="v:gate_V_inv" class="def">gate_V_inv</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/Monad.html#line-724" class="link">Source</a></p><div class="doc"><p>Apply the inverse of a <em>V</em>-gate.
</p></div></div><div class="top"><p class="src"><a name="v:expZt" class="def">expZt</a> :: <a href="Quipper.html#t:Timestep">Timestep</a> -&gt; <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/Monad.html#line-742" class="link">Source</a></p><div class="doc"><p>Apply an <i>e</i><sup>&#8722;<em>iZt</em></sup> gate. The timestep <em>t</em> is a parameter.
</p></div></div><div class="top"><p class="src"><a name="v:rGate" class="def">rGate</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/Monad.html#line-750" class="link">Source</a></p><div class="doc"><p>Apply a rotation by angle 2&#960;<em>i</em>/2<sup><em>n</em></sup> about the <em>z</em>-axis.
</p><p><img src="images/rGate.png">
</p></div></div><div class="top"><p class="src"><a name="v:gate_W" class="def">gate_W</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> (<a href="Quipper.html#t:Qubit">Qubit</a>, <a href="Quipper.html#t:Qubit">Qubit</a>)<a href="src/Quipper/Monad.html#line-769" class="link">Source</a></p><div class="doc"><p>Apply a <em>W</em> gate. The <em>W</em> gate is self-inverse and diagonalizes
 the SWAP gate. 
</p><p><img src="images/W.png">
</p><p>The arguments are such that 
</p><pre> gate_W |0&#9002; |0&#9002; = |00&#9002;
 gate_W |0&#9002; |1&#9002; = (|01&#9002;+|10&#9002;) / &#8730;2
 gate_W |1&#9002; |0&#9002; = (|01&#9002;-|10&#9002;) / &#8730;2
 gate_W |1&#9002; |1&#9002; = |11&#9002;.
</pre><p>In circuit diagrams, <em>W</em><sub>1</sub> denotes the &quot;left&quot; qubit, and <em>W</em><sub>2</sub>
 denotes the &quot;right&quot; qubit.
</p></div></div><div class="top"><p class="src"><a name="v:gate_iX" class="def">gate_iX</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/Monad.html#line-789" class="link">Source</a></p><div class="doc"><p>Apply an <em>iX</em> gate. This gate is used similarly to the Pauli <em>X</em>
 gate, but with two advantages:
</p><ul><li> the doubly-controlled <em>iX</em> gate can be implemented in the
 Clifford+<em>T</em> gate base with <em>T</em>-count 4 (the doubly-controlled <em>X</em>
 gate requires <em>T</em>-count 7);
</li><li> the <em>iX</em>-gate has determinant 1, and therefore an <em>n</em>-times
 controlled <em>iX</em> gate can be implemented in the Clifford+<em>T</em> gate
 base with no ancillas.
</li></ul><p>In particular, the <em>iX</em> gate can be used to implement an additional
 control with <em>T</em>-count 8, like this:
</p><p><img src="images/iX.png">
</p></div></div><div class="top"><p class="src"><a name="v:global_phase" class="def">global_phase</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Monad.html#line-797" class="link">Source</a></p><div class="doc"><p>Apply a global phase change <i>e</i><sup><em>i</em>&#960;<em>t</em></sup>, where typically <em>t</em> &#8712;
 &#91;0,2&#93;.  This gate is uninteresting if not controlled; however, it
 has non-trivial effect if it is used as a controlled gate.
</p></div></div><div class="top"><p class="src"><a name="v:global_phase_anchored" class="def">global_phase_anchored</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Generic.html#line-374" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper.html#v:global_phase">global_phase</a></code>, except the gate is also &quot;anchored&quot; at a
 qubit, a bit, or more generally at some quantum data. The anchor
 is only used as a hint for graphical display. The gate, which is a
 zero-qubit gate, will potentially be displayed near the anchor(s).
</p></div></div><div class="top"><p class="src"><a name="v:qmultinot" class="def">qmultinot</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa<a href="src/Quipper/Generic.html#line-477" class="link">Source</a></p><div class="doc"><p>Negate all qubits in a quantum data structure.
</p></div></div><div class="top"><p class="src"><a name="v:cnot" class="def">cnot</a> :: <a href="Quipper.html#t:Bit">Bit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Bit">Bit</a><a href="src/Quipper/Monad.html#line-833" class="link">Source</a></p><div class="doc"><p>Apply a NOT gate to a classical bit.
</p></div></div><div class="top"><p class="src"><a name="v:swap" class="def">swap</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qc, qc)<a href="src/Quipper/Generic.html#line-394" class="link">Source</a></p><div class="doc"><p>Apply a swap gate to two qubits. More generally, apply swap gates
 to every corresponding pair of qubits in two pieces of quantum
 data.
</p></div></div><div class="doc"><p><a name="Reversible gates in imperative style"></a>
</p></div><h2 id="g:5">Reversible gates in imperative style 
</h2><div class="doc"><p>The gates in this section are in &quot;imperative&quot; style, which means
 that they operate on a qubit &quot;in place&quot; and do not return
 anything. The gates should be used like this:
</p><pre> qnot_at q
</pre><p>or, for a binary gate:
</p><pre> gate_W_at q0 q1
</pre><p>For each of these gates, we also provide a version in functional
 style, see <a href="#Reversible gates in functional style">#Reversible gates in functional style</a> above.
</p></div><div class="top"><p class="src"><a name="v:qnot_at" class="def">qnot_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Monad.html#line-842" class="link">Source</a></p><div class="doc"><p>Apply a NOT gate to a qubit.
</p></div></div><div class="top"><p class="src"><a name="v:hadamard_at" class="def">hadamard_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Monad.html#line-848" class="link">Source</a></p><div class="doc"><p>Apply a Hadamard gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_H_at" class="def">gate_H_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Monad.html#line-854" class="link">Source</a></p><div class="doc"><p>An alternate name for the Hadamard gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_X_at" class="def">gate_X_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Monad.html#line-873" class="link">Source</a></p><div class="doc"><p>Apply a Pauli <em>X</em> gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_Y_at" class="def">gate_Y_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Monad.html#line-879" class="link">Source</a></p><div class="doc"><p>Apply a Pauli <em>Y</em> gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_Z_at" class="def">gate_Z_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Monad.html#line-885" class="link">Source</a></p><div class="doc"><p>Apply a Pauli <em>Z</em> gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_S_at" class="def">gate_S_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Monad.html#line-891" class="link">Source</a></p><div class="doc"><p>Apply a Clifford <em>S</em>-gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_S_inv_at" class="def">gate_S_inv_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Monad.html#line-897" class="link">Source</a></p><div class="doc"><p>Apply the inverse of an <em>S</em>-gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_T_at" class="def">gate_T_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Monad.html#line-903" class="link">Source</a></p><div class="doc"><p>Apply a <em>T</em> = &#8730;<em>S</em> gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_T_inv_at" class="def">gate_T_inv_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Monad.html#line-909" class="link">Source</a></p><div class="doc"><p>Apply the inverse of a <em>T</em>-gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_E_at" class="def">gate_E_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Monad.html#line-927" class="link">Source</a></p><div class="doc"><p>Apply a Clifford <em>E</em> = <em>H</em><em>S</em><sup>3</sup>&#969;<sup>3</sup> gate. 
</p><p><img src="images/E.png">
</p><p>This gate is the unique Clifford operator with the properties <em>E</em>&#179;
 = <em>I</em>, <em>EXE</em>&#8315;&#185; = <em>Y</em>, <em>EYE</em>&#8315;&#185; = <em>Z</em>, and <em>EZE</em>&#8315;&#185; = <em>X</em>. It is a
 convenient gate for calculations. For example, every Clifford
 operator can be uniquely written of the form
</p><ul><li> <em>E</em><sup><em>a</em></sup><em>X</em><sup><em>b</em></sup><em>S</em><sup><em>c</em></sup>&#969;<sup><em>d</em></sup>,
</li></ul><p>where <em>a</em>, <em>b</em>, <em>c</em>, and <em>d</em> are taken modulo 3, 2, 4, and 8,
 respectively.
</p></div></div><div class="top"><p class="src"><a name="v:gate_E_inv_at" class="def">gate_E_inv_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Monad.html#line-933" class="link">Source</a></p><div class="doc"><p>Apply the inverse of an <em>E</em>-gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_omega_at" class="def">gate_omega_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Monad.html#line-939" class="link">Source</a></p><div class="doc"><p>Apply the scalar &#969; = <i>e</i><sup><em>i</em>&#960;/4</sup>, as a single-qubit gate.
</p></div></div><div class="top"><p class="src"><a name="v:gate_V_at" class="def">gate_V_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Monad.html#line-948" class="link">Source</a></p><div class="doc"><p>Apply a <em>V</em> = &#8730;<em>X</em> gate. This is by definition the following gate
 (see also Nielsen and Chuang, p.182):
</p><p><img src="images/V.png">
</p></div></div><div class="top"><p class="src"><a name="v:gate_V_inv_at" class="def">gate_V_inv_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Monad.html#line-954" class="link">Source</a></p><div class="doc"><p>Apply the inverse of a <em>V</em>-gate.
</p></div></div><div class="top"><p class="src"><a name="v:expZt_at" class="def">expZt_at</a> :: <a href="Quipper.html#t:Timestep">Timestep</a> -&gt; <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Monad.html#line-972" class="link">Source</a></p><div class="doc"><p>Apply an <i>e</i><sup>&#8722;<em>iZt</em></sup> gate. The timestep <em>t</em> is a parameter.
</p></div></div><div class="top"><p class="src"><a name="v:rGate_at" class="def">rGate_at</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Monad.html#line-980" class="link">Source</a></p><div class="doc"><p>Apply a rotation by angle 2&#960;<em>i</em>/2<sup><em>n</em></sup> about the <em>z</em>-axis.
</p><p><img src="images/rGate.png">
</p></div></div><div class="top"><p class="src"><a name="v:gate_W_at" class="def">gate_W_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Monad.html#line-999" class="link">Source</a></p><div class="doc"><p>Apply a <em>W</em> gate. The <em>W</em> gate is self-inverse and diagonalizes
 the SWAP gate. 
</p><p><img src="images/W.png">
</p><p>The arguments are such that 
</p><pre> gate_W |0&#9002; |0&#9002; = |00&#9002;
 gate_W |0&#9002; |1&#9002; = (|01&#9002;+|10&#9002;) / &#8730;2
 gate_W |1&#9002; |0&#9002; = (|01&#9002;-|10&#9002;) / &#8730;2
 gate_W |1&#9002; |1&#9002; = |11&#9002;.
</pre><p>In circuit diagrams, <em>W</em><sub>1</sub> denotes the &quot;left&quot; qubit, and <em>W</em><sub>2</sub>
 denotes the &quot;right&quot; qubit.
</p></div></div><div class="top"><p class="src"><a name="v:gate_iX_at" class="def">gate_iX_at</a> :: <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Monad.html#line-1019" class="link">Source</a></p><div class="doc"><p>Apply an <em>iX</em> gate. This gate is used similarly to the Pauli <em>X</em>
 gate, but with two advantages:
</p><ul><li> the doubly-controlled <em>iX</em> gate can be implemented in the
 Clifford+<em>T</em> gate base with <em>T</em>-count 4 (the doubly-controlled <em>X</em>
 gate requires <em>T</em>-count 7);
</li><li> the <em>iX</em>-gate has determinant 1, and therefore an <em>n</em>-times
 controlled <em>iX</em> gate can be implemented in the Clifford+<em>T</em> gate
 base with no ancillas.
</li></ul><p>In particular, the <em>iX</em> gate can be used to implement an additional
 control with <em>T</em>-count 8, like this:
</p><p><img src="images/iX.png">
</p></div></div><div class="top"><p class="src"><a name="v:qmultinot_at" class="def">qmultinot_at</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Generic.html#line-483" class="link">Source</a></p><div class="doc"><p>Negate all qubits in a quantum data structure.
</p></div></div><div class="top"><p class="src"><a name="v:cnot_at" class="def">cnot_at</a> :: <a href="Quipper.html#t:Bit">Bit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Monad.html#line-1043" class="link">Source</a></p><div class="doc"><p>Apply a NOT gate to a classical bit.
</p></div></div><div class="top"><p class="src"><a name="v:swap_at" class="def">swap_at</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Generic.html#line-400" class="link">Source</a></p><div class="doc"><p>Apply a swap gate to two qubits. More generally, apply swap gates
 to every corresponding pair of qubits in two pieces of quantum
 data.
</p></div></div><h2 id="g:6">Gates for state preparation and termination
</h2><div class="top"><p class="src"><a name="v:qinit" class="def">qinit</a> :: <a href="Quipper.html#t:QShape">QShape</a> ba qa ca =&gt; ba -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa<a href="src/Quipper/Generic.html#line-172" class="link">Source</a></p><div class="doc"><p>Initialize a qubit from a boolean parameter. More generally,
 initialize a data structure of qubits from a corresponding data
 structure of boolean parameters. Examples:
</p><pre> q &lt;- qinit False
 (q0, q1) &lt;- qinit (True, False)
 &#91;q0, q1, q2&#93; &lt;- qinit &#91;True, False, True&#93;
</pre></div></div><div class="top"><p class="src"><a name="v:qterm" class="def">qterm</a> :: <a href="Quipper.html#t:QShape">QShape</a> ba qa ca =&gt; ba -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Generic.html#line-194" class="link">Source</a></p><div class="doc"><p>Terminate a qubit, asserting its state to equal the boolean
 parameter. More generally, terminate a data structure of qubits,
 asserting that their state is as given by a data structure of
 booleans parameters. Examples:
</p><pre> qterm False q
 qterm (False, False) (q0, q1)
 qterm &#91;False, False, False&#93; &#91;q0, q1, q2&#93;
</pre><p>In some cases, it is permissible for some aspect of the parameter's
 shape to be underspecified, e.g., a longer than necessary list, or
 an integer of indeterminate length. It is therefore possible, for
 example, to write:
</p><pre> qterm 17 qa          -- when qa :: QDInt,
 qterm &#91;False..&#93; qa   -- when qa :: &#91;Qubit&#93;.
</pre><p>The rules for when a boolean argument can be &quot;promoted&quot; in this
 way are specific to each individual data type.
</p></div></div><div class="top"><p class="src"><a name="v:qdiscard" class="def">qdiscard</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Generic.html#line-212" class="link">Source</a></p><div class="doc"><p>Discard a qubit, ignoring its state. This can leave the quantum
 system in a mixed state, so is not a reversible operation. More
 generally, discard all the qubits in a quantum data
 structure. Examples:
</p><pre> qdiscard q
 qdiscard (q0, q1)
 qdiscard &#91;q0, q1, q2&#93;
</pre></div></div><div class="top"><p class="src"><a name="v:cinit" class="def">cinit</a> :: <a href="Quipper.html#t:QShape">QShape</a> ba qa ca =&gt; ba -&gt; <a href="Quipper.html#t:Circ">Circ</a> ca<a href="src/Quipper/Generic.html#line-224" class="link">Source</a></p><div class="doc"><p>Initialize a <code><a href="Quipper.html#t:Bit">Bit</a></code> (boolean input) from a <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></code> (boolean
 parameter). More generally, initialize the a data structure of Bits
 from a corresponding data structure of Bools. Examples:
</p><pre> b &lt;- cinit False
 (b0, b1) &lt;- cinit (True, False)
 &#91;b0, b1, b2&#93; &lt;- cinit &#91;True, False, True&#93;
</pre></div></div><div class="top"><p class="src"><a name="v:cterm" class="def">cterm</a> :: <a href="Quipper.html#t:QShape">QShape</a> ba qa ca =&gt; ba -&gt; ca -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Generic.html#line-246" class="link">Source</a></p><div class="doc"><p>Terminate a <code><a href="Quipper.html#t:Bit">Bit</a></code>, asserting its state to equal the given
 <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></code>. More generally, terminate a data structure of Bits,
 asserting that their state is as given by a data structure of
 Bools. Examples:
</p><pre> cterm False b
 cterm (False, False) (b0, b1)
 cterm &#91;False, False, False&#93; &#91;b0, b1, b2&#93;
</pre><p>In some cases, it is permissible for some aspect of the parameter's
 shape to be underspecified, e.g., a longer than necessary list, or
 an integer of indeterminate length. It is therefore possible, for
 example, to write:
</p><pre> cterm 17 ca          -- when ca :: CInt,
 cterm &#91;False..&#93; ca   -- when ca :: &#91;Bit&#93;.
</pre><p>The rules for when a boolean argument can be &quot;promoted&quot; in this
 way are specific to each individual data type.
</p></div></div><div class="top"><p class="src"><a name="v:cdiscard" class="def">cdiscard</a> :: <a href="Quipper.html#t:CData">CData</a> ca =&gt; ca -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Generic.html#line-265" class="link">Source</a></p><div class="doc"><p>Discard a <code><a href="Quipper.html#t:Bit">Bit</a></code>, ignoring its state. This can leave the system in
 a mixed state, so is not a reversible operation. More generally,
 discard all the Bits in a data structure. Examples:
</p><pre> cdiscard b
 cdiscard (b0, b1)
 cdiscard &#91;b0, b1, b2&#93;
</pre></div></div><div class="top"><p class="src"><a name="v:qc_init" class="def">qc_init</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; <a href="Quipper-QData.html#t:BType">BType</a> qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> qc<a href="src/Quipper/Generic.html#line-284" class="link">Source</a></p><div class="doc"><p>Heterogeneous version of <code><a href="Quipper.html#v:qinit">qinit</a></code>. Please note that the type of
 the result of this function cannot be inferred from the type of the
 argument. For example, 
</p><pre> x &lt;- qc_init False
</pre><p>is ambiguous, unless it can be inferred from the context whether
 <em>x</em> is a <code><a href="Quipper.html#t:Bit">Bit</a></code> or a <code><a href="Quipper.html#t:Qubit">Qubit</a></code>. If the type cannot be inferred from
 the context, it needs to be stated explicitly, like this:
</p><pre> x &lt;- qc_init False :: Circ Qubit
</pre><p>Alternatively, <code><a href="Quipper.html#v:qc_init_with_shape">qc_init_with_shape</a></code> can be used to fix a specific
 type.
</p></div></div><div class="top"><p class="src"><a name="v:qc_init_with_shape" class="def">qc_init_with_shape</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> qc<a href="src/Quipper/Generic.html#line-299" class="link">Source</a></p><div class="doc"><p>A version of <code><a href="Quipper.html#v:qc_init">qc_init</a></code> that uses a shape type parameter. The
 first argument is the shape type parameter, and the second argument
 is a data structure containing boolean initializers. The shape type
 argument determines which booleans are used to initialize qubits,
 and which ones are used to initialize classical bits.
</p><p>Example:
</p><pre> (x,y) &lt;- qc_init_with_shape (bit,&#91;qubit&#93;) (True, &#91;False,True&#93;)
</pre><p>This will assign to <em>x</em> a classical bit initialized to 1, and to
 <em>y</em> a list of two qubits initialized to |0&#9002; and |1&#9002;, respectively.
</p></div></div><div class="top"><p class="src"><a name="v:qc_term" class="def">qc_term</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; <a href="Quipper-QData.html#t:BType">BType</a> qc -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Generic.html#line-303" class="link">Source</a></p><div class="doc"><p>Heterogeneous version of <code><a href="Quipper.html#v:qterm">qterm</a></code>. 
</p></div></div><div class="top"><p class="src"><a name="v:qc_discard" class="def">qc_discard</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Generic.html#line-320" class="link">Source</a></p><div class="doc"><p>Heterogeneous version of <code><a href="Quipper.html#v:qdiscard">qdiscard</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:measure" class="def">measure</a> :: <a href="Quipper.html#t:QShape">QShape</a> ba qa ca =&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> ca<a href="src/Quipper/Generic.html#line-336" class="link">Source</a></p><div class="doc"><p>Measure a <code><a href="Quipper.html#t:Qubit">Qubit</a></code>, resulting in a <code><a href="Quipper.html#t:Bit">Bit</a></code>. More generally, measure
 all the Qubits in a quantum data structure, resulting in a
 corresponding data structure of Bits. This is not a reversible
 operation. Examples:
</p><pre> b &lt;- measure q
 (b0, b1) &lt;- measure (q0, q1)
 &#91;b0, b1, b2&#93; &lt;- measure &#91;q0, q1, q2&#93;
</pre></div></div><div class="top"><p class="src"><a name="v:prepare" class="def">prepare</a> :: <a href="Quipper.html#t:QShape">QShape</a> ba qa ca =&gt; ca -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa<a href="src/Quipper/Generic.html#line-346" class="link">Source</a></p><div class="doc"><p>Prepare a <code><a href="Quipper.html#t:Qubit">Qubit</a></code> initialized from a <code><a href="Quipper.html#t:Bit">Bit</a></code>. More generally,
 prepare a data structure of Qubits, initialized from a corresponding
 data structure of Bits. Examples:
</p><pre> q &lt;- prepare b
 (q0, q1) &lt;- prepare (b0, b1)
 &#91;q0, q1, q2&#93; &lt;- prepare &#91;b0, b1, b2&#93;
</pre></div></div><div class="top"><p class="src"><a name="v:qc_measure" class="def">qc_measure</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper.html#t:Bit">Bit</a> <a href="Quipper.html#t:Bit">Bit</a> qc)<a href="src/Quipper/Generic.html#line-352" class="link">Source</a></p><div class="doc"><p>Heterogeneous version of <code><a href="Quipper.html#v:measure">measure</a></code>. Given a heterogeneous data
 structure, measure all of its qubits, and leave any classical bits
 unchanged.
</p></div></div><div class="top"><p class="src"><a name="v:qc_prepare" class="def">qc_prepare</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper.html#t:Qubit">Qubit</a> <a href="Quipper.html#t:Qubit">Qubit</a> qc)<a href="src/Quipper/Generic.html#line-361" class="link">Source</a></p><div class="doc"><p>Heterogeneous version of <code><a href="Quipper.html#v:measure">measure</a></code>. Given a heterogeneous data
 structure, prepare qubits from all classical bits, and leave any
 qubits unchanged.
</p></div></div><h2 id="g:7">Gates for classical circuits
</h2><div class="doc"><p>The gates in this section are for constructing classical circuits. 
 None of these gates alter or discard their inputs; each gate produces 
 a new wire holding the output of the gate.
</p></div><div class="top"><p class="src"><a name="v:cgate_xor" class="def">cgate_xor</a> :: &#91;<a href="Quipper.html#t:Bit">Bit</a>&#93; -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Bit">Bit</a><a href="src/Quipper/Monad.html#line-1165" class="link">Source</a></p><div class="doc"><p>Return the &quot;exclusive or&quot; of a list of bits. 
</p></div></div><div class="top"><p class="src"><a name="v:cgate_eq" class="def">cgate_eq</a> :: <a href="Quipper.html#t:Bit">Bit</a> -&gt; <a href="Quipper.html#t:Bit">Bit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Bit">Bit</a><a href="src/Quipper/Monad.html#line-1170" class="link">Source</a></p><div class="doc"><p>Test equality of two bits, and return <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code> iff they are equal. 
</p></div></div><div class="top"><p class="src"><a name="v:cgate_not" class="def">cgate_not</a> :: <a href="Quipper.html#t:Bit">Bit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Bit">Bit</a><a href="src/Quipper/Monad.html#line-1180" class="link">Source</a></p><div class="doc"><p>Return the negation of its input. Note that unlike <code><a href="Quipper.html#v:cnot">cnot</a></code> or
 <code><a href="Quipper.html#v:cnot_at">cnot_at</a></code>, this gate does not alter its input, but returns a newly
 created bit.
</p></div></div><div class="top"><p class="src"><a name="v:cgate_and" class="def">cgate_and</a> :: &#91;<a href="Quipper.html#t:Bit">Bit</a>&#93; -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Bit">Bit</a><a href="src/Quipper/Monad.html#line-1184" class="link">Source</a></p><div class="doc"><p>Return the conjunction of a list of bits.
</p></div></div><div class="top"><p class="src"><a name="v:cgate_or" class="def">cgate_or</a> :: &#91;<a href="Quipper.html#t:Bit">Bit</a>&#93; -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Bit">Bit</a><a href="src/Quipper/Monad.html#line-1188" class="link">Source</a></p><div class="doc"><p>Return the disjunction of a list of bits.
</p></div></div><div class="top"><p class="src"><a name="v:cgate_if" class="def">cgate_if</a> :: <a href="Quipper.html#t:CData">CData</a> ca =&gt; <a href="Quipper.html#t:Bit">Bit</a> -&gt; ca -&gt; ca -&gt; <a href="Quipper.html#t:Circ">Circ</a> ca<a href="src/Quipper/Generic.html#line-542" class="link">Source</a></p><div class="doc"><p>If <em>a</em> is <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code>, return a copy of <em>b</em>, else return a copy of
 <em>c</em>. Here <em>b</em> and <em>c</em> can be any data structures consisting of
 Bits, but <em>b</em> and <em>c</em> must be of the same type and shape (for
 example, if they are lists, they must be of equal
 length). Examples:
</p><pre> output &lt;- cgate_if a b c
 (out0, out1) &lt;- cgate_if a (b0, b1) (c0, c1)
 &#91;out0, out1, out2&#93; &lt;- cgate_if a &#91;b0, b1, b2&#93; &#91;c0, c1, c2&#93;
</pre></div></div><div class="top"><p class="src"><a name="v:circ_if" class="def">circ_if</a> :: <a href="Quipper.html#t:CData">CData</a> ca =&gt; <a href="Quipper.html#t:Bit">Bit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ca -&gt; <a href="Quipper.html#t:Circ">Circ</a> ca -&gt; <a href="Quipper.html#t:Circ">Circ</a> ca<a href="src/Quipper/Generic.html#line-570" class="link">Source</a></p><div class="doc"><p><code><a href="Quipper.html#v:circ_if">circ_if</a></code> is an if-then-else function for classical circuits. 
 It is a wrapper around <code><a href="Quipper.html#v:cgate_if">cgate_if</a></code>, intended to be used like this:
</p><pre> result &lt;- circ_if &lt;&lt;&lt;condition&gt;&gt;&gt; (
   &lt;&lt;then-part&gt;&gt;&gt;
   )(
   &lt;&lt;&lt;else-part&gt;&gt;&gt;
   )
</pre><p>Unlike <code><a href="Quipper.html#v:cgate_if">cgate_if</a></code>, this is a meta-operation, i.e., the bodies of
 the &quot;then&quot; and &quot;else&quot; parts can be circuit building
 operations. 
</p><p>What makes this different from the usual boolean &quot;if-then-else&quot;
 is that the condition is of type <code><a href="Quipper.html#t:Bit">Bit</a></code>, i.e., it is only known at
 circuit execution time. Therefore the generated circuit contains
 <em>both</em> the &quot;then&quot; and &quot;else&quot; parts, suitably
 controlled. Precondition: the &quot;then&quot; and &quot;else&quot; parts must be
 of the same type and shape.
</p></div></div><h2 id="g:8">User-defined gates
</h2><div class="top"><p class="src"><a name="v:named_gate" class="def">named_gate</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa<a href="src/Quipper/Generic.html#line-623" class="link">Source</a></p><div class="doc"><p>Define a new functional-style gate of the given name. Usage:
</p><pre> my_unary_gate :: Qubit -&gt; Circ Qubit
 my_unary_gate = named_gate &quot;Q&quot;
</pre><pre> my_binary_gate :: (Qubit, Qubit) -&gt; Circ (Qubit, Qubit)
 my_binary_gate = named_gate &quot;R&quot;
</pre><p>This defines a new unary gate and a new binary gate, which will be
 rendered as <a href="Q.html">Q</a> and <a href="R.html">R</a>, respectively, in circuit diagrams. 
</p></div></div><div class="top"><p class="src"><a name="v:named_gate_at" class="def">named_gate_at</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Generic.html#line-638" class="link">Source</a></p><div class="doc"><p>Define a new imperative-style gate of the given name. Usage:
</p><pre> my_unary_gate_at :: Qubit -&gt; Circ ()
 my_unary_gate_at = named_gate_at &quot;Q&quot;
</pre><pre> my_binary_gate_at :: (Qubit, Qubit) -&gt; Circ ()
 my_binary_gate_at = named_gate_at &quot;R&quot;
</pre><p>This defines a new unary gate and a new binary gate, which will be
 rendered as <a href="Q.html">Q</a> and <a href="R.html">R</a>, respectively, in circuit diagrams. 
</p></div></div><div class="top"><p class="src"><a name="v:named_rotation" class="def">named_rotation</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; <a href="Quipper.html#t:Timestep">Timestep</a> -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa<a href="src/Quipper/Generic.html#line-654" class="link">Source</a></p><div class="doc"><p>Define a new functional-style gate of the given name, and
 parameterized by a real-valued parameter. This is typically used
 for rotations or phase gates that are parameterized by an angle.
 The name can contain '%' as a place holder for the parameter.
 Usage:
</p><pre> my_unary_gate :: Qubit -&gt; Circ Qubit
 my_unary_gate = named_rotation &quot;exp(-i%Z)&quot; 0.123
</pre><pre> my_binary_gate :: TimeStep -&gt; (Qubit, Qubit) -&gt; Circ (Qubit, Qubit)
 my_binary_gate t = named_rotation &quot;Q(%)&quot; t
</pre></div></div><div class="top"><p class="src"><a name="v:named_rotation_at" class="def">named_rotation_at</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; <a href="Quipper.html#t:Timestep">Timestep</a> -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Generic.html#line-670" class="link">Source</a></p><div class="doc"><p>Define a new imperative-style gate of the given name, and
 parameterized by a real-valued parameter. This is typically used
 for rotations or phase gates that are parameterized by an angle.
 The name can contain '%' as a place holder for the parameter.
 Usage:
</p><pre> my_unary_gate_at :: Qubit -&gt; Circ ()
 my_unary_gate_at = named_rotation &quot;exp(-i%Z)&quot; 0.123
</pre><pre> my_binary_gate_at :: TimeStep -&gt; (Qubit, Qubit) -&gt; Circ ()
 my_binary_gate_at t = named_rotation &quot;Q(%)&quot; t
</pre></div></div><div class="top"><p class="src"><a name="v:extended_named_gate" class="def">extended_named_gate</a> :: (<a href="Quipper.html#t:QData">QData</a> qa, <a href="Quipper.html#t:QData">QData</a> qb) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; qa -&gt; qb -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa<a href="src/Quipper/Generic.html#line-591" class="link">Source</a></p><div class="doc"><p>Define a new functional-style gate of the given name. Like
 <code><a href="Quipper.html#v:named_gate">named_gate</a></code>, except that the generated gate is extended with
 &quot;generalized controls&quot;. The generalized controls are additional
 inputs to the gate that are guaranteed not to be modified if they
 are in a computational basis state. They are rendered in a special
 way in circuit diagrams. Usage:
</p><pre> my_new_gate :: (Qubit,Qubit) -&gt; Qubit -&gt; Circ (Qubit,Qubit)
 my_new_gate = extended_named_gate &quot;Q&quot;
</pre><p>This defines a new gate with name <a href="Q.html">Q</a>, two inputs, and one
 generalized input.
</p></div></div><div class="top"><p class="src"><a name="v:extended_named_gate_at" class="def">extended_named_gate_at</a> :: (<a href="Quipper.html#t:QData">QData</a> qa, <a href="Quipper.html#t:QData">QData</a> qb) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; qa -&gt; qb -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Generic.html#line-604" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper.html#v:extended_named_gate">extended_named_gate</a></code>, except defines an imperative style gate.
 Usage:
</p><pre> my_new_gate_at :: (Qubit,Qubit) -&gt; Qubit -&gt; Circ ()
 my_new_gate_at = extended_named_gate_at &quot;Q&quot;
</pre><p>This defines a new gate with name <a href="Q.html">Q</a>, two inputs, and one
 generalized input.
</p></div></div><h2 id="g:9">Dynamic lifting
</h2><div class="top"><p class="src"><a name="v:dynamic_lift" class="def">dynamic_lift</a> :: <a href="Quipper.html#t:QShape">QShape</a> ba qa ca =&gt; ca -&gt; <a href="Quipper.html#t:Circ">Circ</a> ba<a href="src/Quipper/Generic.html#line-708" class="link">Source</a></p><div class="doc"><p>Convert a <code><a href="Quipper.html#t:Bit">Bit</a></code> (boolean circuit output) to a <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></code> (boolean
 parameter). More generally, convert a data structure of Bits to a
 corresponding data structure of Bools.
</p><p>For use in algorithms that require the output of a measurement to
 be used as a circuit-generation parameter. This is the case, for
 example, for sieving methods, and also for some iterative
 algorithms.
</p><p>Note that this is not a gate, but a meta-operation. The input
 consists of classical circuit endpoints (whose values are known at
 circuit execution time), and the output is a boolean parameter
 (whose value is known at circuit generation time). 
</p><p>The use of this operation implies an interleaving between circuit
 execution and circuit generation. It is therefore a (physically)
 expensive operation and should be used sparingly. Using the
 <code><a href="Quipper.html#v:dynamic_lift">dynamic_lift</a></code> operation interrupts the batch mode operation of the
 quantum device (where circuits are generated ahead of time), and
 forces interactive operation (the quantum device must wait for the
 next portion of the circuit to be generated). This operation is
 especially expensive if the current circuit contains unmeasured
 qubits; in this case, the qubits must be preserved while the
 quantum device remains on standby.
</p><p>Also note that this operation is not supported in all contexts. It
 is an error, for example, to use this operation in a circuit that
 is going to be reversed, or in the body of a boxed subroutine.
 Also, not all output devices (such as circuit viewers) support this
 operation.
</p></div></div><h1 id="g:10">Other circuit-building functions
</h1><div class="top"><p class="src"><a name="v:qinit_plusminus" class="def">qinit_plusminus</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/Monad.html#line-1382" class="link">Source</a></p><div class="doc"><p>Generate a new qubit initialized to |+&#9002; when <em>b</em>=<code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:False">False</a></code> and
 |&#8722;&#9002; when <em>b</em>=<code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:qinit_of_char" class="def">qinit_of_char</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Char.html#t:Char">Char</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/Monad.html#line-1390" class="link">Source</a></p><div class="doc"><p>Generate a new qubit initialized to one of |0&#9002;, |1&#9002;, |+&#9002;, |&#8722;&#9002;,
 depending on a character <em>c</em> which is '0', '1', '+', or '-'.
</p></div></div><div class="top"><p class="src"><a name="v:qinit_of_string" class="def">qinit_of_string</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> &#91;<a href="Quipper.html#t:Qubit">Qubit</a>&#93;<a href="src/Quipper/Monad.html#line-1399" class="link">Source</a></p><div class="doc"><p>Generate a list of qubits initialized to a sequence of |0&#9002;, |1&#9002;,
 |+&#9002;, |&#8722;&#9002;, defined by a string argument e.g. &quot;00+0+++&quot;.
</p></div></div><div class="top"><p class="src"><a name="v:map_hadamard" class="def">map_hadamard</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa<a href="src/Quipper/Generic.html#line-382" class="link">Source</a></p><div class="doc"><p>Apply a Hadamard gate to every qubit in a quantum data structure.
</p></div></div><div class="top"><p class="src"><a name="v:map_hadamard_at" class="def">map_hadamard_at</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Generic.html#line-386" class="link">Source</a></p><div class="doc"><p>Imperative version of <code><a href="Quipper.html#v:map_hadamard">map_hadamard</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:controlled_not" class="def">controlled_not</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qc, qc)<a href="src/Quipper/Generic.html#line-421" class="link">Source</a></p><div class="doc"><p>Apply a controlled-not gate to every corresponding pair of
 quantum or classical bits in two pieces of QCData. The first
 argument is the target and the second the (positive) control.  
</p><p>For now, we require both pieces of QCData to have the same type,
 i.e., classical bits can be controlled only by classical bits and
 quantum bits can be controlled only by quantum bits.
</p><p>Example:
</p><pre> ((a',b'), (x,y)) &lt;- controlled_not (a,b) (x,y)
</pre><p>is equivalent to
</p><pre> a' &lt;- qnot a `controlled` x
 b' &lt;- qnot b `controlled` y
</pre></div></div><div class="top"><p class="src"><a name="v:controlled_not_at" class="def">controlled_not_at</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Generic.html#line-445" class="link">Source</a></p><div class="doc"><p>Imperative version of <code><a href="Quipper.html#v:controlled_not">controlled_not</a></code>. Apply a controlled-not
 gate to every corresponding pair of quantum or classical bits in
 two pieces of QCData. The first argument is the target and the
 second the (positive) control.
</p></div></div><div class="top"><p class="src"><a name="v:bool_controlled_not" class="def">bool_controlled_not</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> qc<a href="src/Quipper/Generic.html#line-456" class="link">Source</a></p><div class="doc"><p>A version of <code><a href="Quipper.html#v:controlled_not">controlled_not</a></code> where the control consists of
 boolean data. Example:
</p><pre> bool_controlled_not (q, r, s) (True, True, False)
</pre><p>negates <em>q</em> and <em>r</em>, but not <em>s</em>.
</p></div></div><div class="top"><p class="src"><a name="v:bool_controlled_not_at" class="def">bool_controlled_not_at</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Generic.html#line-467" class="link">Source</a></p><div class="doc"><p>A version of <code><a href="Quipper.html#v:controlled_not_at">controlled_not_at</a></code> where the control consists of
 boolean data. Example:
</p><pre> bool_controlled_not_at (q, r, s) (True, True, False)
</pre><p>negates <em>q</em> and <em>r</em>, but not <em>s</em>.
</p></div></div><div class="top"><p class="src"><a name="v:qc_copy" class="def">qc_copy</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> qc<a href="src/Quipper/Generic.html#line-513" class="link">Source</a></p><div class="doc"><p>Create a fresh copy of a piece of quantum data. Note: copying is
 performed via a controlled-not operation, and is not cloning. This
 is similar to <code><a href="Quipper.html#v:qc_copy_fun">qc_copy_fun</a></code>, except it returns only the copy, and not
 the original.
</p></div></div><div class="top"><p class="src"><a name="v:qc_uncopy" class="def">qc_uncopy</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Generic.html#line-525" class="link">Source</a></p><div class="doc"><p>&quot;Uncopy&quot; a piece of quantum data; i.e. terminate <em>copy</em>,
 assuming it's a copy of <em>orig</em>. This is the inverse of
 <code><a href="Quipper.html#v:qc_copy">qc_copy</a></code>, in the sense that the following sequence of
 instructions behaves like the identity function:
</p><pre> b &lt;- qc_copy a
 qc_uncopy a b
</pre></div></div><div class="top"><p class="src"><a name="v:qc_copy_fun" class="def">qc_copy_fun</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qc, qc)<a href="src/Quipper/Generic.html#line-492" class="link">Source</a></p><div class="doc"><p>Initialize a new piece of quantum data, as a copy of a given
 piece.  Returns both the original and the copy.
</p></div></div><div class="top"><p class="src"><a name="v:qc_uncopy_fun" class="def">qc_uncopy_fun</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> qc<a href="src/Quipper/Generic.html#line-506" class="link">Source</a></p><div class="doc"><p>Given two pieces of quantum data, assumed equal (w.r.t. the
 computational basis), terminate the second piece (and return the
 first, unmodified). This is the inverse of <code><a href="Quipper.html#v:qc_copy_fun">qc_copy_fun</a></code>, in the sense
 that the following sequence of instructions behaves like the
 identity function:
</p><pre> (orig, copy) &lt;- qc_copy_fun orig
 orig &lt;- qc_uncopy_fun orig copy
</pre></div></div><div class="top"><p class="src"><a name="v:mapUnary" class="def">mapUnary</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; (<a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a>) -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa<a href="src/Quipper/Generic.html#line-715" class="link">Source</a></p><div class="doc"><p>Map a single qubit gate across every qubit in the data structure.
</p></div></div><div class="top"><p class="src"><a name="v:mapBinary" class="def">mapBinary</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; (<a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> (<a href="Quipper.html#t:Qubit">Qubit</a>, <a href="Quipper.html#t:Qubit">Qubit</a>)) -&gt; qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qa, qa)<a href="src/Quipper/Generic.html#line-720" class="link">Source</a></p><div class="doc"><p>Map a binary gate across every corresponding pair of qubits in
 two quantum data structures of equal shape.
</p></div></div><div class="top"><p class="src"><a name="v:mapBinary_c" class="def">mapBinary_c</a> :: <a href="Quipper.html#t:QShape">QShape</a> ba qa ca =&gt; (<a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Bit">Bit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> (<a href="Quipper.html#t:Qubit">Qubit</a>, <a href="Quipper.html#t:Bit">Bit</a>)) -&gt; qa -&gt; ca -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qa, ca)<a href="src/Quipper/Generic.html#line-731" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper.html#v:mapBinary">mapBinary</a></code>, except the second data structure is classical.
</p></div></div><div class="top"><p class="src"><a name="v:qc_mapBinary" class="def">qc_mapBinary</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; (<a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> (<a href="Quipper.html#t:Qubit">Qubit</a>, <a href="Quipper.html#t:Qubit">Qubit</a>)) -&gt; (<a href="Quipper.html#t:Bit">Bit</a> -&gt; <a href="Quipper.html#t:Bit">Bit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> (<a href="Quipper.html#t:Bit">Bit</a>, <a href="Quipper.html#t:Bit">Bit</a>)) -&gt; qc -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qc, qc)<a href="src/Quipper/Generic.html#line-757" class="link">Source</a></p><div class="doc"><p>Heterogeneous version of <code><a href="Quipper.html#v:mapBinary">mapBinary</a></code>. Map a binary gate <em>f</em>
 across every corresponding pair of qubits, and a binary gate <em>g</em>
 across every corresponding pair of bits, in two quantum data
 structures of equal shape.
</p></div></div><h1 id="g:11">Notation for controls
</h1><div class="doc"><p>Some gates can be controlled by a condition involving one of more
 &quot;control&quot; qubits and/or classical bits at circuit execution time.
 Such gates can also be controlled by boolean conditions that are
 known at circuit generation time (in which case the gate will not
 be generated when the control condition is false). This section
 provides a convenient and flexible syntax for specifying controls.
</p><p>In Quipper, controls can be written in a way that is
 reminiscent of (a restricted set of) ordinary boolean
 expressions. Here are some examples:
</p><pre> q1 .==. 0 .&amp;&amp;. q2 .==. 1   for Qubits q1, q2
</pre><pre> q .&amp;&amp;. p                   means  q .==. 1  .&amp;&amp;.  p .==. 1
</pre><pre> qx .==. 5                  for a QDInt qx
</pre><pre> q1 .==. 0 .&amp;&amp;. z &lt;= 7      combines quantum and classical controls
</pre><pre> q ./=. b                   the negation of q .==. b;
                            here b is a boolean.
</pre><pre> &#91;p,q,r,s&#93;                  a list of positive controls
</pre><pre> &#91;(p, True), (q, False), (r, False), (s, True)&#93;
                            a list of positive and negative controls
</pre><p>Among these infix operators, <code>(.&amp;&amp;.)</code> binds more weakly than
 <code>(.==.)</code>, <code>(./=.)</code>.
</p><p>Controls can be attached to a gate by means of the infix
 operator <code><a href="Quipper.html#v:controlled">controlled</a></code>:
</p><pre> gate `controlled` &lt;&lt;controls&gt;&gt;   
</pre></div><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:ControlSource" class="def">ControlSource</a> a  <span class="keyword">where</span><a href="src/Quipper/Control.html#line-215" class="link">Source</a></p><div class="doc"><p>A &quot;control source&quot; is anything that can be used as a control on
 a gate. The most common way to construct a control source is by
 using the <code>.==.</code>, <code>./=.</code>, and <code>.&amp;&amp;.</code> operators. In addition,
 we provide the following instances:
</p><ul><li> <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></code>. A boolean condition that is known at circuit generation
 time can be used as a control, which is then either trivial (the
 gate is generated) or inconsistent (the gate is not generated).
</li><li> <code><a href="Quipper-Circuit.html#t:Wire">Wire</a></code>. This includes the type <code>Bit</code> (for a classical
 execution-time control) and <code>Qubit</code> (for a quantum control). A wire
 can be used as a shorthand notation for a positive control on that
 wire.
</li><li> <code><a href="Quipper.html#t:ControlList">ControlList</a></code>. A control list is Quipper's internal
 representation of a control condition, and is trivially a control
 source.
</li><li> A list of control sources can be used as a control source.
</li></ul></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:to_control" class="def">to_control</a> :: a -&gt; <a href="Quipper.html#t:ControlList">ControlList</a><a href="src/Quipper/Control.html#line-215" class="link">Source</a></p><div class="doc"><p>Convert a condition to a control.
</p></div></div><div class="subs instances"><p id="control.i:ControlSource" class="caption collapser" onclick="toggleSection('i:ControlSource')">Instances</p><div id="section.i:ControlSource" class="show"><table><tr><td class="src"><a href="Quipper.html#t:ControlSource">ControlSource</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:ControlSource">ControlSource</a> ()</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:ControlSource">ControlSource</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:ControlSource">ControlSource</a> <a href="Quipper.html#t:ControlList">ControlList</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:ControlSource">ControlSource</a> <a href="Quipper.html#t:Bit">Bit</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:ControlSource">ControlSource</a> <a href="Quipper.html#t:Qubit">Qubit</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:ControlSource">ControlSource</a> a =&gt; <a href="Quipper.html#t:ControlSource">ControlSource</a> &#91;a&#93;</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:ControlSource">ControlSource</a> (<a href="Quipper.html#t:Signed">Signed</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:ControlSource">ControlSource</a> (<a href="Quipper.html#t:Signed">Signed</a> a), <a href="Quipper.html#t:ControlSource">ControlSource</a> (<a href="Quipper.html#t:Signed">Signed</a> b)) =&gt; <a href="Quipper.html#t:ControlSource">ControlSource</a> (<a href="Quipper.html#t:Signed">Signed</a> (<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:ControlSource">ControlSource</a> (<a href="Quipper.html#t:Signed">Signed</a> <a href="Quipper.html#t:Bit">Bit</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:ControlSource">ControlSource</a> (<a href="Quipper.html#t:Signed">Signed</a> <a href="Quipper.html#t:Qubit">Qubit</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:ControlSource">ControlSource</a> a, <a href="Quipper.html#t:ControlSource">ControlSource</a> b) =&gt; <a href="Quipper.html#t:ControlSource">ControlSource</a> (a, b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:ControlSource">ControlSource</a> a, <a href="Quipper.html#t:ControlSource">ControlSource</a> b) =&gt; <a href="Quipper.html#t:ControlSource">ControlSource</a> (<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:ControlSource">ControlSource</a> a, <a href="Quipper.html#t:ControlSource">ControlSource</a> b, <a href="Quipper.html#t:ControlSource">ControlSource</a> c) =&gt; <a href="Quipper.html#t:ControlSource">ControlSource</a> (a, b, c)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:ControlSource">ControlSource</a> a, <a href="Quipper.html#t:ControlSource">ControlSource</a> b, <a href="Quipper.html#t:ControlSource">ControlSource</a> c, <a href="Quipper.html#t:ControlSource">ControlSource</a> d) =&gt; <a href="Quipper.html#t:ControlSource">ControlSource</a> (a, b, c, d)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:ControlSource">ControlSource</a> a, <a href="Quipper.html#t:ControlSource">ControlSource</a> b, <a href="Quipper.html#t:ControlSource">ControlSource</a> c, <a href="Quipper.html#t:ControlSource">ControlSource</a> d, <a href="Quipper.html#t:ControlSource">ControlSource</a> e) =&gt; <a href="Quipper.html#t:ControlSource">ControlSource</a> (a, b, c, d, e)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:ControlSource">ControlSource</a> a, <a href="Quipper.html#t:ControlSource">ControlSource</a> b, <a href="Quipper.html#t:ControlSource">ControlSource</a> c, <a href="Quipper.html#t:ControlSource">ControlSource</a> d, <a href="Quipper.html#t:ControlSource">ControlSource</a> e, <a href="Quipper.html#t:ControlSource">ControlSource</a> f) =&gt; <a href="Quipper.html#t:ControlSource">ControlSource</a> (a, b, c, d, e, f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:ControlSource">ControlSource</a> a, <a href="Quipper.html#t:ControlSource">ControlSource</a> b, <a href="Quipper.html#t:ControlSource">ControlSource</a> c, <a href="Quipper.html#t:ControlSource">ControlSource</a> d, <a href="Quipper.html#t:ControlSource">ControlSource</a> e, <a href="Quipper.html#t:ControlSource">ControlSource</a> f, <a href="Quipper.html#t:ControlSource">ControlSource</a> g) =&gt; <a href="Quipper.html#t:ControlSource">ControlSource</a> (a, b, c, d, e, f, g)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:ControlList" class="def">ControlList</a>  <a href="src/Quipper/Control.html#line-48" class="link">Source</a></p><div class="doc"><p>A <code><a href="Quipper.html#t:ControlList">ControlList</a></code> is Quipper's internal representation of the type
 of conjunctive controls, i.e., controls that can be constructed
 using the <code>.==.</code>, <code>./=.</code>, and <code>.&amp;&amp;.</code> operators.
</p></div><div class="subs instances"><p id="control.i:ControlList" class="caption collapser" onclick="toggleSection('i:ControlList')">Instances</p><div id="section.i:ControlList" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Quipper.html#t:ControlList">ControlList</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:ControlSource">ControlSource</a> <a href="Quipper.html#t:ControlList">ControlList</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:.-38--38-." class="def">(.&amp;&amp;.)</a> :: (<a href="Quipper.html#t:ControlSource">ControlSource</a> a, <a href="Quipper.html#t:ControlSource">ControlSource</a> b) =&gt; a -&gt; b -&gt; <a href="Quipper.html#t:ControlList">ControlList</a><a href="src/Quipper/Generic.html#line-943" class="link">Source</a></p><div class="doc"><p>This is an infix operator to concatenate two controls, forming
 their logical conjunction.
</p></div></div><div class="top"><p class="src"><a name="v:.-61--61-." class="def">(.==.)</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qc -&gt; <a href="Quipper.html#t:ControlList">ControlList</a><a href="src/Quipper/Generic.html#line-947" class="link">Source</a></p><div class="doc"><p><code>(qx .==. x)</code>: a control which is true just if quantum data <em>qx</em> is in the specified state <em>x</em>. 
</p></div></div><div class="top"><p class="src"><a name="v:.-47--61-." class="def">(./=.)</a> :: <a href="Quipper-QData.html#t:QCLeaf">QCLeaf</a> q =&gt; q -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Quipper.html#t:ControlList">ControlList</a><a href="src/Quipper/Generic.html#line-955" class="link">Source</a></p><div class="doc"><p>The notation <code>(q ./=. x)</code> is shorthand for <code>(q .==. not x)</code>, when
 <em>x</em> is a boolean parameter. 
</p><p>Unlike <code><a href="Quipper.html#v:.-61--61-.">.==.</a></code>, which is defined for any shape of quantum data,
 <code><a href="Quipper.html#v:.-47--61-.">./=.</a></code> is only defined for a single control bit or qubit.
</p></div></div><div class="top"><p class="src"><a name="v:controlled" class="def">controlled</a> :: <a href="Quipper.html#t:ControlSource">ControlSource</a> c =&gt; <a href="Quipper.html#t:Circ">Circ</a> a -&gt; c -&gt; <a href="Quipper.html#t:Circ">Circ</a> a<a href="src/Quipper/Monad.html#line-1485" class="link">Source</a></p><div class="doc"><p>An infix operator to apply the given controls to a gate:
</p><pre> gate `controlled` &lt;&lt;controls&gt;&gt;
</pre><p>It also works with functional-style gates:
</p><pre> result &lt;- gate `controlled` &lt;&lt;controls&gt;&gt;
</pre><p>The infix operator is left associative, so it can be applied
 multiple times:
</p><pre> result &lt;- gate `controlled` &lt;&lt;controls1&gt;&gt; `controlled` &lt;&lt;controls2&gt;&gt;
</pre><p>The latter is equivalent to
</p><pre> result &lt;- gate `controlled` &lt;&lt;controls1&gt;&gt; .&amp;&amp;. &lt;&lt;controls2&gt;&gt;
</pre></div></div><h1 id="g:12">Signed items
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Signed" class="def">Signed</a> a <a href="src/Quipper/Circuit.html#line-64" class="link">Source</a></p><div class="doc"><p>A signed item of type <em>a</em>. <code><a href="Quipper.html#t:Signed">Signed</a></code> <em>x</em> <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code> represents a
 positive item, and <code><a href="Quipper.html#t:Signed">Signed</a></code> <em>x</em> <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:False">False</a></code> represents a negative item.
</p><p>When used with wires in a circuit, a positive sign is used to
 represent a positive control, i.e., a filled dot, and a negative
 sign is used to represent a negative control, i.e., an empty dot.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Signed" class="def">Signed</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Signed" class="caption collapser" onclick="toggleSection('i:Signed')">Instances</p><div id="section.i:Signed" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Typeable-Internal.html#t:Typeable1">Typeable1</a> <a href="Quipper.html#t:Signed">Signed</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> a =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Quipper.html#t:Signed">Signed</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:ControlSource">ControlSource</a> (<a href="Quipper.html#t:Signed">Signed</a> <a href="Quipper-Circuit.html#t:Wire">Wire</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:ControlSource">ControlSource</a> (<a href="Quipper.html#t:Signed">Signed</a> a), <a href="Quipper.html#t:ControlSource">ControlSource</a> (<a href="Quipper.html#t:Signed">Signed</a> b)) =&gt; <a href="Quipper.html#t:ControlSource">ControlSource</a> (<a href="Quipper.html#t:Signed">Signed</a> (<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:ControlSource">ControlSource</a> (<a href="Quipper.html#t:Signed">Signed</a> <a href="Quipper.html#t:Bit">Bit</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:ControlSource">ControlSource</a> (<a href="Quipper.html#t:Signed">Signed</a> <a href="Quipper.html#t:Qubit">Qubit</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:QCData">QCData</a> a =&gt; <a href="Quipper.html#t:QCData">QCData</a> (<a href="Quipper.html#t:Signed">Signed</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:Labelable">Labelable</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (<a href="Quipper.html#t:Signed">Signed</a> a) <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:Labelable">Labelable</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (<a href="Quipper.html#t:Signed">Signed</a> a) (<a href="Quipper.html#t:Signed">Signed</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:from_signed" class="def">from_signed</a> ::  <a href="Quipper.html#t:Signed">Signed</a> a -&gt; a<a href="src/Quipper/Circuit.html#line-68" class="link">Source</a></p><div class="doc"><p>Extract the underlying item of a signed item.
</p></div></div><div class="top"><p class="src"><a name="v:get_sign" class="def">get_sign</a> ::  <a href="Quipper.html#t:Signed">Signed</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a><a href="src/Quipper/Circuit.html#line-73" class="link">Source</a></p><div class="doc"><p>Extract the sign of a signed item: <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code> is positive, and
 <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:False">False</a></code> is negative.
</p></div></div><h1 id="g:13">Comments and labelling
</h1><div class="top"><p class="src"><a name="v:comment" class="def">comment</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Labels.html#line-350" class="link">Source</a></p><div class="doc"><p>Insert a comment in the circuit. This is not a gate, and has no
 effect, except to mark a spot in the circuit. How the comment is
 displayed depends on the printing backend.
</p></div></div><div class="top"><p class="src"><a name="v:label" class="def">label</a> :: <a href="Quipper.html#t:Labelable">Labelable</a> qa labels =&gt; qa -&gt; labels -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Labels.html#line-373" class="link">Source</a></p><div class="doc"><p>Label qubits in the circuit. This is not a gate, and has no
 effect, except to make the circuit more readable. How the labels
 are displayed depends on the printing backend. This can take
 several different forms. Examples:
</p><p>Label <em>q</em> as <code>q</code> and <em>r</em> as <code>r</code>:
</p><pre> label (q,r) (&quot;q&quot;, &quot;r&quot;)
</pre><p>Label <em>a</em>, <em>b</em>, and <em>c</em> as <code>a</code>, <code>b</code>, and <code>c</code>, respectively:
</p><pre> label &#91;a,b,c&#93; &#91;&quot;a&quot;, &quot;b&quot;, &quot;c&quot;&#93;
</pre><p>Label <em>q</em> as <code>x&#91;0&#93;</code> and <em>r</em> as <code>x&#91;1&#93;</code>:
</p><pre> label (q,r) &quot;x&quot;
</pre><p>Label <em>a</em>, <em>b</em>, and <em>c</em> as <code>x&#91;0&#93;</code>, <code>x&#91;1&#93;</code>, <code>x&#91;2&#93;</code>:
</p><pre> label &#91;a,b,c&#93; &quot;x&quot;
</pre></div></div><div class="top"><p class="src"><a name="v:comment_with_label" class="def">comment_with_label</a> :: <a href="Quipper.html#t:Labelable">Labelable</a> qa labels =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; qa -&gt; labels -&gt; <a href="Quipper.html#t:Circ">Circ</a> ()<a href="src/Quipper/Labels.html#line-377" class="link">Source</a></p><div class="doc"><p>Combine <code><a href="Quipper.html#v:comment">comment</a></code> and <code><a href="Quipper.html#v:label">label</a></code> in a single command.
</p></div></div><div class="top"><p class="src"><a name="v:without_comments" class="def">without_comments</a> ::  <a href="Quipper.html#t:Circ">Circ</a> a -&gt; <a href="Quipper.html#t:Circ">Circ</a> a<a href="src/Quipper/Monad.html#line-1331" class="link">Source</a></p><div class="doc"><p>Disable labels and comments for a block of code. The intended
 usage is like this:
</p><pre> without_comments $ do {
   &lt;&lt;&lt;code block&gt;&gt;&gt;
 }
</pre><p>This is sometimes useful in situations where code is being re-used,
 for example when one function is implemented in terms of another,
 but should not inherit comments from it. It is also useful in the
 definition of recursive function, where a comment should only be
 applied at the outermost level. Finally, it can be used to suppress
 comments from parts of circuits for presentation purposes.
</p></div></div><div class="top"><p class="src"><span class="keyword">class</span>  <a name="t:Labelable" class="def">Labelable</a> a s <a href="src/Quipper/Labels.html#line-164" class="link">Source</a></p><div class="doc"><p><code><a href="Quipper.html#t:Labelable">Labelable</a></code> <em>a</em> <em>s</em> means that <em>a</em> is a data structure that can
 be labelled with the format <em>s</em>. A &quot;format&quot; is a string, or a
 data structure with strings at the leaves.
</p></div><div class="subs instances"><p id="control.i:Labelable" class="caption collapser" onclick="toggleSection('i:Labelable')">Instances</p><div id="section.i:Labelable" class="show"><table><tr><td class="src"><a href="Quipper.html#t:Labelable">Labelable</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Char.html#t:Char">Char</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:Labelable">Labelable</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:Labelable">Labelable</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Float">Float</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:Labelable">Labelable</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:Labelable">Labelable</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:Labelable">Labelable</a> () <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:Labelable">Labelable</a> () ()</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:Labelable">Labelable</a> <a href="Quipper.html#t:Bit">Bit</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:Labelable">Labelable</a> <a href="Quipper.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:Labelable">Labelable</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> &#91;a&#93; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:Labelable">Labelable</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (<a href="Quipper.html#t:Signed">Signed</a> a) <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:Labelable">Labelable</a> a s =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> &#91;a&#93; &#91;s&#93;</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:Labelable">Labelable</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (<a href="Quipper.html#t:Signed">Signed</a> a) (<a href="Quipper.html#t:Signed">Signed</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> b <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (a, b) <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> b <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b) <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a sa, <a href="Quipper.html#t:Labelable">Labelable</a> b sb) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (a, b) (sa, sb)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a s, <a href="Quipper.html#t:Labelable">Labelable</a> b t) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b) (<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> s t)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> b <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> c <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (a, b, c) <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a sa, <a href="Quipper.html#t:Labelable">Labelable</a> b sb, <a href="Quipper.html#t:Labelable">Labelable</a> c sc) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (a, b, c) (sa, sb, sc)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> b <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> c <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> d <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (a, b, c, d) <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a sa, <a href="Quipper.html#t:Labelable">Labelable</a> b sb, <a href="Quipper.html#t:Labelable">Labelable</a> c sc, <a href="Quipper.html#t:Labelable">Labelable</a> d sd) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (a, b, c, d) (sa, sb, sc, sd)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> b <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> c <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> d <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> e <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (a, b, c, d, e) <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a sa, <a href="Quipper.html#t:Labelable">Labelable</a> b sb, <a href="Quipper.html#t:Labelable">Labelable</a> c sc, <a href="Quipper.html#t:Labelable">Labelable</a> d sd, <a href="Quipper.html#t:Labelable">Labelable</a> e se) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (a, b, c, d, e) (sa, sb, sc, sd, se)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> b <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> c <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> d <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> e <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> f <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (a, b, c, d, e, f) <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a sa, <a href="Quipper.html#t:Labelable">Labelable</a> b sb, <a href="Quipper.html#t:Labelable">Labelable</a> c sc, <a href="Quipper.html#t:Labelable">Labelable</a> d sd, <a href="Quipper.html#t:Labelable">Labelable</a> e se, <a href="Quipper.html#t:Labelable">Labelable</a> f sf) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (a, b, c, d, e, f) (sa, sb, sc, sd, se, sf)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> b <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> c <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> d <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> e <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> f <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> g <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (a, b, c, d, e, f, g) <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a sa, <a href="Quipper.html#t:Labelable">Labelable</a> b sb, <a href="Quipper.html#t:Labelable">Labelable</a> c sc, <a href="Quipper.html#t:Labelable">Labelable</a> d sd, <a href="Quipper.html#t:Labelable">Labelable</a> e se, <a href="Quipper.html#t:Labelable">Labelable</a> f sf, <a href="Quipper.html#t:Labelable">Labelable</a> g sg) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (a, b, c, d, e, f, g) (sa, sb, sc, sd, se, sf, sg)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> b <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> c <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> d <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> e <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> f <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> g <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> h <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (a, b, c, d, e, f, g, h) <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a sa, <a href="Quipper.html#t:Labelable">Labelable</a> b sb, <a href="Quipper.html#t:Labelable">Labelable</a> c sc, <a href="Quipper.html#t:Labelable">Labelable</a> d sd, <a href="Quipper.html#t:Labelable">Labelable</a> e se, <a href="Quipper.html#t:Labelable">Labelable</a> f sf, <a href="Quipper.html#t:Labelable">Labelable</a> g sg, <a href="Quipper.html#t:Labelable">Labelable</a> h sh) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (a, b, c, d, e, f, g, h) (sa, sb, sc, sd, se, sf, sg, sh)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> b <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> c <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> d <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> e <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> f <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> g <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> h <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> i <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (a, b, c, d, e, f, g, h, i) <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a sa, <a href="Quipper.html#t:Labelable">Labelable</a> b sb, <a href="Quipper.html#t:Labelable">Labelable</a> c sc, <a href="Quipper.html#t:Labelable">Labelable</a> d sd, <a href="Quipper.html#t:Labelable">Labelable</a> e se, <a href="Quipper.html#t:Labelable">Labelable</a> f sf, <a href="Quipper.html#t:Labelable">Labelable</a> g sg, <a href="Quipper.html#t:Labelable">Labelable</a> h sh, <a href="Quipper.html#t:Labelable">Labelable</a> i si) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (a, b, c, d, e, f, g, h, i) (sa, sb, sc, sd, se, sf, sg, sh, si)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> b <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> c <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> d <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> e <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> f <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> g <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> h <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> i <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> j <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (a, b, c, d, e, f, g, h, i, j) <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a sa, <a href="Quipper.html#t:Labelable">Labelable</a> b sb, <a href="Quipper.html#t:Labelable">Labelable</a> c sc, <a href="Quipper.html#t:Labelable">Labelable</a> d sd, <a href="Quipper.html#t:Labelable">Labelable</a> e se, <a href="Quipper.html#t:Labelable">Labelable</a> f sf, <a href="Quipper.html#t:Labelable">Labelable</a> g sg, <a href="Quipper.html#t:Labelable">Labelable</a> h sh, <a href="Quipper.html#t:Labelable">Labelable</a> i si, <a href="Quipper.html#t:Labelable">Labelable</a> j sj) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (a, b, c, d, e, f, g, h, i, j) (sa, sb, sc, sd, se, sf, sg, sh, si, sj)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h1 id="g:14">Hierarchical circuits
</h1><div class="top"><p class="src"><a name="v:box" class="def">box</a> :: (<a href="Quipper.html#t:QCData">QCData</a> qa, <a href="Quipper.html#t:QCData">QCData</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qa_qb qa qb) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; qa_qb -&gt; qa_qb<a href="src/Quipper/Generic.html#line-1540" class="link">Source</a></p><div class="doc"><p>A generic interface for wrapping a circuit-generating function
 into a boxed and named subroutine. This takes a name and a
 circuit-generating function, and returns a new circuit-generating
 function of the same type, but which inserts a boxed subroutine
 instead of the actual body of the subroutine.
</p><p>It is intended to be used like this:
</p><pre> somefunc :: Qubit -&gt; Circ Qubit
 somefunc a = do ...
 
 somefunc_boxed :: Qubit -&gt; Circ Qubit
 somefunc_boxed = box &quot;somefunc&quot; somefunc
</pre><p>Here, the type of <code>somefunc</code> is just an example; this could indeed
 be a function with any number and type of arguments, as long as the
 arguments and return type are quantum data.
</p><p>It is also possible to inline the <code><a href="Quipper.html#v:box">box</a></code> operator directly, in which
 case it should be done like this:
</p><pre> somefunc :: Qubit -&gt; Circ Qubit
 somefunc = box &quot;somefunc&quot; $ \a -&gt; do ...
</pre><p>Note: The <code><a href="Quipper.html#v:box">box</a></code> operator wraps around a complete function,
 including all of its arguments. It would be incorrect to apply the
 <code><a href="Quipper.html#v:box">box</a></code> operator after some quantum variables have already been
 defined. Thus, the following is incorrect:
</p><pre> incorrect_somefunc :: Qubit -&gt; Circ Qubit
 incorrect_somefunc a = box &quot;somefunc&quot; $ do ...
</pre><p>It is the user's responsibility not to use the same name for
 different subroutines. If <code><a href="Quipper.html#v:box">box</a></code> is called more than once with the
 same name and shape of input, Quipper assumes, without checking,
 that they are subsequent calls to the same subroutine. 
</p><p>The type of the <code><a href="Quipper.html#v:box">box</a></code> operator is overloaded and quite difficult to
 read.  It can have for example the following types:
</p><pre> box :: String -&gt; (Qubit -&gt; Circ Qubit) -&gt; (Qubit -&gt; Circ Qubit)
 box :: String -&gt; (QDInt -&gt; QDInt -&gt; Circ (QDInt,QDInt,QDInt)) -&gt; (QDInt -&gt; QDInt -&gt; Circ (QDInt,QDInt,QDInt))
</pre></div></div><div class="top"><p class="src"><a name="v:nbox" class="def">nbox</a> :: <a href="Quipper.html#t:QCData">QCData</a> qa =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; (qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa) -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa<a href="src/Quipper/Generic.html#line-1551" class="link">Source</a></p><div class="doc"><p>A version of <code><a href="Quipper.html#v:box">box</a></code> with iteration. The second argument is an
 iteration count.
</p><p>This can only be applied to functions of a single argument, where
 the input and output types are the same.
</p></div></div><div class="top"><p class="src"><a name="v:box_loopM" class="def">box_loopM</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integral">Integral</a> int, <a href="Quipper.html#t:QCData">QCData</a> qa) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; int -&gt; qa -&gt; (qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa) -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa<a href="src/Quipper/Generic.html#line-1557" class="link">Source</a></p><div class="doc"><p>A version of <code><a href="Quipper.html#v:nbox">nbox</a></code> with same type as <code><a href="Quipper.html#v:loopM">loopM</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:loopM_boxed_if" class="def">loopM_boxed_if</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integral">Integral</a> int, <a href="Quipper.html#t:QCData">QCData</a> qa) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; int -&gt; qa -&gt; (qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa) -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa<a href="src/Quipper/Generic.html#line-1567" class="link">Source</a></p><div class="doc"><p>A version of <code><a href="Quipper.html#v:loopM">loopM</a></code> that will be boxed conditionally on a
 boolean condition. Typical usage:
</p><pre> loopM_boxed_if (s &gt; 1) &quot;name&quot; s x $ \x -&gt; do
   &lt;&lt;&lt;body&gt;&gt;&gt;
   return x
</pre></div></div><h1 id="g:15">Block structure
</h1><div class="doc"><p>The following are higher-order functions that provide a way to
 structure quantum programs into blocks. A block can contain local
 ancillas or local controls.
</p></div><h2 id="g:16">Ancillas
</h2><div class="doc"><p>The use of the <code><a href="Quipper.html#v:with_ancilla">with_ancilla</a></code> family of operators is
 preferable to using <code><a href="Quipper.html#v:qinit">qinit</a></code> and <code><a href="Quipper.html#v:qterm">qterm</a></code> directly. In particular, it
 is possible to add controls to a block created with one of the
 <code><a href="Quipper.html#v:with_ancilla">with_ancilla</a></code> family of operators, whereas <code><a href="Quipper.html#v:qinit">qinit</a></code> and <code><a href="Quipper.html#v:qterm">qterm</a></code>,
 when used individually, cannot be controlled.
</p></div><div class="top"><p class="src"><a name="v:with_ancilla" class="def">with_ancilla</a> ::  (<a href="Quipper.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> a) -&gt; <a href="Quipper.html#t:Circ">Circ</a> a<a href="src/Quipper/Monad.html#line-1439" class="link">Source</a></p><div class="doc"><p>Convenient wrapper around <code>qinit</code> and <code>qterm</code>. This can be used
 to introduce an ancilla with a local scope, like this:
</p><pre> with_ancilla $ \h -&gt; do {
   &lt;&lt;&lt;code block using ancilla h&gt;&gt;&gt;
 }
</pre><p>The ancilla will be initialized to |0&#9002; at the beginning of the
 block, and it is the programmer's responsibility to ensure that it
 will be returned to state |0&#9002; at the end of the block.
</p><p>A block created with <code><a href="Quipper.html#v:with_ancilla">with_ancilla</a></code> is controllable, provided that
 the body is controllable.
</p></div></div><div class="top"><p class="src"><a name="v:with_ancilla_list" class="def">with_ancilla_list</a> ::  <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; (<a href="Quipper.html#t:Qulist">Qulist</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> a) -&gt; <a href="Quipper.html#t:Circ">Circ</a> a<a href="src/Quipper/Generic.html#line-1345" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper.html#v:with_ancilla">with_ancilla</a></code>, but creates a list of <em>n</em> ancillas, all
 initialized to |0&#9002;. Usage:
</p><pre> with_ancilla_list n $ \a -&gt; do {
   &lt;&lt;&lt;code block using list of ancillas a&gt;&gt;&gt;
 }
</pre></div></div><div class="top"><p class="src"><a name="v:with_ancilla_init" class="def">with_ancilla_init</a> :: <a href="Quipper.html#t:QShape">QShape</a> a qa ca =&gt; a -&gt; (qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> b) -&gt; <a href="Quipper.html#t:Circ">Circ</a> b<a href="src/Quipper/Generic.html#line-1332" class="link">Source</a></p><div class="doc"><p>Execute a block with local ancillas. Opens a block, initializing an ancilla with a specified classical value, and terminates it with the same value when the block closes. Note: it is the programmer's responsibility to return the ancilla to its original state at the end of the enclosed block. Usage:
</p><pre> with_ancilla_init True $ \a -&gt; do {
   &lt;&lt;&lt;code block using ancilla a initialized to True&gt;&gt;&gt;
 }
</pre><pre> with_ancilla_init &#91;True,False,True&#93; $ \a -&gt; do {
   &lt;&lt;&lt;code block using list of ancillas a initialized to &#91;True,False,True&#93;&gt;&gt;&gt;
 }
</pre></div></div><h2 id="g:17">Automatic uncomputing
</h2><div class="top"><p class="src"><a name="v:with_computed_fun" class="def">with_computed_fun</a> :: (<a href="Quipper.html#t:QCData">QCData</a> x, <a href="Quipper.html#t:QCData">QCData</a> y) =&gt; x -&gt; (x -&gt; <a href="Quipper.html#t:Circ">Circ</a> y) -&gt; (y -&gt; <a href="Quipper.html#t:Circ">Circ</a> (y, b)) -&gt; <a href="Quipper.html#t:Circ">Circ</a> (x, b)<a href="src/Quipper/Generic.html#line-1353" class="link">Source</a></p><div class="doc"><p><code><code><a href="Quipper.html#v:with_computed_fun">with_computed_fun</a></code> <em>x</em> <em>f</em> <em>g</em></code>: computes <em>x' := f(x)</em>; then computes <em>g(x')</em>, which should be organized as a pair <em>(x',y)</em>; then uncomputes <em>x'</em> back to <em>x</em>, and returns <em>(x,y)</em>.
</p><p>Important subtlety in usage: all quantum data referenced in <em>f</em>, even as controls, must be explicitly bound and returned by <em>f</em>, or the reversing may rebind it incorrectly.  <em>g</em>, on the other hand, can safely refer to anything that is in scope outside the <code><a href="Quipper.html#v:with_computed_fun">with_computed_fun</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:with_computed" class="def">with_computed</a> :: <a href="Quipper.html#t:QCData">QCData</a> x =&gt; <a href="Quipper.html#t:Circ">Circ</a> x -&gt; (x -&gt; <a href="Quipper.html#t:Circ">Circ</a> b) -&gt; <a href="Quipper.html#t:Circ">Circ</a> b<a href="src/Quipper/Generic.html#line-1386" class="link">Source</a></p><div class="doc"><p><code><code><a href="Quipper.html#v:with_computed">with_computed</a></code> <em>computation</em> <em>code</em></code>: performs <em>computation</em>
 (with result <em>x</em>), then performs <em>code</em> <em>x</em>, and finally performs
 the reverse of <em>computation</em>, for example like this:
</p><p><img src="images/with_computed.png">
</p><p>Both <em>computation</em> and <em>code</em> may refer to any qubits that exist in
 the current environment, and they may also create new
 qubits. <em>computation</em> may produce arbitrary garbage in addition to
 its output. 
</p><p>This is a very general but relatively unsafe operation. It is the
 user's responsibility to ensure that the computation can indeed be
 undone. In particular, if <em>computation</em> contains any
 initializations, then <em>code</em> must ensure that the corresponding
 assertions will be satisfied in <em>computation</em><sup>&#8722;1</sup>.
</p><p>Related more specialized, but potentially safer, operations are: 
</p><ul><li> <code><a href="Quipper.html#v:with_basis_change">with_basis_change</a></code>, which is like <code><a href="Quipper.html#v:with_computed">with_computed</a></code>, but assumes
 that <em>computation</em> is unitary, and
</li><li> <code>classical_to_reversible</code>, which assumes that <em>computation</em> is
 classical (or pseudo-classical), and <em>code</em> is a simple
 copy-by-controlled-not operation.
</li></ul></div></div><div class="top"><p class="src"><a name="v:with_basis_change" class="def">with_basis_change</a> ::  <a href="Quipper.html#t:Circ">Circ</a> () -&gt; <a href="Quipper.html#t:Circ">Circ</a> b -&gt; <a href="Quipper.html#t:Circ">Circ</a> b<a href="src/Quipper/Generic.html#line-1413" class="link">Source</a></p><div class="doc"><p><code><code><a href="Quipper.html#v:with_basis_change">with_basis_change</a></code> <em>basischange</em> <em>code</em></code>: performs a basis change,
 then the <em>code</em>, then the inverse of the basis change. Both
 <em>basischange</em> and <em>code</em> are in imperative style. It is the user's
 responsibility to ensure that the image of <em>code</em> is contained in
 the image of <em>basischange</em>, or else there will be unmet assertions
 or runtime errors. Usage:
</p><pre> with_basis_change basischange $ do
   &lt;&lt;&lt;code&gt;&gt;&gt;

 where
   basischange = do
     &lt;&lt;&lt;gates&gt;&gt;&gt;
</pre></div></div><h2 id="g:18">Controls
</h2><div class="top"><p class="src"><a name="v:with_controls" class="def">with_controls</a> :: <a href="Quipper.html#t:ControlSource">ControlSource</a> c =&gt; c -&gt; <a href="Quipper.html#t:Circ">Circ</a> a -&gt; <a href="Quipper.html#t:Circ">Circ</a> a<a href="src/Quipper/Monad.html#line-1460" class="link">Source</a></p><div class="doc"><p>A syntax for &quot;if&quot;-style (classical and quantum) controls. 
 This can be used as follows:
</p><pre> gate1
 with_controls &lt;&lt;controls&gt;&gt; $ do {
   gate2
   gate3
 }
 gate4
</pre><p>The specified controls will be applied to gate2 and gate3. It is an
 error to specify a control for a gate that cannot be controlled
 (such as measurement).
</p></div></div><div class="top"><p class="src"><a name="v:with_classical_control" class="def">with_classical_control</a> :: <a href="Quipper.html#t:QCData">QCData</a> qa =&gt; <a href="Quipper.html#t:Bit">Bit</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> -&gt; qa -&gt; (qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa) -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa<a href="src/Quipper/Generic.html#line-1587" class="link">Source</a></p><div class="doc"><p>Classical control on a function with same shape of input and
 output: if the control bit is true the function is fired, otherwise
 the identity map is used.
 Note: the constraint on the types is dynamically checked.
</p></div></div><div class="top"><p class="src"><a name="v:without_controls" class="def">without_controls</a> ::  <a href="Quipper.html#t:Circ">Circ</a> a -&gt; <a href="Quipper.html#t:Circ">Circ</a> a<a href="src/Quipper/Monad.html#line-1529" class="link">Source</a></p><div class="doc"><p>Apply a block of gates while temporarily suspending the
 application of controls.  This can be used to omit controls on
 gates where they are known to be unnecessary. This is a relatively
 low-level function and should not normally be called directly by
 user code. Instead, it is safer to use a higher-level function such
 as <code>with_basis_change</code>. However, the <code><a href="Quipper.html#v:without_controls">without_controls</a></code> operator is
 useful in certain situations, e.g., it can be used to preserve the
 <code><a href="Quipper.html#t:NoControlFlag">NoControlFlag</a></code> when defining transformers.
</p><p>Usage:
</p><pre> without_controls $ do 
   &lt;&lt;code block&gt;&gt;
</pre><p>or:
</p><pre> without_controls (gate)
</pre><p>Note that all controls specified in the <em>surrounding</em> code are
 disabled within the <code><a href="Quipper.html#v:without_controls">without_controls</a></code> block. This is even true if
 the <code><a href="Quipper.html#v:without_controls">without_controls</a></code> block appears in a subroutine, and the
 subroutine is later called in a controlled context. On the other
 hand, it is possible to specify controls <em>inside</em> the
 <code><a href="Quipper.html#v:without_controls">without_controls</a></code> block. Consider this example:
</p><pre> my_subcircuit = do
   gate1
   without_controls $ do {
     gate2
     gate3 `controlled` &lt;&lt;controls1&gt;&gt;
   }
   gate4

 my_circuit = do
   my_subcircuit `controlled` &lt;&lt;controls2&gt;&gt;
</pre><p>In this example, controls 1 will be applied to gate 3, controls 2
 will be applied to gates 1 and 4, and no controls will be applied
 to gate 2.
</p></div></div><div class="top"><p class="src"><a name="v:without_controls_if" class="def">without_controls_if</a> ::  <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> -&gt; <a href="Quipper.html#t:Circ">Circ</a> a -&gt; <a href="Quipper.html#t:Circ">Circ</a> a<a href="src/Quipper/Monad.html#line-1542" class="link">Source</a></p><div class="doc"><p>Apply <code><a href="Quipper.html#v:without_controls">without_controls</a></code> if <code><a href="Quipper.html#t:NoControlFlag">NoControlFlag</a></code> is <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code>, otherwise
 do nothing.
</p></div></div><h2 id="g:19">Loops
</h2><div class="top"><p class="src"><a name="v:for" class="def">for</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; m ()) -&gt; m ()<a href="src/Libraries/Auxiliary.html#line-546" class="link">Source</a></p><div class="doc"><p>A &quot;for&quot; loop. Counts from <em>a</em> to <em>b</em> in increments of <em>s</em>.
</p><p>Standard notation: 
</p><pre> for i = a to b by s do
   commands             
 end for
</pre><p>Our notation: 
</p><pre> for a b s $ \i -&gt; do
   commands
 endfor
</pre></div></div><div class="top"><p class="src"><a name="v:endfor" class="def">endfor</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; m ()<a href="src/Libraries/Auxiliary.html#line-558" class="link">Source</a></p><div class="doc"><p>Mark the end of a &quot;for&quot;-loop. This command actually does
 nothing, but can be used to make the loop look prettier.
</p></div></div><div class="top"><p class="src"><a name="v:foreach" class="def">foreach</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; &#91;a&#93; -&gt; (a -&gt; m b) -&gt; m ()<a href="src/Libraries/Auxiliary.html#line-570" class="link">Source</a></p><div class="doc"><p>Iterate a parameter over a list of values. It can be used as
 follows:
</p><pre> foreach &#91;1,2,3,4&#93; $ \n -&gt; do
   &lt;&lt;&lt;loop body depending on the parameter n&gt;&gt;&gt;
 endfor
</pre><p>The loop body will get executed once for each <em>n</em> &#8712; {1,2,3,4}.
</p></div></div><div class="top"><p class="src"><a name="v:loop" class="def">loop</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> int, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Num">Num</a> int) =&gt; int -&gt; t -&gt; (t -&gt; t) -&gt; t<a href="src/Libraries/Auxiliary.html#line-394" class="link">Source</a></p><div class="doc"><p>Iterate a function <em>n</em> times. Example: 
</p><pre> loop 3 x f = f (f (f x))
</pre></div></div><div class="top"><p class="src"><a name="v:loop_with_index" class="def">loop_with_index</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> int, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Num">Num</a> int) =&gt; int -&gt; t -&gt; (int -&gt; t -&gt; t) -&gt; t<a href="src/Libraries/Auxiliary.html#line-367" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper.html#v:loop">loop</a></code>, but also pass a loop counter to the function being
 iterated. Example:
</p><pre> loop_with_index 3 x f = f 2 (f 1 (f 0 x))
</pre></div></div><div class="top"><p class="src"><a name="v:loopM" class="def">loopM</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> int, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Num">Num</a> int, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m) =&gt; int -&gt; t -&gt; (t -&gt; m t) -&gt; m t<a href="src/Libraries/Auxiliary.html#line-398" class="link">Source</a></p><div class="doc"><p>Monadic version of <code><a href="Quipper.html#v:loop">loop</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:loop_with_indexM" class="def">loop_with_indexM</a> :: (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> int, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Num">Num</a> int, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m) =&gt; int -&gt; t -&gt; (int -&gt; t -&gt; m t) -&gt; m t<a href="src/Libraries/Auxiliary.html#line-383" class="link">Source</a></p><div class="doc"><p>Monadic version of <code><a href="Quipper.html#v:loop_with_index">loop_with_index</a></code>. Thus, 
</p><pre> loop_with_indexM 3 x0 f
</pre><p>will do the following:
</p><pre> do
   x1 &lt;- f 0 x0
   x2 &lt;- f 1 x1
   x3 &lt;- f 2 x2    
   return x3
</pre></div></div><h1 id="g:20">Operations on circuits
</h1><h2 id="g:21">Reversing
</h2><div class="top"><p class="src"><a name="v:reverse_generic" class="def">reverse_generic</a> :: (<a href="Quipper.html#t:QCData">QCData</a> x, <a href="Quipper.html#t:QCData">QCData</a> y, <a href="Libraries-Tuple.html#t:TupleOrUnary">TupleOrUnary</a> xt x, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> x_y x y, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> x_y_xt x (y -&gt; <a href="Quipper.html#t:Circ">Circ</a> xt)) =&gt; x_y -&gt; x_y_xt<a href="src/Quipper/Generic.html#line-1084" class="link">Source</a></p><div class="doc"><p>Reverse a circuit-generating function. The reversed function
 requires a shape parameter, given as the input type of the original
 function.
</p><p>The type of this highly overloaded function is quite difficult to
 read.  It can have for example the following types:
</p><pre> reverse_generic :: (QCData x, QCData y) =&gt; (x -&gt; Circ y) -&gt; x -&gt; (y -&gt; Circ x) 
 reverse_generic :: (QCData x, QCData y, QCData z) =&gt; (x -&gt; y -&gt; Circ z) -&gt; x -&gt; y -&gt; (z -&gt; Circ (x,y)) 
</pre></div></div><div class="top"><p class="src"><a name="v:reverse_simple" class="def">reverse_simple</a> :: (<a href="Quipper-QData.html#t:QCData_Simple">QCData_Simple</a> x, <a href="Quipper.html#t:QCData">QCData</a> y, <a href="Libraries-Tuple.html#t:TupleOrUnary">TupleOrUnary</a> xt x, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> x_y x y) =&gt; x_y -&gt; y -&gt; <a href="Quipper.html#t:Circ">Circ</a> xt<a href="src/Quipper/Generic.html#line-1124" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper.html#v:reverse_generic">reverse_generic</a></code>, but only works at simple types, and
 therefore requires no shape parameters.  Typical type instances:
</p><pre> reverse_simple :: (QCData_Simple x, QCData y) =&gt; (x -&gt; Circ y) -&gt; (y -&gt; Circ x)
 reverse_simple :: (QCData_Simple x, QCData_Simple y, QCData z) =&gt; (x -&gt; y -&gt; Circ z) -&gt; (z -&gt; Circ (x,y))
</pre></div></div><div class="top"><p class="src"><a name="v:reverse_generic_endo" class="def">reverse_generic_endo</a> :: (<a href="Quipper.html#t:QCData">QCData</a> x, <a href="Libraries-Tuple.html#t:TupleOrUnary">TupleOrUnary</a> xt x, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> x_xt x xt) =&gt; x_xt -&gt; x_xt<a href="src/Quipper/Generic.html#line-1152" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper.html#v:reverse_generic">reverse_generic</a></code>, but specialized to endomorphic circuits,
 i.e., circuits where the input and output have the same type (modulo
 possibly currying) and shape. In this case, unlike <code><a href="Quipper.html#v:reverse_generic">reverse_generic</a></code>,
 no additional shape parameter is required, and the reversed function
 is curried if the original function was.  Typical type instances:
</p><pre> reverse_generic_endo :: (QCData x) =&gt; (x -&gt; Circ x) -&gt; (x -&gt; Circ x)
 reverse_generic_endo :: (QCData x, QCData y) =&gt; (x -&gt; y -&gt; Circ (x,y)) -&gt; (x -&gt; y -&gt; Circ (x,y))
</pre></div></div><div class="top"><p class="src"><a name="v:reverse_generic_imp" class="def">reverse_generic_imp</a> :: (<a href="Quipper.html#t:QCData">QCData</a> x, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> x__ x ()) =&gt; x__ -&gt; x__<a href="src/Quipper/Generic.html#line-1164" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper.html#v:reverse_generic_endo">reverse_generic_endo</a></code>, but applies to endomorphic circuits
 expressed in &quot;imperative&quot; style. Typical type instances:
</p><pre> reverse_generic_endo :: (QCData x) =&gt; (x -&gt; Circ ()) -&gt; (x -&gt; Circ ())
 reverse_generic_endo :: (QCData x, QCData y) =&gt; (x -&gt; y -&gt; Circ ()) -&gt; (x -&gt; y -&gt; Circ ())
</pre></div></div><div class="top"><p class="src"><a name="v:reverse_generic_curried" class="def">reverse_generic_curried</a> :: (<a href="Quipper.html#t:QCData">QCData</a> x, <a href="Quipper.html#t:QCData">QCData</a> y, <a href="Libraries-Tuple.html#t:TupleOrUnary">TupleOrUnary</a> xt x, <a href="Libraries-Tuple.html#t:Tuple">Tuple</a> yt y, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> x_yt x yt, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> y_xt y xt, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> x_y_xt x y_xt) =&gt; x_yt -&gt; x_y_xt<a href="src/Quipper/Generic.html#line-1107" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper.html#v:reverse_generic">reverse_generic</a></code>, but takes functions whose output is a
 tuple, and curries the reversed function.  Differs from
 <code><a href="Quipper.html#v:reverse_generic">reverse_generic</a></code> in an example such as:
</p><pre> f                         :: (x -&gt; y -&gt; Circ (z,w))
 reverse_generic f         :: x -&gt; y -&gt; ((z,w) -&gt; Circ (x,y))
 reverse_generic_curried f :: x -&gt; y -&gt; (z -&gt; w -&gt; Circ (x,y))
</pre><p>Note: the output <em>must</em> be a <em>n</em>-tuple, where <em>n</em> = 0 or <em>n</em> &#8805;
 2. Applying this to a circuit whose output is a non-tuple type is a
 type error; in this case, <code><a href="Quipper.html#v:reverse_generic">reverse_generic</a></code> should be used.
</p></div></div><div class="top"><p class="src"><a name="v:reverse_simple_curried" class="def">reverse_simple_curried</a> :: (<a href="Quipper-QData.html#t:QCData_Simple">QCData_Simple</a> x, <a href="Quipper.html#t:QCData">QCData</a> y, <a href="Libraries-Tuple.html#t:TupleOrUnary">TupleOrUnary</a> xt x, <a href="Libraries-Tuple.html#t:Tuple">Tuple</a> yt y, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> x_yt x yt, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> y_xt y xt) =&gt; x_yt -&gt; y_xt<a href="src/Quipper/Generic.html#line-1137" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper.html#v:reverse_simple">reverse_simple</a></code>, but takes functions whose output is a
 tuple, and curries the reversed function. Typical type instance:
</p><pre> reverse_simple_curried :: (QCData_Simple x, QCData y, QCData z) =&gt; (x -&gt; Circ (y,z)) -&gt; (y -&gt; z -&gt; Circ x)
</pre><p>Note: the output <em>must</em> be a <em>n</em>-tuple, where <em>n</em> = 0 or <em>n</em> &#8805;
 2. Applying this to a circuit whose output is a non-tuple type is a
 type error; in this case, <code><a href="Quipper.html#v:reverse_generic">reverse_generic</a></code> should be used.
</p></div></div><div class="top"><p class="src"><a name="v:reverse_endo_if" class="def">reverse_endo_if</a> :: (<a href="Quipper.html#t:QCData">QCData</a> x, <a href="Libraries-Tuple.html#t:TupleOrUnary">TupleOrUnary</a> xt x, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> x_xt x xt) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; x_xt -&gt; x_xt<a href="src/Quipper/Generic.html#line-1176" class="link">Source</a></p><div class="doc"><p>Conditional version of <code><a href="Quipper.html#v:reverse_generic_endo">reverse_generic_endo</a></code>. Invert the
 endomorphic quantum circuit if the boolean is true; otherwise,
 insert the non-inverted circuit.
</p></div></div><div class="top"><p class="src"><a name="v:reverse_imp_if" class="def">reverse_imp_if</a> :: (<a href="Quipper.html#t:QCData">QCData</a> qa, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> fun qa ()) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; fun -&gt; fun<a href="src/Quipper/Generic.html#line-1183" class="link">Source</a></p><div class="doc"><p>Conditional version of <code><a href="Quipper.html#v:reverse_generic_imp">reverse_generic_imp</a></code>. Invert the
 imperative style quantum circuit if the boolean is true; otherwise,
 insert the non-inverted circuit.
</p></div></div><h2 id="g:22">Printing
</h2><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Format" class="def">Format</a>  <a href="src/Quipper/Printing.html#line-1597" class="link">Source</a></p><div class="doc"><p>Available output formats.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:EPS" class="def">EPS</a></td><td class="doc"><p>Encapsulated PostScript graphics.
</p></td></tr><tr><td class="src"><a name="v:PDF" class="def">PDF</a></td><td class="doc"><p>Portable Document Format. One circuit per page.
</p></td></tr><tr><td class="src"><a name="v:PS" class="def">PS</a></td><td class="doc"><p>PostScript. One circuit per page.
</p></td></tr><tr><td class="src"><a name="v:ASCII" class="def">ASCII</a></td><td class="doc"><p>A textual representation of circuits.
</p></td></tr><tr><td class="src"><a name="v:Preview" class="def">Preview</a></td><td class="doc"><p>Don't print anything, but preview directly on screen (requires the external program <em>acroread</em>).
</p></td></tr><tr><td class="src"><a name="v:GateCount" class="def">GateCount</a></td><td class="doc"><p>Print statistics on gate counts.
</p></td></tr><tr><td class="src"><a name="v:CustomStyle" class="def">CustomStyle</a> <a href="Quipper.html#t:FormatStyle">FormatStyle</a></td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:Format" class="caption collapser" onclick="toggleSection('i:Format')">Instances</p><div id="section.i:Format" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Quipper.html#t:Format">Format</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:FormatStyle" class="def">FormatStyle</a>  <a href="src/Quipper/Printing.html#line-367" class="link">Source</a></p><div class="doc"><p>A data type that holds all the customizable parameters.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:FormatStyle" class="def">FormatStyle</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:renderformat" class="def">renderformat</a> :: <a href="Libraries-Render.html#t:RenderFormat">RenderFormat</a></dt><dd class="doc"><p>The RenderFormat to use.
</p></dd><dt class="src"><a name="v:backgroundcolor" class="def">backgroundcolor</a> :: <a href="Libraries-Render.html#t:Color">Color</a></dt><dd class="doc"><p>The color of the background.
</p></dd><dt class="src"><a name="v:foregroundcolor" class="def">foregroundcolor</a> :: <a href="Libraries-Render.html#t:Color">Color</a></dt><dd class="doc"><p>The color of the foreground (e.g. wires and gates).
</p></dd><dt class="src"><a name="v:linewidth" class="def">linewidth</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></dt><dd class="doc"><p>Line width.
</p></dd><dt class="src"><a name="v:coffs" class="def">coffs</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></dt><dd class="doc"><p>Gap for double line representing classical bit.
</p></dd><dt class="src"><a name="v:dotradius" class="def">dotradius</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></dt><dd class="doc"><p>Radius of dots for &quot;controlled&quot; gates.
</p></dd><dt class="src"><a name="v:oplusradius" class="def">oplusradius</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></dt><dd class="doc"><p>Radius of oplus for &quot;not&quot; gate.
</p></dd><dt class="src"><a name="v:xoff" class="def">xoff</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></dt><dd class="doc"><p>Horizontal column width.
</p></dd><dt class="src"><a name="v:gatepad" class="def">gatepad</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></dt><dd class="doc"><p>Difference between width of box and width of label.
</p></dd><dt class="src"><a name="v:gateheight" class="def">gateheight</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></dt><dd class="doc"><p>Height of labelled box.
</p></dd><dt class="src"><a name="v:crossradius" class="def">crossradius</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></dt><dd class="doc"><p>Width and height of &quot;cross&quot; for swap gate.
</p></dd><dt class="src"><a name="v:stringbase" class="def">stringbase</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></dt><dd class="doc"><p>Vertical shift for text labels.
</p></dd><dt class="src"><a name="v:barwidth" class="def">barwidth</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></dt><dd class="doc"><p>Width of &quot;bar&quot; bar.
</p></dd><dt class="src"><a name="v:barheight" class="def">barheight</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></dt><dd class="doc"><p>Height of &quot;bar&quot; bar.
</p></dd><dt class="src"><a name="v:dwidth" class="def">dwidth</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></dt><dd class="doc"><p>Width of &quot;D&quot; symbol.
</p></dd><dt class="src"><a name="v:dheight" class="def">dheight</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></dt><dd class="doc"><p>Height of &quot;D&quot; symbol.
</p></dd><dt class="src"><a name="v:maxgatelabelwidth" class="def">maxgatelabelwidth</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></dt><dd class="doc"><p>Maximal width of a gate label.
</p></dd><dt class="src"><a name="v:maxlabelwidth" class="def">maxlabelwidth</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></dt><dd class="doc"><p>Maximal width of a wire label.
</p></dd><dt class="src"><a name="v:maxnumberwidth" class="def">maxnumberwidth</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></dt><dd class="doc"><p>Maximal width of a wire number.
</p></dd><dt class="src"><a name="v:gatefont" class="def">gatefont</a> :: <a href="Libraries-Render.html#t:Font">Font</a></dt><dd class="doc"><p>Font to use for labels on gates.
</p></dd><dt class="src"><a name="v:commentfont" class="def">commentfont</a> :: <a href="Libraries-Render.html#t:Font">Font</a></dt><dd class="doc"><p>Font to use for comments.
</p></dd><dt class="src"><a name="v:commentcolor" class="def">commentcolor</a> :: <a href="Libraries-Render.html#t:Color">Color</a></dt><dd class="doc"><p>Color to use for comments.
</p></dd><dt class="src"><a name="v:labelfont" class="def">labelfont</a> :: <a href="Libraries-Render.html#t:Font">Font</a></dt><dd class="doc"><p>Font to use for labels.
</p></dd><dt class="src"><a name="v:labelcolor" class="def">labelcolor</a> :: <a href="Libraries-Render.html#t:Color">Color</a></dt><dd class="doc"><p>Color to use for labels.
</p></dd><dt class="src"><a name="v:numberfont" class="def">numberfont</a> :: <a href="Libraries-Render.html#t:Font">Font</a></dt><dd class="doc"><p>Font to use for numbers.
</p></dd><dt class="src"><a name="v:numbercolor" class="def">numbercolor</a> :: <a href="Libraries-Render.html#t:Color">Color</a></dt><dd class="doc"><p>Color to use for numbers.
</p></dd><dt class="src"><a name="v:subroutineshape" class="def">subroutineshape</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></dt><dd class="doc"><p>Whether to label each subroutine call with shape parameters
</p></dd></dl><div class="clear"></div></div></td></tr></table></div><div class="subs instances"><p id="control.i:FormatStyle" class="caption collapser" onclick="toggleSection('i:FormatStyle')">Instances</p><div id="section.i:FormatStyle" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> <a href="Quipper.html#t:FormatStyle">FormatStyle</a></td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><a name="v:format_enum" class="def">format_enum</a> :: &#91;(<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Format">Format</a>)&#93;<a href="src/Quipper/Printing.html#line-1609" class="link">Source</a></p><div class="doc"><p>A mapping from lower-case strings (to be used, e.g., with command
 line options) to available formats.
</p></div></div><div class="top"><p class="src"><a name="v:print_unary" class="def">print_unary</a> :: <a href="Quipper.html#t:QCData">QCData</a> qa =&gt; <a href="Quipper.html#t:Format">Format</a> -&gt; (qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> b) -&gt; qa -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ()<a href="src/Quipper/Printing.html#line-1656" class="link">Source</a></p><div class="doc"><p>Print a circuit generating function to the specified format; this
 requires a shape parameter.
</p></div></div><div class="top"><p class="src"><a name="v:print_generic" class="def">print_generic</a> :: (<a href="Quipper.html#t:QCData">QCData</a> qa, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa b, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> fun qa (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ())) =&gt; <a href="Quipper.html#t:Format">Format</a> -&gt; qfun -&gt; fun<a href="src/Quipper/Printing.html#line-1675" class="link">Source</a></p><div class="doc"><p>Print a circuit generating function to the specified
 format. Unlike <code><a href="Quipper.html#v:print_unary">print_unary</a></code>, this can be applied to a
 circuit-generating function in curried form with <em>n</em> arguments, for
 any <em>n &gt;= 0</em>. It then requires <em>n</em> shape parameters.
</p><p>The type of this heavily overloaded function is difficult to
 read. In more readable form, it has all of the following types:
</p><pre> print_generic :: Format -&gt; Circ qa -&gt; IO ()
 print_generic :: (QCData qa) =&gt; Format -&gt; (qa -&gt; Circ qb) -&gt; a -&gt; IO ()
 print_generic :: (QCData qa, QCData qb) =&gt; Format -&gt; (qa -&gt; qb -&gt; Circ qc) -&gt; a -&gt; b -&gt; IO ()
</pre><p>and so forth.
</p></div></div><div class="top"><p class="src"><a name="v:print_simple" class="def">print_simple</a> :: (<a href="Quipper.html#t:QCData">QCData</a> qa, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa b, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> fun qa (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ()), <a href="Quipper-QData.html#t:QCData_Simple">QCData_Simple</a> qa) =&gt; <a href="Quipper.html#t:Format">Format</a> -&gt; qfun -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ()<a href="src/Quipper/Printing.html#line-1684" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper.html#v:print_generic">print_generic</a></code>, but only works at simple types, and
 therefore requires no shape parameters.
</p></div></div><div class="top"><p class="src"><a name="v:print_of_document" class="def">print_of_document</a> ::  <a href="Quipper.html#t:Format">Format</a> -&gt; <a href="Libraries-Render.html#t:Document">Document</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> a<a href="src/Quipper/Printing.html#line-1633" class="link">Source</a></p><div class="doc"><p>Print a document to the requested format, which must be one of
 <code><a href="Quipper.html#v:PS">PS</a></code>, <code><a href="Quipper.html#v:PDF">PDF</a></code>, <code><a href="Quipper.html#v:EPS">EPS</a></code>, or <code><a href="Quipper.html#v:Preview">Preview</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:print_of_document_custom" class="def">print_of_document_custom</a> ::  <a href="Libraries-Render.html#t:Custom">Custom</a> -&gt; <a href="Quipper.html#t:Format">Format</a> -&gt; <a href="Libraries-Render.html#t:Document">Document</a> a -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> a<a href="src/Quipper/Printing.html#line-1638" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper.html#v:print_of_document">print_of_document</a></code>, but also takes a <code><a href="Libraries-Render.html#t:Custom">Custom</a></code> data
 structure.
</p></div></div><h2 id="g:23">Classical circuits  
</h2><div class="top"><p class="src"><a name="v:classical_to_cnot" class="def">classical_to_cnot</a> :: (<a href="Quipper.html#t:QCData">QCData</a> qa, <a href="Quipper.html#t:QCData">QCData</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb) =&gt; qfun -&gt; qfun<a href="src/Quipper/Classical.html#line-81" class="link">Source</a></p><div class="doc"><p>Translate all classical gates in a circuit into equivalent
 controlled-not gates.
</p><p>The type of this overloaded function is difficult to read. In more
 readable form, it has all of the following types:
</p><pre> classical_to_cnot :: (QCData qa) =&gt; Circ qa -&gt; Circ qa
 classical_to_cnot :: (QCData qa, QCData qb) =&gt; (qa -&gt; Circ qb) -&gt; (qa -&gt; Circ qb)
 classical_to_cnot :: (QCData qa, QCData qb, QCData qc) =&gt; (qa -&gt; qb -&gt; Circ qc) -&gt; (qa -&gt; qb -&gt; Circ qc)
</pre><p>and so forth.  
</p></div></div><div class="top"><p class="src"><a name="v:classical_to_quantum" class="def">classical_to_quantum</a> :: (<a href="Quipper.html#t:QCData">QCData</a> qa, <a href="Quipper.html#t:QCData">QCData</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun' (<a href="Quipper-QData.html#t:QType">QType</a> qa) (<a href="Quipper-QData.html#t:QType">QType</a> qb)) =&gt; qfun -&gt; qfun'<a href="src/Quipper/Classical.html#line-212" class="link">Source</a></p><div class="doc"><p>Replace all classical gates in a circuit by equivalent quantum gates.
</p><p>The type of this overloaded function is difficult to read. In more
 readable form, it has all of the following types:
</p><pre> classical_to_quantum :: (QCData qa) =&gt; Circ qa -&gt; Circ (QType qa)
 classical_to_quantum :: (QCData qa, QCData qb) =&gt; (qa -&gt; Circ qb) -&gt; (QType qa -&gt; Circ (QType qb))
 classical_to_quantum :: (QCData qa, QCData qb, QCData qc) =&gt; (qa -&gt; qb -&gt; Circ qc) -&gt; (QType qa -&gt; QType qb -&gt; Circ (QType qc))
</pre><p>and so forth.  
</p></div></div><h2 id="g:24">Ancilla uncomputation
</h2><div class="top"><p class="src"><a name="v:classical_to_reversible" class="def">classical_to_reversible</a> :: (<a href="Quipper.html#t:QCData">QCData</a> qa, <a href="Quipper.html#t:QCData">QCData</a> qb) =&gt; (qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qb) -&gt; (qa, qb) -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qa, qb)<a href="src/Quipper/Classical.html#line-231" class="link">Source</a></p><div class="doc"><p>Generic function for turning a classical (or pseudo-classical)
 circuit into a reversible circuit. The input is a classical boolean
 function <em>x</em> &#8614; <em>f</em>(<em>x</em>), given as a not necessarily reversible
 circuit (however, the circuit should be one-to-one, i.e., no
 &quot;garbage&quot; should be explicitly erased). The output is the
 corresponding reversible function (<em>x</em>,<em>y</em>) &#8614; (<em>x</em>,<em>y</em> &#8853;
 <em>f</em>(<em>x</em>)). <em>qa</em> and <em>qb</em> can be any quantum data types. The
 function <code><a href="Quipper.html#v:classical_to_reversible">classical_to_reversible</a></code> does not itself change
 classical bits to qubits; use <code><a href="Quipper.html#v:classical_to_quantum">classical_to_quantum</a></code> for that.
</p></div></div><h1 id="g:25">Circuit transformers
</h1><div class="doc"><p>Transformers are a very general way of defining mappings over
 circuits. Possible uses of this include:
</p><ul><li> gate transformations, where a whole circuit is transformed by
 replacing each kind of gate with another gate or circuit;
</li><li> error correcting codes, where a whole circuit is transformed
 replacing each qubit by some fixed number of qubits, and each gate
 by a circuit; and
</li><li> simulations, where a whole circuit is mapped to a semantic
 function by specifying a semantic function for each gate.
</li></ul><p>The interface is designed to allow the programmer to specify new
 transformers easily. To define a specific transformation, the
 programmer has to specify only three pieces of information:
</p><ul><li> Types <em>a</em>=&#10214;Qubit&#10215; and <em>b</em>=&#10214;Bit&#10215;, to serve as semantic domains.
</li><li> A monad <em>m</em>. This is to allow translations to have side effects
 if desired; one can use the identity monad otherwise.
</li><li> For every gate <em>G</em>, a corresponding semantic function &#10214;<em>G</em>&#10215;.  The
 type of this function depends on what kind of gate <em>G</em> is. For example:
</li></ul><pre>
 If <em>G</em> :: Qubit -&gt; Circ Qubit, then &#10214;<em>G</em>&#10215; :: <em>a</em> -&gt; <em>m</em> <em>a</em>. 
 If <em>G</em> :: (Qubit, Bit) -&gt; Circ (Bit, Bit), then &#10214;<em>G</em>&#10215; :: (<em>a</em>, <em>b</em>) -&gt; <em>m</em> (<em>b</em>, <em>b</em>).
</pre><p>The programmer provides this information by defining a function of
 type <code><a href="Quipper.html#t:Transformer">Transformer</a></code> <em>m</em> <em>a</em> <em>b</em>, see below. Once a
 particular transformer has been defined, it can then be applied to
 entire circuits. For example, for a circuit with 1 inputs and 2
 outputs:
</p><pre>
 If <em>C</em> :: Qubit -&gt; (Qubit, Qubit), then &#10214;<em>C</em>&#10215; :: <em>a</em> -&gt; <em>m</em> (<em>a</em>, <em>a</em>).
</pre></div><h2 id="g:26">User-definable transformers
</h2><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Transformer" class="def">Transformer</a> m a b = <span class="keyword">forall</span> x.  <a href="Quipper.html#t:T_Gate">T_Gate</a> m a b x -&gt; x<a href="src/Quipper/Transformer.html#line-360" class="link">Source</a></p><div class="doc"><p>A circuit transformer is specified by defining a function of type
 <code><a href="Quipper.html#t:Transformer">Transformer</a></code> <em>m</em> <em>a</em> <em>b</em>. This involves specifying a monad <em>m</em>,
 semantic domains <em>a</em>=&#10214;Qubit&#10215; and <em>b</em>=&#10214;Bit&#10215;, and a semantic function
 for each gate, like this:
</p><pre> my_transformer :: Transformer m a b
 my_transformer (T_Gate1 &lt;parameters&gt; f) = f $ &lt;semantic function for gate 1&gt;
 my_transformer (T_Gate2 &lt;parameters&gt; f) = f $ &lt;semantic function for gate 2&gt;
 my_transformer (T_Gate3 &lt;parameters&gt; f) = f $ &lt;semantic function for gate 3&gt;
 ...
</pre></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:T_Gate" class="def">T_Gate</a> m a b x <a href="src/Quipper/Transformer.html#line-298" class="link">Source</a></p><div class="doc"><p>The type <code><a href="Quipper.html#t:T_Gate">T_Gate</a></code> is used to define case distinctions over gates
 in the definition of transformers. For each kind of gate <em>X</em>, it
 contains a constructor of the form <code>(T_X f)</code>. Here, <em>X</em> identifies
 the gate, and <em>f</em> is a higher-order function to pass the
 translation of <em>X</em> to.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:T_QGate" class="def">T_QGate</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="Quipper.html#t:InverseFlag">InverseFlag</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((&#91;a&#93; -&gt; &#91;a&#93; -&gt; <a href="Quipper.html#t:Ctrls">Ctrls</a> a b -&gt; m (&#91;a&#93;, &#91;a&#93;, <a href="Quipper.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_QRot" class="def">T_QRot</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="Quipper.html#t:InverseFlag">InverseFlag</a> <a href="Quipper.html#t:Timestep">Timestep</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((&#91;a&#93; -&gt; &#91;a&#93; -&gt; <a href="Quipper.html#t:Ctrls">Ctrls</a> a b -&gt; m (&#91;a&#93;, &#91;a&#93;, <a href="Quipper.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_GPhase" class="def">T_GPhase</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((&#91;<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b&#93; -&gt; <a href="Quipper.html#t:Ctrls">Ctrls</a> a b -&gt; m (<a href="Quipper.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_CNot" class="def">T_CNot</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((b -&gt; <a href="Quipper.html#t:Ctrls">Ctrls</a> a b -&gt; m (b, <a href="Quipper.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_CGate" class="def">T_CGate</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((&#91;b&#93; -&gt; m (b, &#91;b&#93;)) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_CGateInv" class="def">T_CGateInv</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((b -&gt; &#91;b&#93; -&gt; m &#91;b&#93;) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_CSwap" class="def">T_CSwap</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((b -&gt; b -&gt; <a href="Quipper.html#t:Ctrls">Ctrls</a> a b -&gt; m (b, b, <a href="Quipper.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_QPrep" class="def">T_QPrep</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((b -&gt; m a) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_QUnprep" class="def">T_QUnprep</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((a -&gt; m b) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_QInit" class="def">T_QInit</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> (m a -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_CInit" class="def">T_CInit</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> (m b -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_QTerm" class="def">T_QTerm</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((a -&gt; m ()) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_CTerm" class="def">T_CTerm</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> ((b -&gt; m ()) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_QMeas" class="def">T_QMeas</a> ((a -&gt; m b) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_QDiscard" class="def">T_QDiscard</a> ((a -&gt; m ()) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_CDiscard" class="def">T_CDiscard</a> ((b -&gt; m ()) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_DTerm" class="def">T_DTerm</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> ((b -&gt; m ()) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_Subroutine" class="def">T_Subroutine</a> <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> <a href="Quipper.html#t:InverseFlag">InverseFlag</a> <a href="Quipper.html#t:NoControlFlag">NoControlFlag</a> <a href="Quipper-Circuit.html#t:ControllableFlag">ControllableFlag</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:Arity">Arity</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:Arity">Arity</a> <a href="Quipper-Circuit.html#t:RepeatFlag">RepeatFlag</a> ((<a href="Quipper-Circuit.html#t:Namespace">Namespace</a> -&gt; &#91;<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b&#93; -&gt; <a href="Quipper.html#t:Ctrls">Ctrls</a> a b -&gt; m (&#91;<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b&#93;, <a href="Quipper.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_Comment" class="def">T_Comment</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper.html#t:InverseFlag">InverseFlag</a> ((&#91;(<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>)&#93; -&gt; m ()) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:T_Gate" class="caption collapser" onclick="toggleSection('i:T_Gate')">Instances</p><div id="section.i:T_Gate" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Quipper.html#t:T_Gate">T_Gate</a> m a b x)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:27">Pre-defined transformers
</h2><div class="top"><p class="src"><a name="v:identity_transformer" class="def">identity_transformer</a> :: <a href="Quipper.html#t:Transformer">Transformer</a> <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a> <a href="Quipper.html#t:Bit">Bit</a><a href="src/Quipper/Monad.html#line-1570" class="link">Source</a></p><div class="doc"><p>The identity transformer. This just maps a low-level circuits to
 the corresponding circuit-generating function. It can also be used
 as a building block in other transformers, to define &quot;catch-all&quot;
 clauses for gates that don't need to be transformed.
</p></div></div><h2 id="g:28">An example transformer
</h2><div class="doc"><p>The following is a short but complete example of how to write and
 use a simple transformer. As usual, we start by importing Quipper:
</p><pre> import Quipper
</pre><p>We will write a transformer called <code>sample_transformer</code>, which maps
 every swap gate to a sequence of three controlled-not gates, and
 leaves all other gates unchanged. For convenience, Quipper
 pre-defines an <code><a href="Quipper.html#v:identity_transformer">identity_transformer</a></code>, which can be used as a
 catch-all clause to take care of all the gates that don't need to
 be rewritten.
</p><pre> mytransformer :: Transformer Circ Qubit Bit
 mytransformer (T_QGate &quot;swap&quot; 2 0 _ ncf f) = f $
   \&#91;q0, q1&#93; &#91;&#93; ctrls -&gt; do
     without_controls_if ncf $ do
       with_controls ctrls $ do
         qnot_at q0 `controlled` q1
         qnot_at q1 `controlled` q0
         qnot_at q0 `controlled` q1
         return (&#91;q0, q1&#93;, &#91;&#93;, ctrls)
 mytransformer g = identity_transformer g
</pre><p>Note how Quipper syntax has been used to define the replacement
 circuit <code>new_swap</code>, consisting of three controlled-not gates. Also,
 since the original swap gate may have been controlled, we have
 added the additional controls with a <code><a href="Quipper.html#v:with_controls">with_controls</a></code>
 operator. Finally, the <code><a href="Quipper.html#v:without_controls_if">without_controls_if</a></code> operator ensures that
 if the <code><a href="Quipper.html#t:NoControlFlag">NoControlFlag</a></code> is set on the original swap gate, then it
 will also be set on the replacement circuit.
</p><p>To try this out, we define some random circuit using swap gates:
</p><pre> mycirc a b c d = do
   swap_at a b
   hadamard_at b
   swap_at b c `controlled` &#91;a, d&#93;
   hadamard_at c
   swap_at c d
</pre><p>To apply the transformer to this circuit, we use the generic
 operator <code><a href="Quipper.html#v:transform_generic">transform_generic</a></code>:
</p><pre> mycirc2 = transform_generic mytransformer mycirc
</pre><p>Finally, we use a <code>main</code> function to display the original circuit
 and then the transformed one:
</p><pre> main = do
   print_simple Preview mycirc
   print_simple Preview mycirc2
</pre></div><h2 id="g:29">Applying transformers to circuits
</h2><div class="top"><p class="src"><a name="v:transform_generic" class="def">transform_generic</a> :: (<a href="Quipper.html#t:QCData">QCData</a> x, <a href="Quipper.html#t:QCData">QCData</a> y, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun x y) =&gt; <a href="Quipper.html#t:Transformer">Transformer</a> <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a> <a href="Quipper.html#t:Bit">Bit</a> -&gt; qfun -&gt; qfun<a href="src/Quipper/Generic.html#line-1312" class="link">Source</a></p><div class="doc"><p>Apply the given transformer to a circuit.  Unlike
 <code><a href="Quipper-Generic.html#v:transform_unary">transform_unary</a></code>, this function can be applied to a
 circuit-generating function in curried form with <em>n</em> arguments, for
 any <em>n</em> &#8805; 0.
</p><p>The type of this heavily overloaded function is difficult to
 read. In more readable form, it has all of the following types:
</p><pre> transform_generic :: (QCData x) =&gt; Transformer Circ Qubit Bit -&gt; Circ x -&gt; Circ x
 transform_generic :: (QCData x, QCData y) =&gt; Transformer Circ Qubit Bit -&gt; (x -&gt; Circ y) -&gt; (x -&gt; Circ y)
 transform_generic :: (QCData x, QCData y, QCData z) =&gt; Transformer Circ Qubit Bit -&gt; (x -&gt; y -&gt; Circ z) -&gt; (x -&gt; y -&gt; Circ z)
</pre><p>and so forth.
</p></div></div><div class="top"><p class="src"><a name="v:transform_generic_shape" class="def">transform_generic_shape</a> :: (<a href="Quipper.html#t:QCData">QCData</a> x, <a href="Quipper.html#t:QCData">QCData</a> y, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun x y, <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun' x' (m y'), <a href="Libraries-Auxiliary.html#t:Curry">Curry</a> qfun'' x qfun', x' ~ <a href="Quipper-QData.html#t:QCType">QCType</a> a b x, y' ~ <a href="Quipper-QData.html#t:QCType">QCType</a> a b y, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m) =&gt; <a href="Quipper.html#t:Transformer">Transformer</a> m a b -&gt; qfun -&gt; qfun''<a href="src/Quipper/Generic.html#line-1290" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper.html#v:transform_generic">transform_generic</a></code>, but applies to arbitrary transformers
 of type
</p><pre> Transformer m a b
</pre><p>instead of the special case
</p><pre> Transformer Circ Qubit Bit.
</pre><p>This requires an additional shape argument. 
</p><p>The type of this heavily overloaded function is difficult to
 read. In more readable form, it has all of the following types:
</p><pre> transform_generic :: (QCData x) =&gt; Transformer m a b -&gt; Circ x -&gt; m (QCData a b x)
 transform_generic :: (QCData x, QCData y) =&gt; Transformer m a b -&gt; (x -&gt; Circ y) -&gt; x -&gt; (QCData a b x -&gt; m (QCData a b y))
 transform_generic :: (QCData x, QCData y, QCData z) =&gt; Transformer m a b -&gt; (x -&gt; y -&gt; Circ z) -&gt; x -&gt; y -&gt; (QCData a b x -&gt; QCData a b y -&gt; m (QCData a b z))
</pre><p>and so forth.
</p></div></div><h2 id="g:30">Auxiliary type definitions
</h2><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:InverseFlag" class="def">InverseFlag</a> = <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a><a href="src/Quipper/Circuit.html#line-85" class="link">Source</a></p><div class="doc"><p>A flag that, if <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code>, indicates that the gate is inverted.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:NoControlFlag" class="def">NoControlFlag</a> = <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a><a href="src/Quipper/Circuit.html#line-94" class="link">Source</a></p><div class="doc"><p>A flag that, if <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code>, indicates that the gate is controllable,
 but any further controls on the gate should be ignored. This is
 used, e.g., for circuits consisting of a basis change, some
 operation, and the inverse basis change. When controlling such a
 circuit, it is sufficient to control the middle operation, so the
 gates belonging to the basis change and its inverse will have the
 NoControlFlag set.
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:B_Endpoint" class="def">B_Endpoint</a> a b <a href="src/Quipper/Transformer.html#line-149" class="link">Source</a></p><div class="doc"><p>An <em>endpoint</em> is either a <em>qubit</em> or a <em>bit</em>. In a transformer,
 we have &#10214;Endpoint Qubit Bit&#10215; = &#10214;Qubit&#10215; + &#10214;Bit&#10215;. The type <code>Endpoint</code>
 <em>a</em> <em>b</em> is the same as <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Either.html#t:Either">Either</a></code> <em>a</em> <em>b</em>, but we use more suggestive
 field names.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Endpoint_Qubit" class="def">Endpoint_Qubit</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Endpoint_Bit" class="def">Endpoint_Bit</a> b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:B_Endpoint" class="caption collapser" onclick="toggleSection('i:B_Endpoint')">Instances</p><div id="section.i:B_Endpoint" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Typeable-Internal.html#t:Typeable2">Typeable2</a> <a href="Quipper.html#t:B_Endpoint">B_Endpoint</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:ControlSource">ControlSource</a> (<a href="Quipper.html#t:Signed">Signed</a> a), <a href="Quipper.html#t:ControlSource">ControlSource</a> (<a href="Quipper.html#t:Signed">Signed</a> b)) =&gt; <a href="Quipper.html#t:ControlSource">ControlSource</a> (<a href="Quipper.html#t:Signed">Signed</a> (<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> b) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> (<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a> b) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> b) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:ControlSource">ControlSource</a> a, <a href="Quipper.html#t:ControlSource">ControlSource</a> b) =&gt; <a href="Quipper.html#t:ControlSource">ControlSource</a> (<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:QCData">QCData</a> a, <a href="Quipper.html#t:QCData">QCData</a> b) =&gt; <a href="Quipper.html#t:QCData">QCData</a> (<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper.html#t:Labelable">Labelable</a> b <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b) <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:Labelable">Labelable</a> a s, <a href="Quipper.html#t:Labelable">Labelable</a> b t) =&gt; <a href="Quipper.html#t:Labelable">Labelable</a> (<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b) (<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> s t)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Endpoint" class="def">Endpoint</a> = <a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> <a href="Quipper.html#t:Qubit">Qubit</a> <a href="Quipper.html#t:Bit">Bit</a><a href="src/Quipper/Monad.html#line-426" class="link">Source</a></p><div class="doc"><p>An endpoint in a circuit. This is either a <code><a href="Quipper.html#t:Qubit">Qubit</a></code> or a <code><a href="Quipper.html#t:Bit">Bit</a></code>.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Ctrls" class="def">Ctrls</a> a b = &#91;<a href="Quipper.html#t:Signed">Signed</a> (<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b)&#93;<a href="src/Quipper/Transformer.html#line-239" class="link">Source</a></p><div class="doc"><p>A list of signed values of type &#10214;Endpoint&#10215;. This type is an
 abbreviation defined for convenience.
</p></div></div><h1 id="g:31">Automatic circuit generation from classical code
</h1><div class="doc"><p>The following two modules provide functions that are useful for
 automatic circuit generation from classical code. Please see
 <a href="Quipper-CircLifting.html">Quipper.CircLifting</a> for a more detailed explanation of how to use
 this feature.
</p></div><div class="top"><p class="src">module <a href="Quipper-CircLifting.html">Quipper.CircLifting</a></p></div><div class="top"><p class="src">module <a href="Libraries-Template.html">Libraries.Template</a></p></div><h1 id="g:32">Extended quantum data types
</h1><h2 id="g:33">Homogeneous quantum data types
</h2><div class="top"><p class="src"><span class="keyword">class</span> (<a href="Quipper.html#t:QData">QData</a> qa, <a href="Quipper-QData.html#t:CType">CType</a> qa ~ ca, <a href="Quipper-QData.html#t:BType">BType</a> qa ~ ba) =&gt; <a name="t:QShape" class="def">QShape</a> ba qa ca | ba -&gt; qa, qa -&gt; ca, ca -&gt; ba<a href="src/Quipper/QData.html#line-1030" class="link">Source</a></p><div class="doc"><p>The <code><a href="Quipper.html#t:QShape">QShape</a></code> class allows the definition of generic functions that
 can operate on quantum data of any &quot;shape&quot;, for example, nested
 tuples or lists of qubits.
</p><p>In general, there are three kinds of data: quantum inputs (such as
 <code><a href="Quipper.html#t:Qubit">Qubit</a></code>), classical inputs (such as <code><a href="Quipper.html#t:Bit">Bit</a></code>), and classical
 parameters (such as <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></code>). For example, a <code><a href="Quipper.html#t:Qubit">Qubit</a></code> can be
 initialized from a <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></code>; a <code><a href="Quipper.html#t:Qubit">Qubit</a></code> can be measured, resulting in
 a <code><a href="Quipper.html#t:Bit">Bit</a></code>, etc. For this reason, the type class <code><a href="Quipper.html#t:QShape">QShape</a></code> establishes a
 relation between three types:
</p><dl><dt><code>qa</code></dt><dd> A data structure having <code><a href="Quipper.html#t:Qubit">Qubit</a></code> at the leaves.
</dd><dt><code>ca</code></dt><dd> A data structure of the same shape as <code>qa</code>, having <code><a href="Quipper.html#t:Bit">Bit</a></code> at
 the leaves.
</dd><dt><code>ba</code></dt><dd> A data structure of the same shape as <code>qa</code>, having <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></code> at
 the leaves.
</dd></dl><p>Some functions input a classical parameter for the sole purpose of
 establishing the &quot;shape&quot; of a piece of data. The shape refers to
 qualities of a data structure, such as the length of a list, which
 are not uniquely determined by the type. For example, two different
 lists of length 5 have the same shape. When performing a generic
 operation, such as reversing a circuit, it is often necessary to
 specify the shape of the inputs, but not the actual inputs.
</p><p>In the common case where one only needs to declare one of the types
 <em>qa</em>, <em>ca</em>, or <em>ba</em>, one of the simpler type classes <code><a href="Quipper.html#t:QData">QData</a></code>,
 <code><a href="Quipper.html#t:CData">CData</a></code>, or <code><a href="Quipper.html#t:BData">BData</a></code> can be used.
</p></div><div class="subs instances"><p id="control.i:QShape" class="caption collapser" onclick="toggleSection('i:QShape')">Instances</p><div id="section.i:QShape" class="show"><table><tr><td class="src">(<a href="Quipper.html#t:QData">QData</a> qa, ~ * (<a href="Quipper-QData.html#t:BType">BType</a> qa) ba, ~ * (<a href="Quipper-QData.html#t:CType">CType</a> qa) ca) =&gt; <a href="Quipper.html#t:QShape">QShape</a> ba qa ca</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> (qa ~ <a href="Quipper-QData.html#t:QType">QType</a> (<a href="Quipper-QData.html#t:CType">CType</a> qa), qa ~ <a href="Quipper-QData.html#t:QTypeB">QTypeB</a> (<a href="Quipper-QData.html#t:BType">BType</a> qa), qa ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> qa, qa ~ <a href="Quipper-QData.html#t:QType">QType</a> qa, <a href="Quipper.html#t:QCData">QCData</a> qa, <a href="Quipper.html#t:QCData">QCData</a> (<a href="Quipper-QData.html#t:CType">CType</a> qa)) =&gt; <a name="t:QData" class="def">QData</a> qa <a href="src/Quipper/QData.html#line-743" class="link">Source</a></p><div class="doc"><p>The <code><a href="Quipper.html#t:QData">QData</a></code> type class contains homogeneous data types built up
 from leaves of type <code><a href="Quipper.html#t:Qubit">Qubit</a></code>.
</p></div><div class="subs instances"><p id="control.i:QData" class="caption collapser" onclick="toggleSection('i:QData')">Instances</p><div id="section.i:QData" class="show"><table><tr><td class="src">(~ * qa (<a href="Quipper-QData.html#t:QType">QType</a> (<a href="Quipper-QData.html#t:CType">CType</a> qa)), ~ * qa (<a href="Quipper-QData.html#t:QTypeB">QTypeB</a> (<a href="Quipper-QData.html#t:BType">BType</a> qa)), ~ * qa (<a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper.html#t:Qubit">Qubit</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> qa), ~ * qa (<a href="Quipper-QData.html#t:QType">QType</a> qa), <a href="Quipper.html#t:QCData">QCData</a> qa, <a href="Quipper.html#t:QCData">QCData</a> (<a href="Quipper-QData.html#t:CType">CType</a> qa)) =&gt; <a href="Quipper.html#t:QData">QData</a> qa</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> (<a href="Quipper.html#t:QData">QData</a> (<a href="Quipper-QData.html#t:QType">QType</a> ca), <a href="Quipper-QData.html#t:CType">CType</a> (<a href="Quipper-QData.html#t:QType">QType</a> ca) ~ ca) =&gt; <a name="t:CData" class="def">CData</a> ca <a href="src/Quipper/QData.html#line-971" class="link">Source</a></p><div class="doc"><p>The <code><a href="Quipper.html#t:CData">CData</a></code> type class contains homogeneous data types built up
 from leaves of type <code><a href="Quipper.html#t:Bit">Bit</a></code>.
</p></div><div class="subs instances"><p id="control.i:CData" class="caption collapser" onclick="toggleSection('i:CData')">Instances</p><div id="section.i:CData" class="show"><table><tr><td class="src">(<a href="Quipper.html#t:QData">QData</a> (<a href="Quipper-QData.html#t:QType">QType</a> ca), ~ * (<a href="Quipper-QData.html#t:CType">CType</a> (<a href="Quipper-QData.html#t:QType">QType</a> ca)) ca) =&gt; <a href="Quipper.html#t:CData">CData</a> ca</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> (<a href="Quipper.html#t:QData">QData</a> (<a href="Quipper-QData.html#t:QTypeB">QTypeB</a> ba), <a href="Quipper-QData.html#t:BType">BType</a> (<a href="Quipper-QData.html#t:QTypeB">QTypeB</a> ba) ~ ba) =&gt; <a name="t:BData" class="def">BData</a> ba <a href="src/Quipper/QData.html#line-976" class="link">Source</a></p><div class="doc"><p>The <code><a href="Quipper.html#t:BData">BData</a></code> type class contains homogeneous data types built up
 from leaves of type <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></code>.
</p></div><div class="subs instances"><p id="control.i:BData" class="caption collapser" onclick="toggleSection('i:BData')">Instances</p><div id="section.i:BData" class="show"><table><tr><td class="src">(<a href="Quipper.html#t:QData">QData</a> (<a href="Quipper-QData.html#t:QTypeB">QTypeB</a> ba), ~ * (<a href="Quipper-QData.html#t:BType">BType</a> (<a href="Quipper-QData.html#t:QTypeB">QTypeB</a> ba)) ba) =&gt; <a href="Quipper.html#t:BData">BData</a> ba</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:34">Heterogeneous quantum data types
</h2><div class="top"><p class="src"><span class="keyword">class</span> (<a href="Quipper.html#t:Labelable">Labelable</a> qc <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Typeable-Internal.html#t:Typeable">Typeable</a> qc, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> qc, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Quipper-QData.html#t:LType">LType</a> qc), qc ~ <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="Quipper.html#t:Qubit">Qubit</a> <a href="Quipper.html#t:Bit">Bit</a> qc, <a href="Quipper-QData.html#t:CType">CType</a> (<a href="Quipper-QData.html#t:QType">QType</a> qc) ~ <a href="Quipper-QData.html#t:CType">CType</a> qc, <a href="Quipper-QData.html#t:BType">BType</a> (<a href="Quipper-QData.html#t:CType">CType</a> qc) ~ <a href="Quipper-QData.html#t:BType">BType</a> qc, <a href="Quipper-QData.html#t:QCType">QCType</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> (<a href="Quipper-QData.html#t:CType">CType</a> qc) ~ <a href="Quipper-QData.html#t:BType">BType</a> qc) =&gt; <a name="t:QCData" class="def">QCData</a> qc <a href="src/Quipper/QData.html#line-222" class="link">Source</a></p><div class="doc"><p>The <code><a href="Quipper.html#t:QCData">QCData</a></code> type class contains heterogeneous data types built
 up from leaves of type <code><a href="Quipper.html#t:Qubit">Qubit</a></code> and <code><a href="Quipper.html#t:Bit">Bit</a></code>. It is the basis for
 several generic operations that apply to classical and quantum
 data, such as copying, transformers, simulation, and heterogeneous
 versions of qterm and qdiscard.
</p><p><code><a href="Quipper.html#t:QCData">QCData</a></code> and <code><a href="Quipper.html#t:QData">QData</a></code> are interrelated, in the sense that the
 following implications hold:
</p><pre> QData qa   implies   QCData qa
 CData ca   implies   QCData ca
</pre><p>Implications in the converse direction also hold whenever <em>qc</em> is a
 fixed known type:
</p><pre> QCData qc   implies   QData (QType qc)
 QCData qc   implies   CData (CType qc)
 QCData qc   implies   BData (BType qc)
</pre><p>However, the type checker cannot prove the above implication in the
 case where <em>qc</em> is a type variable; for this, the more flexible
 (but more computationally expensive) <code><a href="Quipper.html#t:QCDataPlus">QCDataPlus</a></code> class can be used.
</p></div><div class="subs instances"><p id="control.i:QCData" class="caption collapser" onclick="toggleSection('i:QCData')">Instances</p><div id="section.i:QCData" class="show"><table><tr><td class="src"><a href="Quipper.html#t:QCData">QCData</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Char.html#t:Char">Char</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:QCData">QCData</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:QCData">QCData</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Float">Float</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:QCData">QCData</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:QCData">QCData</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:QCData">QCData</a> ()</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:QCData">QCData</a> <a href="Quipper.html#t:Bit">Bit</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:QCData">QCData</a> <a href="Quipper.html#t:Qubit">Qubit</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:QCData">QCData</a> a =&gt; <a href="Quipper.html#t:QCData">QCData</a> &#91;a&#93;</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a href="Quipper.html#t:QCData">QCData</a> a =&gt; <a href="Quipper.html#t:QCData">QCData</a> (<a href="Quipper.html#t:Signed">Signed</a> a)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:QCData">QCData</a> a, <a href="Quipper.html#t:QCData">QCData</a> b) =&gt; <a href="Quipper.html#t:QCData">QCData</a> (a, b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:QCData">QCData</a> a, <a href="Quipper.html#t:QCData">QCData</a> b) =&gt; <a href="Quipper.html#t:QCData">QCData</a> (<a href="Quipper.html#t:B_Endpoint">B_Endpoint</a> a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:QCData">QCData</a> a, <a href="Quipper.html#t:QCData">QCData</a> b, <a href="Quipper.html#t:QCData">QCData</a> c) =&gt; <a href="Quipper.html#t:QCData">QCData</a> (a, b, c)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:QCData">QCData</a> a, <a href="Quipper.html#t:QCData">QCData</a> b, <a href="Quipper.html#t:QCData">QCData</a> c, <a href="Quipper.html#t:QCData">QCData</a> d) =&gt; <a href="Quipper.html#t:QCData">QCData</a> (a, b, c, d)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:QCData">QCData</a> a, <a href="Quipper.html#t:QCData">QCData</a> b, <a href="Quipper.html#t:QCData">QCData</a> c, <a href="Quipper.html#t:QCData">QCData</a> d, <a href="Quipper.html#t:QCData">QCData</a> e) =&gt; <a href="Quipper.html#t:QCData">QCData</a> (a, b, c, d, e)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:QCData">QCData</a> a, <a href="Quipper.html#t:QCData">QCData</a> b, <a href="Quipper.html#t:QCData">QCData</a> c, <a href="Quipper.html#t:QCData">QCData</a> d, <a href="Quipper.html#t:QCData">QCData</a> e, <a href="Quipper.html#t:QCData">QCData</a> f) =&gt; <a href="Quipper.html#t:QCData">QCData</a> (a, b, c, d, e, f)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:QCData">QCData</a> a, <a href="Quipper.html#t:QCData">QCData</a> b, <a href="Quipper.html#t:QCData">QCData</a> c, <a href="Quipper.html#t:QCData">QCData</a> d, <a href="Quipper.html#t:QCData">QCData</a> e, <a href="Quipper.html#t:QCData">QCData</a> f, <a href="Quipper.html#t:QCData">QCData</a> g) =&gt; <a href="Quipper.html#t:QCData">QCData</a> (a, b, c, d, e, f, g)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:QCData">QCData</a> a, <a href="Quipper.html#t:QCData">QCData</a> b, <a href="Quipper.html#t:QCData">QCData</a> c, <a href="Quipper.html#t:QCData">QCData</a> d, <a href="Quipper.html#t:QCData">QCData</a> e, <a href="Quipper.html#t:QCData">QCData</a> f, <a href="Quipper.html#t:QCData">QCData</a> g, <a href="Quipper.html#t:QCData">QCData</a> h) =&gt; <a href="Quipper.html#t:QCData">QCData</a> (a, b, c, d, e, f, g, h)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:QCData">QCData</a> a, <a href="Quipper.html#t:QCData">QCData</a> b, <a href="Quipper.html#t:QCData">QCData</a> c, <a href="Quipper.html#t:QCData">QCData</a> d, <a href="Quipper.html#t:QCData">QCData</a> e, <a href="Quipper.html#t:QCData">QCData</a> f, <a href="Quipper.html#t:QCData">QCData</a> g, <a href="Quipper.html#t:QCData">QCData</a> h, <a href="Quipper.html#t:QCData">QCData</a> i) =&gt; <a href="Quipper.html#t:QCData">QCData</a> (a, b, c, d, e, f, g, h, i)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper.html#t:QCData">QCData</a> a, <a href="Quipper.html#t:QCData">QCData</a> b, <a href="Quipper.html#t:QCData">QCData</a> c, <a href="Quipper.html#t:QCData">QCData</a> d, <a href="Quipper.html#t:QCData">QCData</a> e, <a href="Quipper.html#t:QCData">QCData</a> f, <a href="Quipper.html#t:QCData">QCData</a> g, <a href="Quipper.html#t:QCData">QCData</a> h, <a href="Quipper.html#t:QCData">QCData</a> i, <a href="Quipper.html#t:QCData">QCData</a> j) =&gt; <a href="Quipper.html#t:QCData">QCData</a> (a, b, c, d, e, f, g, h, i, j)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> (<a href="Quipper.html#t:QCData">QCData</a> qc, <a href="Quipper.html#t:QData">QData</a> (<a href="Quipper-QData.html#t:QType">QType</a> qc)) =&gt; <a name="t:QCDataPlus" class="def">QCDataPlus</a> qc <a href="src/Quipper/QData.html#line-1249" class="link">Source</a></p><div class="doc"><p>The <code><a href="Quipper.html#t:QCDataPlus">QCDataPlus</a></code> type class is almost identical to <code><a href="Quipper.html#t:QCData">QCData</a></code>,
 except that it contains one additional piece of information that
 allows the type checker to prove the implications
</p><pre> QCDataPlus qc     implies   QShape (BType qc) (QType qc) (CType qc)
 QCDataPlus qc     implies   QData (QType qc)
 QCDataPlus qc     implies   CData (CType qc)
 QCDataPlus qc     implies   BData (BType qc)
</pre><p>This is sometimes useful, for example, in the context of a function
 that inputs a <code><a href="Quipper.html#t:QCData">QCData</a></code>, measures all the qubits, and returns a
 <code><a href="Quipper.html#t:CData">CData</a></code>. However, the additional information for the type checker
 comes at a price, which is drastically increased compilation time.
 Therefore <code><a href="Quipper.html#t:QCDataPlus">QCDataPlus</a></code> should only be used when <code><a href="Quipper.html#t:QCData">QCData</a></code> is
 insufficient.
</p></div><div class="subs instances"><p id="control.i:QCDataPlus" class="caption collapser" onclick="toggleSection('i:QCDataPlus')">Instances</p><div id="section.i:QCDataPlus" class="show"><table><tr><td class="src">(<a href="Quipper.html#t:QCData">QCData</a> qc, <a href="Quipper.html#t:QData">QData</a> (<a href="Quipper-QData.html#t:QType">QType</a> qc)) =&gt; <a href="Quipper.html#t:QCDataPlus">QCDataPlus</a> qc</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><h2 id="g:35">Shape-related operations
</h2><div class="doc"><p>Some Quipper functions, such as <code><a href="Quipper.html#v:print_generic">print_generic</a></code>, require a
 <em>shape parameter</em>. A shape parameter is a parameter passed to a
 function for the sole purpose of specifying the type or size of
 some data structure, without actually specifying any data.
 Example: given a circuit
</p><pre> circuit :: (&#91;Qubit&#93;, Bit) -&gt; Circ Qubit,
</pre><p>the command
</p><pre> print_generic Preview circuit (&#91;qubit,qubit,qubit&#93;, bit)
</pre><p>tells Quipper to preview the circuit for a problem size of 3 qubits
 and 1 bit.
</p></div><div class="top"><p class="src"><a name="v:bit" class="def">bit</a> :: <a href="Quipper.html#t:Bit">Bit</a><a href="src/Quipper/QData.html#line-697" class="link">Source</a></p><div class="doc"><p>A dummy term of type <code><a href="Quipper.html#t:Bit">Bit</a></code>. It can be used in shape parameters
 (e.g., <code>qc_init</code>), as well as shape type parameters (e.g.,
 <code><a href="Quipper-QData.html#v:qcdata_mapM">qcdata_mapM</a></code>).
</p></div></div><div class="top"><p class="src"><a name="v:qubit" class="def">qubit</a> :: <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/QData.html#line-691" class="link">Source</a></p><div class="doc"><p>A dummy term of type <code><a href="Quipper.html#t:Qubit">Qubit</a></code>. It can be used in shape parameters
 (e.g., <code>qc_init</code>), as well as shape type parameters (e.g.,
 <code><a href="Quipper-QData.html#v:qcdata_mapM">qcdata_mapM</a></code>).
</p></div></div><div class="top"><p class="src"><a name="v:qshape" class="def">qshape</a> :: <a href="Quipper.html#t:QData">QData</a> qa =&gt; <a href="Quipper-QData.html#t:BType">BType</a> qa -&gt; qa<a href="src/Quipper/Generic.html#line-848" class="link">Source</a></p><div class="doc"><p>Return a quantum data structure of the given boolean shape, with
 every leaf initialized to the undefined dummy value <code><a href="Quipper.html#v:qubit">qubit</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:qc_false" class="def">qc_false</a> :: <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; qc -&gt; <a href="Quipper-QData.html#t:BType">BType</a> qc<a href="src/Quipper/Generic.html#line-840" class="link">Source</a></p><div class="doc"><p>Return a boolean data structure of the given shape, with every
 leaf initialized to <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:False">False</a></code>.
</p></div></div><h2 id="g:36">Quantum type classes
</h2><div class="doc"><p>Haskell provides many convenient type classes: <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a></code>, <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a></code>, <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Num">Num</a></code>, etc.
 Quipper provides quantum analogues of some of these.
 For instance, Haskell&#8217;s <code><code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a></code> a</code> has the method
</p><pre> (==) :: a -&gt; a -&gt; Bool.  
</pre><p>Correspondingly, our <code><code><a href="Quipper.html#t:QEq">QEq</a></code> a qa ca</code> has a method
</p><pre> q_is_equal :: qa -&gt; qa -&gt; Circ (qa,qa,Qubit).  
</pre><p>Similarly, where Haskell&#8217;s <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Num">Num</a></code> class has methods <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#v:-43-">+</a></code>, <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#v:-42-">*</a></code>, <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#v:signum">signum</a></code>,
 the class <code>QNum</code> has <code>q_add</code>, <code>q_mult</code>, <code>q_signum</code>, and so on.  
 (<code>QNum</code> is defined in <a href="QuipperLib-Arith.html">QuipperLib.Arith</a>.)
</p><p>All quantum type classes assume (a) that their instance types are
 <code><a href="Quipper.html#t:QCData">QCData</a></code>, and (b) that the corresponding classical parameter types
 are instances of the corresponding Haskell type classes.
</p><p>Quantum type classes are designed to work well with the automatic
 circuit generation of <a href="Quipper-CircLifting.html">Quipper.CircLifting</a>: the methods of
 Haskell&#8217;s standard type classes are translated into their quantum
 analogues, where available.
</p></div><div class="top"><p class="src"><span class="keyword">class</span> <a href="Quipper.html#t:QCData">QCData</a> qc =&gt; <a name="t:QEq" class="def">QEq</a> qc  <span class="keyword">where</span><a href="src/Quipper/QClasses.html#line-35" class="link">Source</a></p><div class="doc"><p>This is a quantum analogue of Haskell&#8217;s <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a></code> type class. Default
 implementations are provided; by default, equality is bitwise
 equality of the underlying data structure. However, specific
 instances can provide custom implementations. In this case,
 <code><a href="Quipper.html#v:q_is_equal">q_is_equal</a></code> is a minimal complete definition.
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:q_is_equal" class="def">q_is_equal</a> :: qc -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qc, qc, <a href="Quipper.html#t:Qubit">Qubit</a>)<a href="src/Quipper/QClasses.html#line-35" class="link">Source</a></p><div class="doc"><p>Test for equality. 
</p></div><p class="src"><a name="v:q_is_not_equal" class="def">q_is_not_equal</a> :: qc -&gt; qc -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qc, qc, <a href="Quipper.html#t:Qubit">Qubit</a>)<a href="src/Quipper/QClasses.html#line-35" class="link">Source</a></p><div class="doc"><p>Test for inequality.
</p></div></div><div class="subs instances"><p id="control.i:QEq" class="caption collapser" onclick="toggleSection('i:QEq')">Instances</p><div id="section.i:QEq" class="show"><table><tr><td class="src"><a href="Quipper.html#t:QCData">QCData</a> qc =&gt; <a href="Quipper.html#t:QEq">QEq</a> qc</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">class</span> (<a href="Quipper.html#t:QEq">QEq</a> qa, <a href="Quipper.html#t:QData">QData</a> qa) =&gt; <a name="t:QOrd" class="def">QOrd</a> qa  <span class="keyword">where</span><a href="src/Quipper/QClasses.html#line-70" class="link">Source</a></p><div class="doc"><p>This is a quantum analogue of Haskell's <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a></code> type class. Its
 purpose is to define a total ordering on each of its instances. The
 functions in this class are assumed dirty in the sense that they do
 not uncompute ancillas, and some of the inputs may be returned as
 outputs. The functions are also assumed to be non-linear safe,
 i.e., they apply no gates to their inputs except as control
 sources. Minimal complete definition: <code><a href="Quipper.html#v:q_less">q_less</a></code> or <code><a href="Quipper.html#v:q_greater">q_greater</a></code>. The default
 implementations of <code><a href="Quipper.html#v:q_max">q_max</a></code> and <code><a href="Quipper.html#v:q_min">q_min</a></code> assume that both arguments
 are of the same shape (for example, numbers of the same length).
</p></div><div class="subs methods"><p class="caption">Methods</p><p class="src"><a name="v:q_less" class="def">q_less</a> :: qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/QClasses.html#line-70" class="link">Source</a></p><div class="doc"><p>Test for less than.  
</p></div><p class="src"><a name="v:q_greater" class="def">q_greater</a> :: qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/QClasses.html#line-70" class="link">Source</a></p><div class="doc"><p>Test for greater than.
</p></div><p class="src"><a name="v:q_leq" class="def">q_leq</a> :: qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/QClasses.html#line-70" class="link">Source</a></p><div class="doc"><p>Test for less than or equal.
</p></div><p class="src"><a name="v:q_geq" class="def">q_geq</a> :: qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> <a href="Quipper.html#t:Qubit">Qubit</a><a href="src/Quipper/QClasses.html#line-70" class="link">Source</a></p><div class="doc"><p>Test for greater than or equal.
</p></div><p class="src"><a name="v:q_max" class="def">q_max</a> :: qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa<a href="src/Quipper/QClasses.html#line-70" class="link">Source</a></p><div class="doc"><p>Compute the maximum of two values.
</p></div><p class="src"><a name="v:q_min" class="def">q_min</a> :: qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> qa<a href="src/Quipper/QClasses.html#line-70" class="link">Source</a></p><div class="doc"><p>Compute the minimum of two values.
</p></div></div></div><div class="top"><p class="src"><a name="v:q_lt" class="def">q_lt</a> :: <a href="Quipper.html#t:QOrd">QOrd</a> qa =&gt; qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qa, qa, <a href="Quipper.html#t:Qubit">Qubit</a>)<a href="src/Quipper/QClasses.html#line-113" class="link">Source</a></p><div class="doc"><p><code><code><a href="Quipper.html#v:q_lt">q_lt</a></code> <em>qx</em> <em>qy</em></code>: test whether <em>qx</em> &lt; <em>qy</em>.  A functionally typed wrapper for <code><a href="Quipper.html#v:q_less">q_less</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:q_gt" class="def">q_gt</a> :: <a href="Quipper.html#t:QOrd">QOrd</a> qa =&gt; qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qa, qa, <a href="Quipper.html#t:Qubit">Qubit</a>)<a href="src/Quipper/QClasses.html#line-119" class="link">Source</a></p><div class="doc"><p><code><code><a href="Quipper.html#v:q_gt">q_gt</a></code> <em>qx</em> <em>qy</em></code>: test whether <em>qx</em> &gt; <em>qy</em>. A functionally typed wrapper for <code><a href="Quipper.html#v:q_greater">q_greater</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:q_le" class="def">q_le</a> :: <a href="Quipper.html#t:QOrd">QOrd</a> qa =&gt; qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qa, qa, <a href="Quipper.html#t:Qubit">Qubit</a>)<a href="src/Quipper/QClasses.html#line-125" class="link">Source</a></p><div class="doc"><p><code><code><a href="Quipper.html#v:q_le">q_le</a></code> <em>qx</em> <em>qy</em></code>: test whether <em>qx</em> &#8804; <em>qy</em>. A functionally typed wrapper for <code><a href="Quipper.html#v:q_leq">q_leq</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:q_ge" class="def">q_ge</a> :: <a href="Quipper.html#t:QOrd">QOrd</a> qa =&gt; qa -&gt; qa -&gt; <a href="Quipper.html#t:Circ">Circ</a> (qa, qa, <a href="Quipper.html#t:Qubit">Qubit</a>)<a href="src/Quipper/QClasses.html#line-131" class="link">Source</a></p><div class="doc"><p><code><code><a href="Quipper.html#v:q_ge">q_ge</a></code> <em>qx</em> <em>qy</em></code>: test whether <em>qx</em> &#8805; <em>qy</em>. A functionally typed wrapper for <code><a href="Quipper.html#v:q_geq">q_geq</a></code>.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.11.0</p></div></body></html>
