<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Algorithms.CL.CL</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Algorithms-CL-CL.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Algorithms/CL/CL.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Algorithms.CL.CL</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Stage 1 (quantum): Approximate regulator to low precision
</a></li><li><a href="#g:2">Stage 2 (classical): Compute the regulator more accurately. 
</a></li><li><a href="#g:3">Stage 3 (classical): Find generators of the class group.
</a></li><li><a href="#g:4">Stage 4 (quantum): Find relations between generators.
</a></li><li><a href="#g:5">Section 5 (classical): compute class number.
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>An implementation of the quantum algorithms, based on the works of Hallgren, to compute the class number of a real quadratic number field.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:approximate_regulator_circuit">approximate_regulator_circuit</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="QuipperLib-Arith.html#t:CInt">CInt</a></li><li class="src short"><a href="#v:try_approximate_regulator">try_approximate_regulator</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a>)</li><li class="src short"><a href="#v:verify_period_multiple">verify_period_multiple</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:approximate_regulator">approximate_regulator</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a></li><li class="src short"><a href="#v:improve_regulator_accuracy">improve_regulator_accuracy</a> :: <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a></li><li class="src short"><a href="#v:compute_generators">compute_generators</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; &#91;<a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a>&#93;</li><li class="src short"><a href="#v:hI">hI</a> :: <a href="Algorithms-CL-Types.html#t:IdDist">IdDist</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; (<a href="Algorithms-CL-Types.html#t:IdDist">IdDist</a>, <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a>)</li><li class="src short"><a href="#v:compute_ghat">compute_ghat</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integral">Integral</a> int =&gt; &#91;<a href="Algorithms-CL-Types.html#t:IdDist">IdDist</a>&#93; -&gt; &#91;int&#93; -&gt; <a href="Algorithms-CL-Types.html#t:IdDist">IdDist</a></li><li class="src short"><a href="#v:compute_i_N_at">compute_i_N_at</a> :: <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:register_sizes">register_sizes</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a> -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>)</li><li class="src short"><a href="#v:structure_circuit">structure_circuit</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a> -&gt; &#91;<a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="QuipperLib-Arith.html#t:CInt">CInt</a>&#93;</li><li class="src short"><a href="#v:compute_relations">compute_relations</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a> -&gt; &#91;<a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a>&#93; -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> &#91;<a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a>&#93;</li><li class="src short"><a href="#v:class_number">class_number</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a></li></ul></div><div id="interface"><h1 id="g:1">Stage 1 (quantum): Approximate regulator to low precision
</h1><div class="top"><p class="src"><a name="v:approximate_regulator_circuit" class="def">approximate_regulator_circuit</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="QuipperLib-Arith.html#t:CInt">CInt</a><a href="src/Algorithms/CL/CL.html#line-38" class="link">Source</a></p><div class="doc"><p>Quantum part of the procedure to approximate the regulator <em>R</em>.
</p><p>Follows the procedure described in &#91;Jozsa 2003&#93;, Sec. 10. An adapted
 version of the Hidden Subgroup Problem (HSP) Algorithm is used to
 estimate the (irrational) period of the function <em>f</em> <sub><em>N</em></sub>
 (<code><a href="Algorithms-CL-RegulatorClassical.html#v:fN">fN</a></code>, <code><a href="Algorithms-CL-RegulatorQuantum.html#v:q_fN">q_fN</a></code>); this is the function <em>h</em> of &#91;Jozsa 2003&#93;, Sec. 9,
 discretized with precision <em>N</em> = 2 <sup>&#8722;<em>n</em></sup>, and so has weak
 period <em>S</em> = <em>NR</em>.  The precision <em>n</em> is determined by <code><a href="Algorithms-CL-Types.html#v:n_of_bigD">n_of_bigD</a></code>.
</p><p>Inputs: &#916;; <em>i</em>, an assumed bound such that <em>S</em> &#8804; 2<sup><em>i</em></sup>; 
 and a random &#8220;jitter&#8221; parameter.
</p></div></div><div class="top"><p class="src"><a name="v:try_approximate_regulator" class="def">try_approximate_regulator</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a>)<a href="src/Algorithms/CL/CL.html#line-83" class="link">Source</a></p><div class="doc"><p>Attempt to approximate the regulator <em>R</em>, given an assumed 
 bound <em>i</em> such that <em>S</em> &#8804; 2<sup><em>i</em></sup>, using the probabilistic 
 quantum computation <code>approximate_regulator_circuit</code> twice as
 described in &#91;Jozsa 2003&#93;, Sec. 10.
</p><p>Check the result for success; if it fails, return <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#v:Nothing">Nothing</a></code>.
</p><p>(The <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a></code> monad is slight overkill here: it is just to make a
 source of randomness available. A tighter approach could use e.g. a
 monad transformer such as <code>RandT</code>, applied to the <code><a href="Quipper-Monad.html#t:Circ">Circ</a></code> monad.)
</p></div></div><div class="top"><p class="src"><a name="v:verify_period_multiple" class="def">verify_period_multiple</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a><a href="src/Algorithms/CL/CL.html#line-109" class="link">Source</a></p><div class="doc"><p><code><code><a href="Algorithms-CL-CL.html#v:verify_period_multiple">verify_period_multiple</a></code> &#916; <em>n</em> <em>m</em></code>: 
 check whether <em>m</em> is within 1 of a multiple of the period <em>S</em> of <em>f</em><sub><em>N</em></sub>.
</p><p>Since for any ideal <em>I</em>, &#961;(&#961;(<em>I</em>)) is distance &gt; ln 2 from <em>I</em>, it suffices 
 to check whether the unit ideal is within 4 steps either way of <em>f</em><sub><em>N</em></sub>(m).
</p></div></div><div class="top"><p class="src"><a name="v:approximate_regulator" class="def">approximate_regulator</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a><a href="src/Algorithms/CL/CL.html#line-119" class="link">Source</a></p><div class="doc"><p>Approximate the regulator for a given &#916; (<em>bigD</em>).
</p><p>Repeatedly run <code><code><a href="Algorithms-CL-CL.html#v:try_approximate_regulator">try_approximate_regulator</a></code></code> enough times, with increasing
 <em>i</em>, that it eventually succeeds with high probability. 
</p></div></div><h1 id="g:2">Stage 2 (classical): Compute the regulator more accurately. 
</h1><div class="top"><p class="src"><a name="v:improve_regulator_accuracy" class="def">improve_regulator_accuracy</a> :: <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a><a href="src/Algorithms/CL/CL.html#line-137" class="link">Source</a></p><div class="doc"><p>Improve the precision of the initial estimate of the regulator <em>R</em>, for 
 a quadratic discriminant &#916;.
</p><p>The implementation is essentially based on the proof of Theorem 5 of 
 &#91;Jozsa 2003&#93;.
</p></div></div><h1 id="g:3">Stage 3 (classical): Find generators of the class group.
</h1><div class="top"><p class="src"><a name="v:compute_generators" class="def">compute_generators</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; &#91;<a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a>&#93;<a href="src/Algorithms/CL/CL.html#line-233" class="link">Source</a></p><div class="doc"><p>A set of ideal classes generating <em>CL</em>(<em>K</em>).
</p><p>Implementation: assuming the Generalized Riemann Hypothesis, it is
 enough to enumerate the non-principal prime ideals arising as
 factors of (<em>p</em>), for primes <em>p</em> &#8804; 12(ln &#916;)<sup>2</sup>. ([Haase and
 Maier 2006], Prop. 4.4.)  For each <em>p</em>, there are at most two such
 prime ideals, and they are easily described.
</p></div></div><h1 id="g:4">Stage 4 (quantum): Find relations between generators.
</h1><div class="doc"><p>Notation is as in &#91;Hallgren 2006, Section 5&#93;.  Note: Some
 components are currently missing here, and are marked
 &quot;incomplete&quot; in the code below.
</p></div><div class="top"><p class="src"><a name="v:hI" class="def">hI</a> :: <a href="Algorithms-CL-Types.html#t:IdDist">IdDist</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; (<a href="Algorithms-CL-Types.html#t:IdDist">IdDist</a>, <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a>)<a href="src/Algorithms/CL/CL.html#line-280" class="link">Source</a></p><div class="doc"><p>Compute the generators of <em>CL</em>(<em>K</em>), function <em>hI</em>.
</p></div></div><div class="top"><p class="src"><a name="v:compute_ghat" class="def">compute_ghat</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integral">Integral</a> int =&gt; &#91;<a href="Algorithms-CL-Types.html#t:IdDist">IdDist</a>&#93; -&gt; &#91;int&#93; -&gt; <a href="Algorithms-CL-Types.html#t:IdDist">IdDist</a><a href="src/Algorithms/CL/CL.html#line-304" class="link">Source</a></p><div class="doc"><p>Compute the ideals from the generators (&#285; function).
</p></div></div><div class="top"><p class="src"><a name="v:compute_i_N_at" class="def">compute_i_N_at</a> :: <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/Algorithms/CL/CL.html#line-316" class="link">Source</a></p><div class="doc"><p>Compute <em>i</em>/<em>N</em>. Incomplete.
</p></div></div><div class="top"><p class="src"><a name="v:register_sizes" class="def">register_sizes</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a> -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>)<a href="src/Algorithms/CL/CL.html#line-325" class="link">Source</a></p><div class="doc"><p>Compute register sizes for <code>structure_circuit</code>, given
  &#916; and a precise estimate of <em>R</em>. Return a 7-tuple
   (<em>q</em>,1,2,3,4,5,6) where <em>q</em> is the size of the first
   <em>k</em> registers, and 1&#8230;6 are the sizes of registers <em>k</em>+1&#8230;<em>k</em>+6.
</p></div></div><div class="top"><p class="src"><a name="v:structure_circuit" class="def">structure_circuit</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a> -&gt; &#91;<a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="QuipperLib-Arith.html#t:CInt">CInt</a>&#93;<a href="src/Algorithms/CL/CL.html#line-387" class="link">Source</a></p><div class="doc"><p>The quantum circuit used in computing the structure of <em>CL</em>(<em>K</em>),
 given &#916;, a precise estimate of <em>R</em>, and a generating set for <em>CL</em>(<em>K</em>).
</p></div></div><div class="top"><p class="src"><a name="v:compute_relations" class="def">compute_relations</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="Algorithms-CL-Types.html#t:CLReal">CLReal</a> -&gt; &#91;<a href="Algorithms-CL-Types.html#t:IdealRed">IdealRed</a>&#93; -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> &#91;<a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a>&#93;<a href="src/Algorithms/CL/CL.html#line-442" class="link">Source</a></p><div class="doc"><p>Compute the relations between a given set of reduced generators.
</p></div></div><h1 id="g:5">Section 5 (classical): compute class number.
</h1><div class="top"><p class="src"><a name="v:class_number" class="def">class_number</a> :: <a href="Algorithms-CL-Types.html#t:CLIntP">CLIntP</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> <a href="Algorithms-CL-Types.html#t:CLInt">CLInt</a><a href="src/Algorithms/CL/CL.html#line-455" class="link">Source</a></p><div class="doc"><p>The full implementation of Hallgren&#8217;s algorithm.
</p><p><code>class_number dd t</code>: computes the class number |<em>CL</em>(<em>K</em>)| for &#916; = <em>dd</em>,
 with success probability at least (1 - 1/2<sup><em>t</em></sup>).
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.11.0</p></div></body></html>
