<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Algorithms.USV.USV</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Algorithms-USV-USV.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Algorithms/USV/USV.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Algorithms.USV.USV</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Coherent arithmetic
</a></li><li><a href="#g:2">Algorithm 1: &quot;uSVP&quot;
</a></li><li><a href="#g:3">Algorithm 2: &quot;Q&quot;
</a></li><li><a href="#g:4">Algorithm 3: &quot;R&quot;
</a></li><li><a href="#g:5">Algorithm 4: &quot;TPP&quot;
</a></li><li><a href="#g:6">Algorithm 5: &quot;DCP&quot;
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides an implementation of the 
 main Unique Shortest Vector algorithm.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:f_classical">f_classical</a> :: &#91;&#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;&#93; -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>&#93;) -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;</li><li class="src short"><a href="#v:f_quantum">f_quantum</a> :: &#91;&#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;&#93; -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-USV-Definitions.html#t:TwoPoint">TwoPoint</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93;</li><li class="src short"><a href="#v:g1_classical">g1_classical</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a></li><li class="src short"><a href="#v:g_classical">g_classical</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;</li><li class="src short"><a href="#v:g1_quantum">g1_quantum</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a></li><li class="src short"><a href="#v:g_quantum">g_quantum</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a>&#93; -&gt; &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93;</li><li class="src short"><a href="#v:h_classical">h_classical</a> :: &#91;<a href="QuipperLib-Arith.html#t:IntM">IntM</a>&#93; -&gt; <a href="QuipperLib-Arith.html#t:IntM">IntM</a></li><li class="src short"><a href="#v:h_quantum">h_quantum</a> :: &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a></li><li class="src short"><a href="#v:uSVP">uSVP</a> :: &#91;&#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;</li><li class="src short"><a href="#v:usvp_aux">usvp_aux</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; &#91;&#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;&#93; -&gt; &#91;(<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>)&#93; -&gt; <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:StdGen">StdGen</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;</li><li class="src short"><a href="#v:algorithm_Q">algorithm_Q</a> :: &#91;&#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;&#93; -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>) -&gt; <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:StdGen">StdGen</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;</li><li class="src short"><a href="#v:algorithm_R">algorithm_R</a> :: &#91;&#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;&#93; -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:StdGen">StdGen</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Algorithms-USV-Definitions.html#t:TwoPoint">TwoPoint</a></li><li class="src short"><a href="#v:tPP">tPP</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; &#91;<a href="Algorithms-USV-Definitions.html#t:TwoPoint">TwoPoint</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;</li><li class="src short"><a href="#v:n_low_bits">n_low_bits</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a> -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93;</li><li class="src short"><a href="#v:pairing">pairing</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; &#91;<a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a>&#93; -&gt; (&#91;(<a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a>, <a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a>)&#93;, &#91;<a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a>&#93;)</li><li class="src short"><a href="#v:sieving">sieving</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; &#91;<a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a>&#93;</li><li class="src short"><a href="#v:dCP">dCP</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; &#91;<a href="Algorithms-USV-Definitions.html#t:CosetState">CosetState</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a></li></ul></div><div id="interface"><h1 id="g:1">Coherent arithmetic
</h1><div class="doc"><p>Some arithmetic functions used in the reductions of the <em>USV</em> to 
 the <em>TPP</em> and of the <em>TPP</em> to the <em>DCP</em>.
</p></div><div class="top"><p class="src"><a name="v:f_classical" class="def">f_classical</a> :: &#91;&#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;&#93; -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>&#93;) -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;<a href="src/Algorithms/USV/USV.html#line-45" class="link">Source</a></p><div class="doc"><p>Compute the function <em>f</em>, that selects a subset
 of lattice points. It is defined as:
</p><p><img src="images/def_f.png">
</p><p>The arguments are: 
</p><ul><li> <em>bb_bar</em>, an <em>n</em>-dimensional matrix;
</li><li> <em>p</em>, a prime such that <em>n</em> &#8804; <em>p</em> &#8804; 2<em>n</em>;
</li><li> <em>m</em>, an integer such that <em>1</em> &#8804; <em>m</em> &#8804; <em>p-1</em>;
</li><li> <em>i0</em>, an integer index such that <em>0</em> &#8804; <em>i0</em> &#8804; <em>n-1</em>;
</li><li> <em>t</em>, an integer (either <em>0</em> or <em>1</em>);
</li><li> <em>a</em>=(<em>a</em><sub>1</sub>,...,<em>a</em><sub><em>n</em></sub>), an integer vector.
</li></ul></div></div><div class="top"><p class="src"><a name="v:f_quantum" class="def">f_quantum</a> :: &#91;&#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;&#93; -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-USV-Definitions.html#t:TwoPoint">TwoPoint</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93;<a href="src/Algorithms/USV/USV.html#line-51" class="link">Source</a></p><div class="doc"><p>Quantum version of <code><a href="Algorithms-USV-USV.html#v:f_classical">f_classical</a></code>. 
</p></div></div><div class="top"><p class="src"><a name="v:g1_classical" class="def">g1_classical</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a><a href="src/Algorithms/USV/USV.html#line-93" class="link">Source</a></p><div class="doc"><p>Compute the function <em>g</em> defined as:
</p><p><img src="images/def_g1.png">
</p><p>The arguments are: 
</p><ul><li> <em>l</em>, an integer (in principle, a real number, but the 
 GFI only uses integer values);
</li><li> <em>w</em>, a real number in the interval [0,1);
</li><li> <em>v</em>, an integer.
</li></ul><p>We note that in the quantum version of this function, <em>l</em>
 and <em>w</em> will be parameters, and <em>v</em> will be a quantum 
 input. We implement this operation using only integer
 division, using the following property: for all integers
 <em>v</em>, <em>m</em> and real numbers <em>w</em>, 
</p><p><img src="images/floor2.png">
</p></div></div><div class="top"><p class="src"><a name="v:g_classical" class="def">g_classical</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;<a href="src/Algorithms/USV/USV.html#line-107" class="link">Source</a></p><div class="doc"><p>Compute the function <em>g</em>. The function <em>g</em> 
 partitions the space into hypercubes of size
 128<em>l</em> at a random offset <em>w</em>. It is defined as:
</p><p><img src="images/def_g.png">
</p><p>This is just the componentwise application of <code><a href="Algorithms-USV-USV.html#v:g1_classical">g1_classical</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:g1_quantum" class="def">g1_quantum</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a><a href="src/Algorithms/USV/USV.html#line-111" class="link">Source</a></p><div class="doc"><p>Quantum version of <code><a href="Algorithms-USV-USV.html#v:g1_classical">g1_classical</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:g_quantum" class="def">g_quantum</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a>&#93; -&gt; &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93;<a href="src/Algorithms/USV/USV.html#line-125" class="link">Source</a></p><div class="doc"><p>Quantum version of <code><a href="Algorithms-USV-USV.html#v:g_classical">g_classical</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:h_classical" class="def">h_classical</a> :: &#91;<a href="QuipperLib-Arith.html#t:IntM">IntM</a>&#93; -&gt; <a href="QuipperLib-Arith.html#t:IntM">IntM</a><a href="src/Algorithms/USV/USV.html#line-137" class="link">Source</a></p><div class="doc"><p>Compute the function <em>h</em>, defined as:
</p><p><img src="images/def_h.png">
</p><p>The function <em>h</em> transforms a vector <em>a</em>=(<em>a</em><sub>1</sub>,...,<em>a</em><sub>n</sub>) 
 of 4<em>n</em>-bit integers into a 4<em>n</em><sup>2</sup>+<em>n</em>-bit integer by 
 inserting a 0 between each component of <em>a</em>. 
</p></div></div><div class="top"><p class="src"><a name="v:h_quantum" class="def">h_quantum</a> :: &#91;<a href="QuipperLib-Arith.html#t:QDInt">QDInt</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="QuipperLib-Arith.html#t:QDInt">QDInt</a><a href="src/Algorithms/USV/USV.html#line-147" class="link">Source</a></p><div class="doc"><p>Quantum version of <code><a href="Algorithms-USV-USV.html#v:h_classical">h_classical</a></code>. 
</p></div></div><h1 id="g:2">Algorithm 1: &quot;uSVP&quot;
</h1><div class="top"><p class="src"><a name="v:uSVP" class="def">uSVP</a> :: &#91;&#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;<a href="src/Algorithms/USV/USV.html#line-174" class="link">Source</a></p><div class="doc"><p>Find the shortest vector. The argument, <em>bb</em>, is an 
 <em>n</em>-dimensional integer matrix. The algorithm first uses
 <em>bb</em> to generate a list of parameter tuples and then 
 recursively goes through this list by calling <code><a href="Algorithms-USV-USV.html#v:algorithm_Q">algorithm_Q</a></code>
 on each tuple until it either finds the shortest vector
 or exhausts the list and fails by returning 0.
</p><p>Remark: 
</p><ul><li> Argument <em>n</em> is redundant, it can be inferred from <em>bb</em>.
</li></ul></div></div><div class="top"><p class="src"><a name="v:usvp_aux" class="def">usvp_aux</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; &#91;&#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;&#93; -&gt; &#91;(<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>)&#93; -&gt; <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:StdGen">StdGen</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;<a href="src/Algorithms/USV/USV.html#line-214" class="link">Source</a></p><div class="doc"><p>For each tuple of parameters, call <code><a href="Algorithms-USV-USV.html#v:algorithm_Q">algorithm_Q</a></code> and 
 then test whether the returned vector is the shortest vector 
 in the lattice. If it is, return it. If not, move on to 
 the next tuple. If the end of the list is reached, return 0.
</p><p>Remark:
</p><ul><li> The algorithm takes as additional argument a random number 
 generator. At each iteration, a new seed is extracted and used
 by the next iteration's generator.
</li></ul></div></div><h1 id="g:3">Algorithm 2: &quot;Q&quot;
</h1><div class="top"><p class="src"><a name="v:algorithm_Q" class="def">algorithm_Q</a> :: &#91;&#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;&#93; -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a>) -&gt; <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:StdGen">StdGen</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;<a href="src/Algorithms/USV/USV.html#line-244" class="link">Source</a></p><div class="doc"><p>Compute <code><a href="Algorithms-USV-USV.html#v:algorithm_Q">algorithm_Q</a></code>. The arguments are:
</p><ul><li> <em>bb_bar</em>, an <em>n</em>-dimensional LLL-reduced basis;
</li><li> (<em>l</em>,<em>m</em>,<em>i0</em>,<em>p</em>), a 4-tuple of integer parameters;
</li><li> <em>randomgen</em>, a random number generator.
</li></ul><p>The algorithm first calls algorithm <code><a href="Algorithms-USV-USV.html#v:algorithm_R">algorithm_R</a></code> to prepare
 a list of <code><a href="Algorithms-USV-Definitions.html#t:TwoPoint">TwoPoint</a></code>s parameterized on (<em>l</em>,<em>m</em>,<em>i0</em>,<em>p</em>) and 
 then calls <code><a href="Algorithms-USV-USV.html#v:tPP">tPP</a></code> on this list. With high probability, the 
 returned vector is the shortest vector in the lattice up to 
 one component. 
</p><p>Remark: 
</p><ul><li> Argument <em>n</em> is redundant, it can be inferred 
 from <em>bb_bar</em>.
</li></ul></div></div><h1 id="g:4">Algorithm 3: &quot;R&quot;
</h1><div class="top"><p class="src"><a name="v:algorithm_R" class="def">algorithm_R</a> :: &#91;&#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;&#93; -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/random/1.0.1.1/doc/html/System-Random.html#t:StdGen">StdGen</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Algorithms-USV-Definitions.html#t:TwoPoint">TwoPoint</a><a href="src/Algorithms/USV/USV.html#line-294" class="link">Source</a></p><div class="doc"><p>Compute <code><a href="Algorithms-USV-USV.html#v:algorithm_R">algorithm_R</a></code>. The arguments are: 
</p><ul><li> <em>bb_bar</em>, an <em>n</em>-dimensional LLL-reduced basis,
</li><li> <em>l</em>, an integer approximation of the length of the 
 shortest vector,
</li><li> <em>p</em>, a prime such that <em>n</em> &#8804; <em>n</em> &#8804; 2<em>n</em>,
</li><li> <em>m</em>, an integer such that <em>1</em> &#8804; <em>m</em> &#8804; <em>p-1</em>,
</li><li> <em>i0</em>, an integer index such that <em>0</em> &#8804; <em>i0</em> &#8804; <em>n-1</em> and
</li><li> <em>randomgen</em>, a random number generator.
</li></ul><p>The algorithm first calls the functions <code><a href="Algorithms-USV-USV.html#v:f_quantum">f_quantum</a></code> and 
 <code><a href="Algorithms-USV-USV.html#v:g_quantum">g_quantum</a></code> to prepare a superposition of hypercubes 
 containing at most two lattice points, whose difference 
 is the shortest vector. It then measures the output to 
 collapses the state to a <code><a href="Algorithms-USV-Definitions.html#t:TwoPoint">TwoPoint</a></code>.
</p></div></div><h1 id="g:5">Algorithm 4: &quot;TPP&quot;
</h1><div class="top"><p class="src"><a name="v:tPP" class="def">tPP</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; &#91;<a href="Algorithms-USV-Definitions.html#t:TwoPoint">TwoPoint</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a>&#93;<a href="src/Algorithms/USV/USV.html#line-340" class="link">Source</a></p><div class="doc"><p>Perform Regev's reduction of the <em>TPP</em> to the <em>DCP</em> and then
 call <code><a href="Algorithms-USV-USV.html#v:dCP">dCP</a></code>. The arguments are: 
</p><ul><li> <em>n</em>, an integer and
</li><li> <em>states</em>, a list of <code><a href="Algorithms-USV-Definitions.html#t:TwoPoint">TwoPoint</a></code>s.
</li></ul><p>The algorithm transforms the <code><a href="Algorithms-USV-Definitions.html#t:TwoPoint">TwoPoint</a></code>s in <em>states</em> into 
 <code><a href="Algorithms-USV-Definitions.html#t:CosetState">CosetState</a></code>s using the function <code><a href="Algorithms-USV-USV.html#v:h_quantum">h_quantum</a></code>, then calls 
 <code><a href="Algorithms-USV-USV.html#v:dCP">dCP</a></code> on this modified list to find the shortest vector.
</p></div></div><h1 id="g:6">Algorithm 5: &quot;DCP&quot;
</h1><div class="top"><p class="src"><a name="v:n_low_bits" class="def">n_low_bits</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a> -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93;<a href="src/Algorithms/USV/USV.html#line-372" class="link">Source</a></p><div class="doc"><p>Given integers <em>m</em> and <em>n</em> and a <code><a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a></code> <em>(q,k)</em>
 compute the last <em>n</em> bits of the binary expansion
 of <em>k</em> on <em>m</em> bits.
</p></div></div><div class="top"><p class="src"><a name="v:pairing" class="def">pairing</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; &#91;<a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a>&#93; -&gt; (&#91;(<a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a>, <a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a>)&#93;, &#91;<a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a>&#93;)<a href="src/Algorithms/USV/USV.html#line-379" class="link">Source</a></p><div class="doc"><p>Given integers <em>m</em> and <em>n</em> and a list <em>l</em> of <code><a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a></code>s, group the 
 elements  of <em>l</em> into pairs <em>(psi_p, psi_q)</em> where 
 <em>p</em> and <em>q</em> share <em>n</em> low bits. Return the list of all such 
 pairs together with the list of unpaired elements of <em>l</em>.
</p></div></div><div class="top"><p class="src"><a name="v:sieving" class="def">sieving</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; &#91;<a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a>&#93;<a href="src/Algorithms/USV/USV.html#line-405" class="link">Source</a></p><div class="doc"><p>Perform Kuperberg's sieve. The arguments are:
</p><ul><li> <em>n</em>, an integer,
</li><li> <em>m</em>, an integer and
</li><li> <em>l</em>, a list of <code><a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a></code>s.
</li></ul><p>The algorithm recursively combines and sieves the 
 elements of <em>l</em> until it reaches a list whose
 elements have <em>m</em><sup>2</sup> trailing zeros.
 At each step, the list of remaining <code><a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a></code>s are
 paired and each pair 
 ((<em>q</em><sub>1</sub>, <em>k</em><sub>1</sub>), (<em>q</em><sub>2</sub>, <em>k</em><sub>2</sub>))
 is combined into a new <code><a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a></code> <em>(q, k)</em> with
 <em>k</em>= <em>k</em><sub>1</sub> &#177; <em>k</em><sub>2</sub>. 
 If <em>k</em>= <em>k</em><sub>1</sub> - <em>k</em><sub>2</sub>, the <code><a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a></code> is preserved,
 otherwise it is discarded.
</p><p>Remark:
</p><ul><li> Uses <code><a href="Quipper-Generic.html#v:dynamic_lift">dynamic_lift</a></code> to determine whether 
 to keep a discard a <code><a href="Algorithms-USV-Definitions.html#t:Psi_k">Psi_k</a></code>.
</li></ul></div></div><div class="top"><p class="src"><a name="v:dCP" class="def">dCP</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; &#91;<a href="Algorithms-USV-Definitions.html#t:CosetState">CosetState</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Integer">Integer</a><a href="src/Algorithms/USV/USV.html#line-457" class="link">Source</a></p><div class="doc"><p>Perform Kuperberg's algorithm solving the Dihedral
 Coset problem. The arguments are: 
</p><ul><li> <em>n</em>, an integer measuring the length of the output,
</li><li> <em>d</em>, an integer to hold the output initially set to 0,
</li><li> <em>s</em>, an integer counter initially set to 0 and
</li><li> <em>states</em>, a list of <code><a href="Algorithms-USV-Definitions.html#t:CosetState">CosetState</a></code>s.
</li></ul><p>The algorithm proceeds recursively. At each iteration it  
 uses Kuperberg's sieve on the first <em>n</em> elements of <em>states</em> 
 to compute the <em>s</em>-th bit of the output and updates <em>d</em> with
 the result. Then it increments <em>s</em> and repeats until <em>states</em> is 
 exhausted. 
</p><p>Remark: 
</p><ul><li> The function <code><a href="Quipper-Generic.html#v:dynamic_lift">dynamic_lift</a></code> used in this algorithm is presumably
 very expensive in terms of resources. In this implementation
 it is used profusely but there is room for optimization.
</li></ul></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.11.0</p></div></body></html>
