<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Algorithms.GSE.GSE</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Algorithms-GSE-GSE.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Algorithms/GSE/GSE.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Algorithms.GSE.GSE</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Basic time step
</a></li><li><a href="#g:2">Iteration
</a></li><li><a href="#g:3">Main circuit
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides the main circuit for the GSE algorithm.
 This circuit consists of a state preparation, followed by a large
 number of Hamiltonian simulation terms for small time steps,
 followed by an inverse Quantum Fourier Transform and a final
 measurement. 
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:exp_pq">exp_pq</a> :: ((<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a>) -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a> -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:exp_pqrs">exp_pqrs</a> :: ((<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a>) -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a> -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:exp_pqrs_orthodox">exp_pqrs_orthodox</a> :: ((<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a>) -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a> -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:unitary_hat_at">unitary_hat_at</a> :: <a href="Algorithms-GSE-GSEData.html#t:GSEData">GSEData</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:gse">gse</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-GSE-GSEData.html#t:GSEData">GSEData</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a> -&gt; (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Bit">Bit</a>&#93;</li></ul></div><div id="interface"><h1 id="g:1">Basic time step
</h1><div class="doc"><p>These functions provide one- and two-electron operators for an
 individual Trotter time step &#952;. Each operator consists of a large
 number of individual Hamiltonian terms.
</p></div><div class="top"><p class="src"><a name="v:exp_pq" class="def">exp_pq</a> :: ((<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a>) -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a> -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/Algorithms/GSE/GSE.html#line-30" class="link">Source</a></p><div class="doc"><p>Apply the one-electron operator <i>e</i><sup>-<em>i</em>&#952;<em>H</em></sup>, where
 <em>H</em> = <em>h</em><sub><em>pq</em></sub> <em>a</em><sub><em>p</em></sub><sup>&#8224;</sup><em>a</em><sub><em>q</em></sub> if <em>p</em> = <em>q</em> and
 <em>H</em> = <em>h</em><sub><em>pq</em></sub> (<em>a</em><sub><em>p</em></sub><sup>&#8224;</sup><em>a</em><sub><em>q</em></sub>
 + <em>a</em><sub><em>q</em></sub><sup>&#8224;</sup><em>a</em><sub><em>p</em></sub>) otherwise, to every pair of
 qubits <em>p</em>&#8805;<em>q</em> in a register |&#968;&#9002;. The inputs are Hamiltonian data
 <em>h</em>, the angle &#952;, the register |&#968;&#9002;, and a control qubit. 
</p></div></div><div class="top"><p class="src"><a name="v:exp_pqrs" class="def">exp_pqrs</a> :: ((<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a>) -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a> -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/Algorithms/GSE/GSE.html#line-54" class="link">Source</a></p><div class="doc"><p>Apply the two-electron operator <i>e</i><sup>-<em>i</em>&#952;<em>H</em></sup>, where
 <em>H</em> = <em>h</em><sub><em>pqrs</em></sub> 
 <em>a</em><sub><em>p</em></sub><sup>&#8224;</sup><em>a</em><sub><em>q</em></sub><sup>&#8224;</sup><em>a</em><sub><em>r</em></sub><em>a</em><sub><em>s</em></sub> if
 (<em>p</em>,<em>q</em>) = (<em>s</em>,<em>r</em>) and <em>H</em> =
 <em>a</em><sub><em>p</em></sub><sup>&#8224;</sup><em>a</em><sub><em>q</em></sub><sup>&#8224;</sup><em>a</em><sub><em>r</em></sub><em>a</em><sub><em>s</em></sub> +
 <em>a</em><sub><em>s</em></sub><sup>&#8224;</sup><em>a</em><sub><em>r</em></sub><sup>&#8224;</sup><em>a</em><sub><em>q</em></sub><em>a</em><sub><em>p</em></sub>
 otherwise, to every quadruple (<em>p</em>, <em>q</em>, <em>r</em>, <em>s</em>) of qubits in a 
 register |&#968;&#9002;. To ensure that terms are enumerated exactly once, we
 only consider indices where (<em>p</em>, <em>q</em>) &#8805; (<em>s</em>, <em>r</em>) in the
 lexicographic order (i.e., <em>p</em>&gt;<em>s</em> or (<em>p</em>=<em>s</em> and <em>q</em>&#8805;<em>r</em>).  The
 inputs are Hamiltonian data <em>h</em>, the angle &#952;, the register |&#968;&#9002;,
 and a control qubit.
</p></div></div><div class="top"><p class="src"><a name="v:exp_pqrs_orthodox" class="def">exp_pqrs_orthodox</a> :: ((<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>, <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>) -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a>) -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a> -&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/Algorithms/GSE/GSE.html#line-70" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Algorithms-GSE-GSE.html#v:exp_pqrs">exp_pqrs</a></code>, but use the &quot;orthodox&quot; circuit template for
 the Coulomb operator.
</p></div></div><h1 id="g:2">Iteration
</h1><div class="doc"><p>The following function iterates the basic Trotter timestep
 <em>N</em><sub><em>k</em></sub> times, and also normalizes the maximum energy 
 <em>E</em><sub>max</sub>.
</p></div><div class="top"><p class="src"><a name="v:unitary_hat_at" class="def">unitary_hat_at</a><a href="src/Algorithms/GSE/GSE.html#line-93" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="Algorithms-GSE-GSEData.html#t:GSEData">GSEData</a></td><td class="doc"><p>The integral data <em>h</em><sub>pq</sub> and <em>h</em><sub>pqrs</sub>.
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a></td><td class="doc"><p>The Trotter iteration count <em>N</em><sub><em>k</em></sub>.
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a></td><td class="doc"><p>The Hamiltonian scaling parameter &#964;.
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a></td><td class="doc"><p>The maximum energy <em>E</em><sub>max</sub>.
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></td><td class="doc"><p>Use the &quot;orthodox&quot; Coulomb operator?
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a></td><td class="doc"><p>The control qubit index <em>k</em>.
</p></td></tr><tr><td class="src">-&gt; &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;</td><td class="doc"><p>The state |&#968;&#9002;.
</p></td></tr><tr><td class="src">-&gt; <a href="Quipper-Monad.html#t:Qubit">Qubit</a></td><td class="doc"><p>The control qubit <em>b</em><sub><em>k</em></sub>.
</p></td></tr><tr><td class="src">-&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>Apply the operator &#219;<sub>k</sub> &#8776;
 <i>e</i><sup><em>iE</em><sub>max</sub>&#964;2<sup><em>k</em></sup></sup><i>e</i><sup>-<em>iH</em>&#964;2<sup><em>k</em></sup></sup> to |&#968;&#9002;.
</p></div></div><h1 id="g:3">Main circuit
</h1><div class="doc"><p>The main circuit for the GSE Algorithm. This consists of the
 initial state preparation, the Trotterized phase estimation
 circuit, the Quantum Fourier Transform, and the final measurement.
</p></div><div class="top"><p class="src"><a name="v:gse" class="def">gse</a><a href="src/Algorithms/GSE/GSE.html#line-131" class="link">Source</a></p><div class="subs arguments"><p class="caption">Arguments</p><table><tr><td class="src">:: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a></td><td class="doc"><p>The number of precision qubits <em>b</em>.
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a></td><td class="doc"><p>The number of basis functions <em>M</em>.
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a></td><td class="doc"><p>The number of occupied orbitals <em>N</em>.
</p></td></tr><tr><td class="src">-&gt; <a href="Algorithms-GSE-GSEData.html#t:GSEData">GSEData</a></td><td class="doc"><p>The integral data <em>h</em><sub>pq</sub> and <em>h</em><sub>pqrs</sub>.
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a></td><td class="doc"><p>The Hamiltonian scaling parameter &#964;.
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Double">Double</a></td><td class="doc"><p>The maximum energy <em>E</em><sub>max</sub>.
</p></td></tr><tr><td class="src">-&gt; (<a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a>)</td><td class="doc"><p>The function <em>k</em> &#8614; <em>N</em><sub><em>k</em></sub>.
</p></td></tr><tr><td class="src">-&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a></td><td class="doc"><p>Use the &quot;orthodox&quot; Coulomb operator?
</p></td></tr><tr><td class="src">-&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> &#91;<a href="Quipper-Monad.html#t:Bit">Bit</a>&#93;</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="doc"><p>The main circuit for the GSE Algorithm.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>
