<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Algorithms.BWT.Alternative</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Algorithms-BWT-Alternative.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Algorithms/BWT/Alternative.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Algorithms.BWT.Alternative</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Oracle abstraction
</a></li><li><a href="#g:2">Top-level algorithm
</a></li><li><a href="#g:3">Oracle implementations
</a><ul><li><a href="#g:4">Blackbox oracle
</a></li><li><a href="#g:5">A simple &quot;exponential&quot; oracle.
</a></li><li><a href="#g:6">Alternate implementations of the &quot;orthodox&quot; oracle
</a><ul><li><a href="#g:7">Classical implementation
</a></li><li><a href="#g:8">Auxiliary functions
</a></li><li><a href="#g:9">Classical circuit implementation
</a></li><li><a href="#g:10">Oracle abstraction
</a></li></ul></li></ul></li><li><a href="#g:11">Testing functions
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>Alternative implementations for the binary welded tree algorithm.
 The purpose of these is to experiment with and potentially
 illustrate a more functional programming style.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span>  <a href="#t:Oracle">Oracle</a>  = <a href="#v:Oracle">Oracle</a> {<ul class="subs"><li><a href="#v:n">n</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a></li><li><a href="#v:m">m</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a></li><li><a href="#v:k">k</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a></li><li><a href="#v:entrance">entrance</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a></li><li><a href="#v:oraclefun">oraclefun</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; (<a href="Quipper-Monad.html#t:Qulist">Qulist</a>, <a href="Quipper-Monad.html#t:Qulist">Qulist</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li></ul>}</li><li class="src short"><a href="#v:convert_oracle">convert_oracle</a> :: <a href="Algorithms-BWT-Alternative.html#t:Oracle">Oracle</a> -&gt; <a href="Algorithms-BWT-BWT.html#t:Oracle">Oracle</a></li><li class="src short"><a href="#v:qrwbwt">qrwbwt</a> :: <a href="Algorithms-BWT-Alternative.html#t:Oracle">Oracle</a> -&gt; <a href="Quipper-Circuit.html#t:Timestep">Timestep</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a></li><li class="src short"><a href="#v:hamiltonian">hamiltonian</a> :: <a href="Quipper-Circuit.html#t:Timestep">Timestep</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Oracle">Oracle</a> -&gt; <a href="Quipper-Monad.html#t:Qulist">Qulist</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:time_step">time_step</a> :: <a href="Quipper-Circuit.html#t:Timestep">Timestep</a> -&gt; (<a href="Quipper-Monad.html#t:Qulist">Qulist</a>, <a href="Quipper-Monad.html#t:Qulist">Qulist</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:basischange">basischange</a> :: (<a href="Quipper-Monad.html#t:Qulist">Qulist</a>, <a href="Quipper-Monad.html#t:Qulist">Qulist</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:compute_steps">compute_steps</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:oracle_blackbox">oracle_blackbox</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Oracle">Oracle</a></li><li class="src short"><a href="#v:oracle_simple">oracle_simple</a> :: <a href="Algorithms-BWT-Alternative.html#t:Oracle">Oracle</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:Node">Node</a> = (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>, &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93;)</li><li class="src short"><a href="#v:node_of_int">node_of_int</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a></li><li class="src short"><a href="#v:int_of_node">int_of_node</a> :: <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a></li><li class="src short"><a href="#v:node_of_boollist">node_of_boollist</a> :: &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a></li><li class="src short"><a href="#v:boollist_of_node">boollist_of_node</a> :: <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93;</li><li class="src short"><a href="#v:parent">parent</a> :: <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a></li><li class="src short"><a href="#v:childintree">childintree</a> :: <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a></li><li class="src short"><a href="#v:bit_adder">bit_adder</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>) -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>)</li><li class="src short"><a href="#v:doweld1">doweld1</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93;</li><li class="src short"><a href="#v:doweld0">doweld0</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93;</li><li class="src short"><a href="#v:weld">weld</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a></li><li class="src short"><a href="#v:child">child</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a></li><li class="src short"><a href="#v:level_parity">level_parity</a> :: &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:is_zero">is_zero</a> :: &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:is_root">is_root</a> :: &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li><li class="src short"><a href="#v:v_function">v_function</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a></li><li class="src short"><span class="keyword">type</span> <a href="#t:CNode">CNode</a> = (<a href="Quipper-Monad.html#t:Bit">Bit</a>, <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a>)</li><li class="src short"><span class="keyword">type</span> <a href="#t:QNode">QNode</a> = (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;)</li><li class="src short"><a href="#v:qnode_of_qulist">qnode_of_qulist</a> :: <a href="Quipper-Monad.html#t:Qulist">Qulist</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a></li><li class="src short"><a href="#v:cnode_of_bitlist">cnode_of_bitlist</a> :: <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a></li><li class="src short"><a href="#v:cboollist_xor">cboollist_xor</a> :: <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a> -&gt; <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a></li><li class="src short"><a href="#v:cparent">cparent</a> :: <a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a></li><li class="src short"><a href="#v:cchildintree">cchildintree</a> :: <a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a> -&gt; <a href="Quipper-Monad.html#t:Bit">Bit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a></li><li class="src short"><a href="#v:cbit_adder">cbit_adder</a> :: <a href="Quipper-Monad.html#t:Bit">Bit</a> -&gt; (<a href="Quipper-Monad.html#t:Bit">Bit</a>, <a href="Quipper-Monad.html#t:Bit">Bit</a>, <a href="Quipper-Monad.html#t:Bit">Bit</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="Quipper-Monad.html#t:Bit">Bit</a>, <a href="Quipper-Monad.html#t:Bit">Bit</a>)</li><li class="src short"><a href="#v:cdoweld1">cdoweld1</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Quipper-Monad.html#t:Bit">Bit</a> -&gt; <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a></li><li class="src short"><a href="#v:cdoweld0">cdoweld0</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a></li><li class="src short"><a href="#v:cweld">cweld</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a> -&gt; <a href="Quipper-Monad.html#t:Bit">Bit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a></li><li class="src short"><a href="#v:cchild">cchild</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a> -&gt; <a href="Quipper-Monad.html#t:Bit">Bit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a></li><li class="src short"><a href="#v:clevel_parity">clevel_parity</a> :: <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:cis_zero">cis_zero</a> :: <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:cis_root">cis_root</a> :: <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:cv_function">cv_function</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a>, <a href="Quipper-Monad.html#t:Bit">Bit</a>)</li><li class="src short"><a href="#v:oracle_classical">oracle_classical</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Oracle">Oracle</a></li><li class="src short"><a href="#v:main_edges1">main_edges1</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:circfun">circfun</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; (<a href="Algorithms-BWT-Alternative.html#t:Node">Node</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>)</li><li class="src short"><a href="#v:main_edges2">main_edges2</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:main_oraclec">main_oraclec</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="Algorithms-BWT-BWT.html#t:Oracle">Oracle</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:main_oracle2">main_oracle2</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="Algorithms-BWT-BWT.html#t:Oracle">Oracle</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:main_oracle3">main_oracle3</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="Algorithms-BWT-BWT.html#t:Oracle">Oracle</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ()</li><li class="src short"><a href="#v:main_qrwbwt">main_qrwbwt</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ()</li></ul></div><div id="interface"><h1 id="g:1">Oracle abstraction
</h1><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:Oracle" class="def">Oracle</a>  <a href="src/Algorithms/BWT/Alternative.html#line-39" class="link">Source</a></p><div class="doc"><p>This is a version of <code><a href="Algorithms-BWT-BWT.html#t:Oracle">Oracle</a></code> that uses <code><a href="Quipper-Monad.html#t:Qulist">Qulist</a></code> instead of
   <code><a href="QuipperLib-Qureg.html#t:Qureg">Qureg</a></code>.  An oracle provides the following information: the tree
   depth <em>n</em>, the label length <em>m</em>, the number of edge colors <em>k</em>,
   the entrance label <em>ENTRANCE</em>, and for each color 0 &#8804; <em>c</em> &lt; <em>k</em>,
   a reversible circuit <em>ORACLE<sub>c</sub>(a,b,r)</em>.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Oracle" class="def">Oracle</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:n" class="def">n</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:m" class="def">m</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:k" class="def">k</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:entrance" class="def">entrance</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a></dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:oraclefun" class="def">oraclefun</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; (<a href="Quipper-Monad.html#t:Qulist">Qulist</a>, <a href="Quipper-Monad.html#t:Qulist">Qulist</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><a name="v:convert_oracle" class="def">convert_oracle</a> :: <a href="Algorithms-BWT-Alternative.html#t:Oracle">Oracle</a> -&gt; <a href="Algorithms-BWT-BWT.html#t:Oracle">Oracle</a><a href="src/Algorithms/BWT/Alternative.html#line-48" class="link">Source</a></p><div class="doc"><p>Convert a <a href="Alternative.html">Alternative</a>.<code><a href="Algorithms-BWT-Alternative.html#t:Oracle">Oracle</a></code> into a <a href="BWT.html">BWT</a>.<code><a href="Algorithms-BWT-BWT.html#t:Oracle">Oracle</a></code>.
</p></div></div><h1 id="g:2">Top-level algorithm
</h1><div class="top"><p class="src"><a name="v:qrwbwt" class="def">qrwbwt</a> :: <a href="Algorithms-BWT-Alternative.html#t:Oracle">Oracle</a> -&gt; <a href="Quipper-Circuit.html#t:Timestep">Timestep</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a><a href="src/Algorithms/BWT/Alternative.html#line-73" class="link">Source</a></p><div class="doc"><p>Do a quantum random walk on the binary welded tree given by the
 oracle, for <em>s</em> times steps of length <em>dt</em>.  Return a bit list
 corresponding to the probable exit label.  This is a more
 functional implementation of <code><a href="Algorithms-BWT-BWT.html#v:qrwbwt">qrwbwt</a></code> from the module <a href="BWT.html">BWT</a>.
</p><p>Note: This implementation does not rely on the oracle being
 self-inverse, and therefore only requires that
</p><pre> ORACLE<sub>c</sub>(a, 0, 0) = (a, v<sub>c</sub>(a), f<sub>c</sub>(a)), 
</pre><p>rather than the more general property 
</p><pre> ORACLE<sub>c</sub>(a, b, r) = (a, b &#8853; v<sub>c</sub>(a), r &#8853; f<sub>c</sub>(a)).  
</pre><p>This gives us the freedom to build more efficient oracles, where
 appropriate.
</p></div></div><div class="top"><p class="src"><a name="v:hamiltonian" class="def">hamiltonian</a> :: <a href="Quipper-Circuit.html#t:Timestep">Timestep</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Oracle">Oracle</a> -&gt; <a href="Quipper-Monad.html#t:Qulist">Qulist</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/Algorithms/BWT/Alternative.html#line-88" class="link">Source</a></p><div class="doc"><p>Apply one round of the Hamiltonian for time step <em>dt</em> to <em>a</em>.
</p></div></div><div class="top"><p class="src"><a name="v:time_step" class="def">time_step</a> :: <a href="Quipper-Circuit.html#t:Timestep">Timestep</a> -&gt; (<a href="Quipper-Monad.html#t:Qulist">Qulist</a>, <a href="Quipper-Monad.html#t:Qulist">Qulist</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/Algorithms/BWT/Alternative.html#line-107" class="link">Source</a></p><div class="doc"><p>Apply the diffusion step to <em>(a,b,r)</em>. Here <em>a</em> and <em>b</em> must be
 of equal length.
</p></div></div><div class="top"><p class="src"><a name="v:basischange" class="def">basischange</a> :: (<a href="Quipper-Monad.html#t:Qulist">Qulist</a>, <a href="Quipper-Monad.html#t:Qulist">Qulist</a>, <a href="Quipper-Monad.html#t:Qubit">Qubit</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/Algorithms/BWT/Alternative.html#line-118" class="link">Source</a></p><div class="doc"><p>Apply the basis change from Figure 3 of &#91;Childs et al.&#93; to <em>a</em>,
 <em>b</em>, and <em>h</em>. Here <em>a</em> and <em>b</em> must be of equal length.
</p></div></div><div class="top"><p class="src"><a name="v:compute_steps" class="def">compute_steps</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a><a href="src/Algorithms/BWT/Alternative.html#line-142" class="link">Source</a></p><div class="doc"><p>Compute the required number of iterations as a function of &#949; and
 <em>dt</em>.
</p><p>Inputs: <em>n</em> is the tree depth, &#949; is the desired precision, <em>dt</em> is
 the simulation time step. Intermediate values: <em>t</em> is the
 simulation time. Output: <em>s</em>, the upper bound on the number of
 simulation time steps.
</p><p>Note: &#91;Childs et al&#93; specifies that <em>t</em> should be chosen
 uniformly at random within the interval 0 &lt; <em>t</em> &#8804; <em>n</em><sup>4</sup>/2&#949;.
 Here, for simplicity, we just use <em>t</em> = &#8970;<em>n</em><sup>4</sup>/2&#949;&#8971;. Also note
 that this function is for information only, as it is not actually
 used. Users should specify <em>s</em> directly.
</p></div></div><h1 id="g:3">Oracle implementations
</h1><h2 id="g:4">Blackbox oracle
</h2><div class="top"><p class="src"><a name="v:oracle_blackbox" class="def">oracle_blackbox</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Oracle">Oracle</a><a href="src/Algorithms/BWT/Alternative.html#line-156" class="link">Source</a></p><div class="doc"><p>A blackbox oracle for testing. This just produces a labelled box
 in place of the actual oracle circuit. The argument is the tree
 height.
</p></div></div><h2 id="g:5">A simple &quot;exponential&quot; oracle.
</h2><div class="top"><p class="src"><a name="v:oracle_simple" class="def">oracle_simple</a> :: <a href="Algorithms-BWT-Alternative.html#t:Oracle">Oracle</a><a href="src/Algorithms/BWT/Alternative.html#line-177" class="link">Source</a></p><div class="doc"><p>This oracle, which works only for the fixed tree height 3, works
 by explicitly listing all the edges. It serves only to illustrate
 how the edge information is encoded. Listing all edges explicitly
 obviously would not scale well to larger graphs.
</p></div></div><h2 id="g:6">Alternate implementations of the &quot;orthodox&quot; oracle
</h2><h3 id="g:7">Classical implementation
</h3><div class="doc"><p>In this section, we first implement the oracle function 
 <em>v<sub>c</sub>(a)</em> as a classical boolean function. This implementation
 is just for reference, and attempts to be neither efficient nor
 quantum. It can, however, be used as a specification to test the 
 actual quantum oracles against. 
</p><p>Both the classical circuit implementation (below) and the Template
 Haskell implementation (in the module <a href="BWT-Template.html">BWT.Template</a>) were derived
 from this.
</p><p>We start with several auxiliary functions.
</p></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Node" class="def">Node</a> = (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>, &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93;)<a href="src/Algorithms/BWT/Alternative.html#line-269" class="link">Source</a></p><div class="doc"><p>The type of nodes: a pair of a tree bit and a node address.
</p></div></div><div class="top"><p class="src"><a name="v:node_of_int" class="def">node_of_int</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a><a href="src/Algorithms/BWT/Alternative.html#line-272" class="link">Source</a></p><div class="doc"><p>Convert integers to nodes, mainly for testing.
</p></div></div><div class="top"><p class="src"><a name="v:int_of_node" class="def">int_of_node</a> :: <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a><a href="src/Algorithms/BWT/Alternative.html#line-276" class="link">Source</a></p><div class="doc"><p>Convert nodes to integers, mainly for testing.
</p></div></div><div class="top"><p class="src"><a name="v:node_of_boollist" class="def">node_of_boollist</a> :: &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a><a href="src/Algorithms/BWT/Alternative.html#line-280" class="link">Source</a></p><div class="doc"><p>Convert a bit vector to a node.
</p></div></div><div class="top"><p class="src"><a name="v:boollist_of_node" class="def">boollist_of_node</a> :: <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93;<a href="src/Algorithms/BWT/Alternative.html#line-285" class="link">Source</a></p><div class="doc"><p>Convert a node to a bit vector.
</p></div></div><div class="top"><p class="src"><a name="v:parent" class="def">parent</a> :: <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a><a href="src/Algorithms/BWT/Alternative.html#line-290" class="link">Source</a></p><div class="doc"><p>Input a node <em>a</em> and return the parent of <em>a</em>. We assume that <em>a</em>
 is not a root or invalid.
</p></div></div><div class="top"><p class="src"><a name="v:childintree" class="def">childintree</a> :: <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a><a href="src/Algorithms/BWT/Alternative.html#line-296" class="link">Source</a></p><div class="doc"><p>Input a node <em>a</em> and return the left or right child of <em>a</em>
 (depending on whether the <em>childbit</em> is <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:False">False</a></code> or <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code>,
 respectively). Assumes that <em>a</em> is not a leaf.
</p></div></div><div class="top"><p class="src"><a name="v:bit_adder" class="def">bit_adder</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>) -&gt; (<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>)<a href="src/Algorithms/BWT/Alternative.html#line-302" class="link">Source</a></p><div class="doc"><p><code><code><a href="Algorithms-BWT-Alternative.html#v:bit_adder">bit_adder</a></code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:False">False</a></code></code> is a one-bit adder, and <code><code><a href="Algorithms-BWT-Alternative.html#v:bit_adder">bit_adder</a></code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code></code> is
 a one-bit subtracter (i.e., add the 2's complement of <em>y</em>).
</p></div></div><div class="top"><p class="src"><a name="v:doweld1" class="def">doweld1</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93;<a href="src/Algorithms/BWT/Alternative.html#line-316" class="link">Source</a></p><div class="doc"><p>Input an <em>n</em>+1-bit leaf node <em>a</em>:<em>aa</em> (without the tree bit; <em>a</em>
 is the highest bit and <em>aa</em> is the remaining <em>n</em> bits) and a sign
 <em>s</em> (where <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code> = negative, <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:False">False</a></code> = positive).  Return
 <em>a</em>:(<em>aa</em> + <em>s</em> * <em>f</em>). The first input is the <em>n</em>-bit welding
 vector <em>f</em> (a parameter to the oracle). Note that <em>f</em> is a
 parameter and <em>s</em>, <em>aa</em> are inputs.
</p></div></div><div class="top"><p class="src"><a name="v:doweld0" class="def">doweld0</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93;<a href="src/Algorithms/BWT/Alternative.html#line-324" class="link">Source</a></p><div class="doc"><p>Input an <em>n</em>+1-bit leaf node <em>a</em>:<em>aa</em> (without the tree bit), and
 return <em>a</em>:(<em>aa</em> &#8853; <em>g</em>). The first input is the <em>n</em>-bit welding
 vector <em>g</em> (a parameter to the oracle).
</p></div></div><div class="top"><p class="src"><a name="v:weld" class="def">weld</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a><a href="src/Algorithms/BWT/Alternative.html#line-332" class="link">Source</a></p><div class="doc"><p>Input a leaf node <em>a</em> and return the left or right weld of <em>a</em> in
 the other tree (depending on whether the <em>weldbit</em> is <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:False">False</a></code> or
 <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code>).  Assumes that <em>a</em> is a leaf.
</p></div></div><div class="top"><p class="src"><a name="v:child" class="def">child</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a><a href="src/Algorithms/BWT/Alternative.html#line-342" class="link">Source</a></p><div class="doc"><p>Input a node <em>a</em> and return the left or right child of <em>a</em>
 (depending on whether the <em>childbit</em> is <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:False">False</a></code> or <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code>. This
 works for leaf and non-leaf nodes.
</p></div></div><div class="top"><p class="src"><a name="v:level_parity" class="def">level_parity</a> :: &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a><a href="src/Algorithms/BWT/Alternative.html#line-356" class="link">Source</a></p><div class="doc"><p>Input a node address (without the tree bit) and return the parity
 of the node level expressed as a boolean either <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:False">False</a></code> or
 <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code>. Leaves have parity <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:False">False</a></code>, and other levels have
 alternating parities. In other words: count the number of leading
 zeros modulo 2.
</p></div></div><div class="top"><p class="src"><a name="v:is_zero" class="def">is_zero</a> :: &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a><a href="src/Algorithms/BWT/Alternative.html#line-363" class="link">Source</a></p><div class="doc"><p>Input a node address (without the tree bit) and return <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code> iff
 the node address is invalid. In other words, return <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code> iff the
 list consists of all 0's.
</p></div></div><div class="top"><p class="src"><a name="v:is_root" class="def">is_root</a> :: &#91;<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>&#93; -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a><a href="src/Algorithms/BWT/Alternative.html#line-370" class="link">Source</a></p><div class="doc"><p>Input a node address (without the tree bit) and return <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code> iff
 the node is a root or invalid. In other words, check whether all
 digits but the last are 0's.
</p></div></div><div class="top"><p class="src"><a name="v:v_function" class="def">v_function</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a> <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a><a href="src/Algorithms/BWT/Alternative.html#line-380" class="link">Source</a></p><div class="doc"><p><code><code><a href="Algorithms-BWT-Alternative.html#v:v_function">v_function</a></code> f g c a</code>: returns <em>v</em><sub><em>c</em></sub>(<em>a</em>), the label of the
 node connected to <em>a</em> by an edge of color <em>c</em>, or <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#v:Nothing">Nothing</a></code> if
 there is no such node. The parameters <em>f</em> and <em>g</em> encode the
 welding functions, and are lists of length <em>n</em>. <em>c</em> is a color in
 the range 0..3, and <em>a</em> is an (<em>n</em>+2)-bit node label.
</p></div></div><h3 id="g:8">Auxiliary functions
</h3><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:CNode" class="def">CNode</a> = (<a href="Quipper-Monad.html#t:Bit">Bit</a>, <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a>)<a href="src/Algorithms/BWT/Alternative.html#line-398" class="link">Source</a></p><div class="doc"><p>The type of nodes: a pair of a tree bit and a node address.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:QNode" class="def">QNode</a> = (<a href="Quipper-Monad.html#t:Qubit">Qubit</a>, &#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93;)<a href="src/Algorithms/BWT/Alternative.html#line-401" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a></code>, but uses qubits instead of classical bits.
</p></div></div><div class="top"><p class="src"><a name="v:qnode_of_qulist" class="def">qnode_of_qulist</a> :: <a href="Quipper-Monad.html#t:Qulist">Qulist</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a><a href="src/Algorithms/BWT/Alternative.html#line-404" class="link">Source</a></p><div class="doc"><p>Convert a <code><a href="Quipper-Monad.html#t:Qulist">Qulist</a></code> to a <code><a href="Algorithms-BWT-Alternative.html#t:QNode">QNode</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:cnode_of_bitlist" class="def">cnode_of_bitlist</a> :: <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a><a href="src/Algorithms/BWT/Alternative.html#line-409" class="link">Source</a></p><div class="doc"><p>Convert a <code><a href="Quipper-Monad.html#t:Bitlist">Bitlist</a></code> to a <code><a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:cboollist_xor" class="def">cboollist_xor</a> :: <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a> -&gt; <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a><a href="src/Algorithms/BWT/Alternative.html#line-414" class="link">Source</a></p><div class="doc"><p>Exclusive or operation on bit vectors.
</p></div></div><h3 id="g:9">Classical circuit implementation
</h3><div class="doc"><p>We now implement the oracle function v<sub>c</sub>(a) as a classical
 circuit, with <em>c</em> as a parameter. We don't try to be clever or
 efficient yet.  The implementation follows the &quot;classical
 implementation&quot; above, but must be reformulated due to the need to
 work within the <code><a href="Quipper-Monad.html#t:Circ">Circ</a></code> monad.
</p></div><div class="top"><p class="src"><a name="v:cparent" class="def">cparent</a> :: <a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a><a href="src/Algorithms/BWT/Alternative.html#line-428" class="link">Source</a></p><div class="doc"><p>Input a node <em>a</em> and return the parent of <em>a</em>. We assume that <em>a</em>
 is not a root or invalid.
</p></div></div><div class="top"><p class="src"><a name="v:cchildintree" class="def">cchildintree</a> :: <a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a> -&gt; <a href="Quipper-Monad.html#t:Bit">Bit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a><a href="src/Algorithms/BWT/Alternative.html#line-439" class="link">Source</a></p><div class="doc"><p>Input a node <em>a</em> and return the left or right child of <em>a</em>
 (depending on whether the <em>childbit</em> is <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:False">False</a></code> or <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code>,
 respectively). Assumes that <em>a</em> is not a leaf.
</p></div></div><div class="top"><p class="src"><a name="v:cbit_adder" class="def">cbit_adder</a> :: <a href="Quipper-Monad.html#t:Bit">Bit</a> -&gt; (<a href="Quipper-Monad.html#t:Bit">Bit</a>, <a href="Quipper-Monad.html#t:Bit">Bit</a>, <a href="Quipper-Monad.html#t:Bit">Bit</a>) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="Quipper-Monad.html#t:Bit">Bit</a>, <a href="Quipper-Monad.html#t:Bit">Bit</a>)<a href="src/Algorithms/BWT/Alternative.html#line-449" class="link">Source</a></p><div class="doc"><p><code><code><a href="Algorithms-BWT-Alternative.html#v:bit_adder">bit_adder</a></code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:False">False</a></code></code> is a one-bit adder, and <code><code><a href="Algorithms-BWT-Alternative.html#v:bit_adder">bit_adder</a></code> <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code></code> is
 a one-bit subtracter (i.e., add the 2's complement of <em>y</em>).
</p></div></div><div class="top"><p class="src"><a name="v:cdoweld1" class="def">cdoweld1</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Quipper-Monad.html#t:Bit">Bit</a> -&gt; <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a><a href="src/Algorithms/BWT/Alternative.html#line-468" class="link">Source</a></p><div class="doc"><p>Input an <em>n</em>+1-bit leaf node <em>a</em>:<em>aa</em> (without the tree bit; <em>a</em>
 is the highest bit and <em>aa</em> is the remaining <em>n</em> bits) and a sign
 <em>s</em> (where <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code> = negative, <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:False">False</a></code> = positive).  Return
 <em>a</em>:(<em>aa</em> + <em>s</em> * <em>f</em>). The first input is the <em>n</em>-bit welding
 vector <em>f</em> (a parameter to the oracle). Note that <em>f</em> is a
 parameter and <em>s</em>, <em>aa</em> are inputs.
</p></div></div><div class="top"><p class="src"><a name="v:cdoweld0" class="def">cdoweld0</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a><a href="src/Algorithms/BWT/Alternative.html#line-481" class="link">Source</a></p><div class="doc"><p>Input an <em>n</em>+1-bit leaf node <em>a</em>:<em>aa</em> (without the tree bit), and
 return <em>a</em>:(<em>aa</em> &#8853; <em>g</em>). The first input is the <em>n</em>-bit welding
 vector <em>g</em> (a parameter to the oracle).
</p></div></div><div class="top"><p class="src"><a name="v:cweld" class="def">cweld</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a> -&gt; <a href="Quipper-Monad.html#t:Bit">Bit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a><a href="src/Algorithms/BWT/Alternative.html#line-494" class="link">Source</a></p><div class="doc"><p>Input a leaf node <em>a</em> and return the left or right weld of <em>a</em> in
 the other tree (depending on whether the <em>weldbit</em> is <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:False">False</a></code> or
 <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code>).  Assumes that <em>a</em> is a leaf.
</p></div></div><div class="top"><p class="src"><a name="v:cchild" class="def">cchild</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a> -&gt; <a href="Quipper-Monad.html#t:Bit">Bit</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a><a href="src/Algorithms/BWT/Alternative.html#line-510" class="link">Source</a></p><div class="doc"><p>Input a node <em>a</em> and return the left or right child of <em>a</em>
 (depending on whether the <em>childbit</em> is <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:False">False</a></code> or <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code>. This
 works for leaf and non-leaf nodes.
</p></div></div><div class="top"><p class="src"><a name="v:clevel_parity" class="def">clevel_parity</a> :: <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Bit">Bit</a><a href="src/Algorithms/BWT/Alternative.html#line-531" class="link">Source</a></p><div class="doc"><p>Input a node address (without the tree bit) and return the parity
 of the node level expressed as a boolean either <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:False">False</a></code> or
 <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code>. Leaves have parity <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:False">False</a></code>, and other levels have
 alternating parities. In other words: count the number of leading
 zeros modulo 2.
</p></div></div><div class="top"><p class="src"><a name="v:cis_zero" class="def">cis_zero</a> :: <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Bit">Bit</a><a href="src/Algorithms/BWT/Alternative.html#line-552" class="link">Source</a></p><div class="doc"><p>Input a node address (without the tree bit) and return <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code> iff
 the node address is invalid. In other words, return <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code> iff the
 list consists of all 0's.
</p></div></div><div class="top"><p class="src"><a name="v:cis_root" class="def">cis_root</a> :: <a href="Quipper-Monad.html#t:Bitlist">Bitlist</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Bit">Bit</a><a href="src/Algorithms/BWT/Alternative.html#line-572" class="link">Source</a></p><div class="doc"><p>Input a node address (without the tree bit) and return <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code> iff
 the node is a root or invalid. In other words, check whether all
 digits but the last are 0's.
</p></div></div><div class="top"><p class="src"><a name="v:cv_function" class="def">cv_function</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> (<a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a>, <a href="Quipper-Monad.html#t:Bit">Bit</a>)<a href="src/Algorithms/BWT/Alternative.html#line-600" class="link">Source</a></p><div class="doc"><p><code><code><a href="Algorithms-BWT-Alternative.html#v:cv_function">cv_function</a></code> f g c a</code>: returns <em>v</em><sub><em>c</em></sub>(<em>a</em>), the label of the
 node connected to <em>a</em> by an edge of color <em>c</em>, or <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#v:Nothing">Nothing</a></code> if
 there is no such node. The parameters <em>f</em> and <em>g</em> encode the
 welding functions, and are lists of length <em>n</em>. <em>c</em> is a color in
 the range 0..3, and <em>a</em> is an (<em>n</em>+2)-bit node label.
</p><p>We currently implement <code><code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a></code></code> as an indexed union, and
 specifically as <code>(<code><a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a></code>,<code><a href="Quipper-Monad.html#t:Bit">Bit</a></code>)</code>. When <em>Bit</em>=<code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#v:True">True</a></code>, the value of
 <code><a href="Algorithms-BWT-Alternative.html#t:CNode">CNode</a></code> is undefined (doesn't matter); in particular, this value
 may contain garbage.
</p></div></div><h3 id="g:10">Oracle abstraction
</h3><div class="top"><p class="src"><a name="v:oracle_classical" class="def">oracle_classical</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Oracle">Oracle</a><a href="src/Algorithms/BWT/Alternative.html#line-642" class="link">Source</a></p><div class="doc"><p>The classical oracle implementation, packaged into the <code><a href="Algorithms-BWT-Alternative.html#t:Oracle">Oracle</a></code>
 abstraction. This oracle has two parameters, namely the welding
 vectors <em>f</em> and <em>g</em>. Note: this oracle has not been optimized
 whatsoever.
</p></div></div><h1 id="g:11">Testing functions
</h1><div class="top"><p class="src"><a name="v:main_edges1" class="def">main_edges1</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ()<a href="src/Algorithms/BWT/Alternative.html#line-667" class="link">Source</a></p><div class="doc"><p>Output the list of colored edges as computed by the classical
 <code><a href="Algorithms-BWT-Alternative.html#v:v_function">v_function</a></code>, for some arbitrary choice of <em>f</em> and <em>g</em> and <em>n</em>=3.
</p></div></div><div class="top"><p class="src"><a name="v:circfun" class="def">circfun</a> :: <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="Libraries-Auxiliary.html#t:Boollist">Boollist</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="Algorithms-BWT-Alternative.html#t:Node">Node</a> -&gt; (<a href="Algorithms-BWT-Alternative.html#t:Node">Node</a>, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a>)<a href="src/Algorithms/BWT/Alternative.html#line-685" class="link">Source</a></p><div class="doc"><p>For debugging: <code><a href="Algorithms-BWT-Alternative.html#v:circfun">circfun</a></code> is similar to <code><a href="Algorithms-BWT-Alternative.html#v:v_function">v_function</a></code>, except it
 works by calling <code><a href="Algorithms-BWT-Alternative.html#v:cv_function">cv_function</a></code> to assemble the circuit, then
 simulates it. This is for testing whether the assembled circuit is
 correct. Returns <code>(<code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></code>, <code><a href="Algorithms-BWT-Alternative.html#t:Node">Node</a></code>)</code> instead of <code><code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Maybe.html#t:Maybe">Maybe</a></code> <code><a href="Algorithms-BWT-Alternative.html#t:Node">Node</a></code></code>, so
 that we can see any garbage that is output in case of an invalid
 node.
</p></div></div><div class="top"><p class="src"><a name="v:main_edges2" class="def">main_edges2</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ()<a href="src/Algorithms/BWT/Alternative.html#line-693" class="link">Source</a></p><div class="doc"><p>Output the list of colored edges as computed by simulating the
 circuit <code><a href="Algorithms-BWT-Alternative.html#v:cv_function">cv_function</a></code>, for some arbitrary choice of <em>f</em> and <em>g</em> and
 <em>n</em>=3. This is like <code><a href="Algorithms-BWT-Alternative.html#v:main_edges1">main_edges1</a></code>, except it actually assembles and
 simulates the classical circuit.
</p></div></div><div class="top"><p class="src"><a name="v:main_oraclec" class="def">main_oraclec</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="Algorithms-BWT-BWT.html#t:Oracle">Oracle</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ()<a href="src/Algorithms/BWT/Alternative.html#line-707" class="link">Source</a></p><div class="doc"><p>Graphically output the classical oracle circuit for color <em>c</em>,
 using <em>n</em> from the oracle data structure, and for some arbitrary
 <em>f</em> and <em>g</em>.
</p></div></div><div class="top"><p class="src"><a name="v:main_oracle2" class="def">main_oracle2</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="Algorithms-BWT-BWT.html#t:Oracle">Oracle</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ()<a href="src/Algorithms/BWT/Alternative.html#line-720" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Algorithms-BWT-Alternative.html#v:main_oraclec">main_oraclec</a></code>, except it rewrites the classical circuit in
 terms of Toffoli gates.
</p></div></div><div class="top"><p class="src"><a name="v:main_oracle3" class="def">main_oracle3</a> :: <a href="Quipper-Printing.html#t:Format">Format</a> -&gt; <a href="Algorithms-BWT-BWT.html#t:Oracle">Oracle</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> -&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ()<a href="src/Algorithms/BWT/Alternative.html#line-733" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Algorithms-BWT-Alternative.html#v:main_oraclec">main_oraclec</a></code>, except it makes the classical circuit
 reversible first.
</p></div></div><div class="top"><p class="src"><a name="v:main_qrwbwt" class="def">main_qrwbwt</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/System-IO.html#t:IO">IO</a> ()<a href="src/Algorithms/BWT/Alternative.html#line-747" class="link">Source</a></p><div class="doc"><p>Output the top-level circuit for the binary welded tree algorithm
 with the classical oracle, using some arbitrary welding vectors <em>f</em>
 and <em>g</em>, and <em>s</em>=1.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.11.0</p></div></body></html>
