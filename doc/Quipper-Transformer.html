<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>Quipper.Transformer</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_Quipper-Transformer.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/Quipper/Transformer.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">Quipper.Transformer</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">An example transformer
</a></li><li><a href="#g:2">Bindings
</a></li><li><a href="#g:3">Transformers
</a></li><li><a href="#g:4">Applying transformers to circuits
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides functions for defining general-purpose
 transformations on low-level circuits. The uses of this include:
</p><ul><li> gate transformations, where a whole circuit is transformed by
 replacing each kind of gate with another gate or circuit;
</li><li> error correcting codes, where a whole circuit is transformed
 replacing each qubit by some fixed number of qubits, and each gate
 by a circuit; and
</li><li> simulations, where a whole circuit is mapped to a semantic
 function by specifying a semantic function for each gate.
</li></ul><p>The interface is designed to allow the programmer to specify new
 transformers easily. To define a specific transformation, the
 programmer has to specify only four pieces of information:
</p><ul><li> A type <em>a</em>=&#10214;Qubit&#10215;, to serve as a semantic domain for qubits.
</li><li> A type <em>b</em>=&#10214;Bit&#10215;, to serve as a semantic domain for bits.
</li><li> A monad <em>m</em>. This is to allow translations to have side effects
 if desired; one can use the identity monad otherwise.
</li><li> For every gate <em>G</em>, a corresponding semantic function &#10214;<em>G</em>&#10215;.  The
 type of this function depends on what kind of gate <em>G</em> is. For example:
</li></ul><pre>
 If <em>G</em> :: Qubit -&gt; Circ Qubit, then &#10214;<em>G</em>&#10215; :: <em>a</em> -&gt; <em>m</em> <em>a</em>. 
 If <em>G</em> :: (Qubit, Bit) -&gt; Circ (Bit, Bit), then &#10214;<em>G</em>&#10215; :: (<em>a</em>, <em>b</em>) -&gt; <em>m</em> (<em>b</em>, <em>b</em>).
</pre><p>The programmer provides this information by defining a function of
 type <code><a href="Quipper-Transformer.html#t:Transformer">Transformer</a></code> <em>m</em> <em>a</em> <em>b</em>. See <a href="#Transformers">#Transformers</a> below.  Once a
 particular transformer has been defined, it can then be applied to
 entire circuits. For example, for a circuit with 1 inputs and 2
 outputs:
</p><pre>
 If <em>C</em> :: Qubit -&gt; (Bit, Qubit), then &#10214;<em>C</em>&#10215; :: <em>a</em> -&gt; <em>m</em> (<em>b</em>, <em>a</em>).
</pre></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><span class="keyword">data</span>  <a href="#t:B_Endpoint">B_Endpoint</a> a b<ul class="subs"><li>= <a href="#v:Endpoint_Qubit">Endpoint_Qubit</a> a  </li><li>| <a href="#v:Endpoint_Bit">Endpoint_Bit</a> b  </li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:Bindings">Bindings</a> a b = Map <a href="Quipper-Circuit.html#t:Wire">Wire</a> (<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b)</li><li class="src short"><a href="#v:wires_of_bindings">wires_of_bindings</a> ::  <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;</li><li class="src short"><a href="#v:bindings_empty">bindings_empty</a> ::  <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b</li><li class="src short"><a href="#v:bind">bind</a> ::  <a href="Quipper-Circuit.html#t:Wire">Wire</a> -&gt; <a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b</li><li class="src short"><a href="#v:bind_qubit_wire">bind_qubit_wire</a> ::  <a href="Quipper-Circuit.html#t:Wire">Wire</a> -&gt; a -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b</li><li class="src short"><a href="#v:bind_bit_wire">bind_bit_wire</a> ::  <a href="Quipper-Circuit.html#t:Wire">Wire</a> -&gt; b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b</li><li class="src short"><a href="#v:unbind">unbind</a> ::  <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Circuit.html#t:Wire">Wire</a> -&gt; <a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b</li><li class="src short"><a href="#v:unbind_qubit_wire">unbind_qubit_wire</a> ::  <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Circuit.html#t:Wire">Wire</a> -&gt; a</li><li class="src short"><a href="#v:unbind_bit_wire">unbind_bit_wire</a> ::  <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Circuit.html#t:Wire">Wire</a> -&gt; b</li><li class="src short"><a href="#v:bind_delete">bind_delete</a> ::  <a href="Quipper-Circuit.html#t:Wire">Wire</a> -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b</li><li class="src short"><a href="#v:bind_list">bind_list</a> ::  &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b&#93; -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b</li><li class="src short"><a href="#v:bind_qubit_wire_list">bind_qubit_wire_list</a> ::  &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;a&#93; -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b</li><li class="src short"><a href="#v:bind_bit_wire_list">bind_bit_wire_list</a> ::  &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;b&#93; -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b</li><li class="src short"><a href="#v:unbind_list">unbind_list</a> ::  <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b&#93;</li><li class="src short"><a href="#v:unbind_qubit_wire_list">unbind_qubit_wire_list</a> ::  <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;a&#93;</li><li class="src short"><a href="#v:unbind_bit_wire_list">unbind_bit_wire_list</a> ::  <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;b&#93;</li><li class="src short"><span class="keyword">type</span> <a href="#t:Ctrls">Ctrls</a> a b = &#91;<a href="Quipper-Circuit.html#t:Signed">Signed</a> (<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b)&#93;</li><li class="src short"><a href="#v:bind_controls">bind_controls</a> ::  <a href="Quipper-Circuit.html#t:Controls">Controls</a> -&gt; <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b</li><li class="src short"><a href="#v:unbind_controls">unbind_controls</a> ::  <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Circuit.html#t:Controls">Controls</a> -&gt; <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b</li><li class="src short"><span class="keyword">data</span>  <a href="#t:T_Gate">T_Gate</a> m a b x<ul class="subs"><li>= <a href="#v:T_QGate">T_QGate</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="Quipper-Circuit.html#t:InverseFlag">InverseFlag</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((&#91;a&#93; -&gt; &#91;a&#93; -&gt; <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b -&gt; m (&#91;a&#93;, &#91;a&#93;, <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)  </li><li>| <a href="#v:T_QRot">T_QRot</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="Quipper-Circuit.html#t:InverseFlag">InverseFlag</a> <a href="Quipper-Circuit.html#t:Timestep">Timestep</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((&#91;a&#93; -&gt; &#91;a&#93; -&gt; <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b -&gt; m (&#91;a&#93;, &#91;a&#93;, <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)  </li><li>| <a href="#v:T_GPhase">T_GPhase</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((&#91;<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b&#93; -&gt; <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b -&gt; m (<a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)  </li><li>| <a href="#v:T_CNot">T_CNot</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((b -&gt; <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b -&gt; m (b, <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)  </li><li>| <a href="#v:T_CGate">T_CGate</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((&#91;b&#93; -&gt; m (b, &#91;b&#93;)) -&gt; x)  </li><li>| <a href="#v:T_CGateInv">T_CGateInv</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((b -&gt; &#91;b&#93; -&gt; m &#91;b&#93;) -&gt; x)  </li><li>| <a href="#v:T_CSwap">T_CSwap</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((b -&gt; b -&gt; <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b -&gt; m (b, b, <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)  </li><li>| <a href="#v:T_QPrep">T_QPrep</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((b -&gt; m a) -&gt; x)  </li><li>| <a href="#v:T_QUnprep">T_QUnprep</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((a -&gt; m b) -&gt; x)  </li><li>| <a href="#v:T_QInit">T_QInit</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> (m a -&gt; x)  </li><li>| <a href="#v:T_CInit">T_CInit</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> (m b -&gt; x)  </li><li>| <a href="#v:T_QTerm">T_QTerm</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((a -&gt; m ()) -&gt; x)  </li><li>| <a href="#v:T_CTerm">T_CTerm</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((b -&gt; m ()) -&gt; x)  </li><li>| <a href="#v:T_QMeas">T_QMeas</a> ((a -&gt; m b) -&gt; x)  </li><li>| <a href="#v:T_QDiscard">T_QDiscard</a> ((a -&gt; m ()) -&gt; x)  </li><li>| <a href="#v:T_CDiscard">T_CDiscard</a> ((b -&gt; m ()) -&gt; x)  </li><li>| <a href="#v:T_DTerm">T_DTerm</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> ((b -&gt; m ()) -&gt; x)  </li><li>| <a href="#v:T_Subroutine">T_Subroutine</a> <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> <a href="Quipper-Circuit.html#t:InverseFlag">InverseFlag</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> <a href="Quipper-Circuit.html#t:ControllableFlag">ControllableFlag</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:Arity">Arity</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:Arity">Arity</a> <a href="Quipper-Circuit.html#t:RepeatFlag">RepeatFlag</a> ((<a href="Quipper-Circuit.html#t:Namespace">Namespace</a> -&gt; &#91;<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b&#93; -&gt; <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b -&gt; m (&#91;<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b&#93;, <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)  </li><li>| <a href="#v:T_Comment">T_Comment</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper-Circuit.html#t:InverseFlag">InverseFlag</a> ((&#91;(<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>)&#93; -&gt; m ()) -&gt; x)  </li></ul></li><li class="src short"><span class="keyword">type</span> <a href="#t:Transformer">Transformer</a> m a b = <span class="keyword">forall</span> x.  <a href="Quipper-Transformer.html#t:T_Gate">T_Gate</a> m a b x -&gt; x</li><li class="src short"><span class="keyword">type</span> <a href="#t:BT">BT</a> m a b = <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; m (<a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b)</li><li class="src short"><a href="#v:bind_gate">bind_gate</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Quipper-Circuit.html#t:Namespace">Namespace</a> -&gt; <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; <a href="Quipper-Transformer.html#t:T_Gate">T_Gate</a> m a b (<a href="Quipper-Transformer.html#t:BT">BT</a> m a b)</li><li class="src short"><a href="#v:transform_circuit">transform_circuit</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Quipper-Transformer.html#t:Transformer">Transformer</a> m a b -&gt; <a href="Quipper-Circuit.html#t:Circuit">Circuit</a> -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; m (<a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b)</li><li class="src short"><a href="#v:transform_bcircuit_rec">transform_bcircuit_rec</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Quipper-Transformer.html#t:Transformer">Transformer</a> m a b -&gt; <a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a> -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; m (<a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b)</li><li class="src short"><a href="#v:transform_bcircuit_id">transform_bcircuit_id</a> ::  <a href="Quipper-Transformer.html#t:Transformer">Transformer</a> <a href="Libraries-Auxiliary.html#t:Id">Id</a> a b -&gt; <a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a> -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b</li><li class="src short"><span class="keyword">data</span>  <a href="#t:DynamicTransformer">DynamicTransformer</a> m a b = <a href="#v:DT">DT</a> {<ul class="subs"><li><a href="#v:transformer">transformer</a> :: <a href="Quipper-Transformer.html#t:Transformer">Transformer</a> m a b</li><li><a href="#v:define_subroutine">define_subroutine</a> :: <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> -&gt; <a href="Quipper-Circuit.html#t:TypedSubroutine">TypedSubroutine</a> -&gt; m ()</li><li><a href="#v:lifting_function">lifting_function</a> :: b -&gt; m <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></li></ul>}</li><li class="src short"><a href="#v:transform_dbcircuit">transform_dbcircuit</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Quipper-Transformer.html#t:DynamicTransformer">DynamicTransformer</a> m a b -&gt; <a href="Quipper-Circuit.html#t:DBCircuit">DBCircuit</a> x -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; m (x, <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b)</li></ul></div><div id="interface"><h1 id="g:1">An example transformer
</h1><div class="doc"><p>The following is a short but complete example of how to write and
 use a simple transformer. As usual, we start by importing Quipper:
</p><pre> import Quipper
</pre><p>We will write a transformer called <code>sample_transformer</code>, which maps
 every swap gate to a sequence of three controlled-not gates, and
 leaves all other gates unchanged. For convenience, Quipper
 pre-defines an <code>identity_transformer</code>, which can be used as a
 catch-all clause to take care of all the gates that don't need to
 be rewritten.
</p><pre> mytransformer :: Transformer Circ Qubit Bit
 mytransformer (T_QGate &quot;swap&quot; 2 0 _ ncf f) = f $
   \&#91;q0, q1&#93; &#91;&#93; ctrls -&gt; do
     without_controls_if ncf $ do
       with_controls ctrls $ do
         qnot_at q0 `controlled` q1
         qnot_at q1 `controlled` q0
         qnot_at q0 `controlled` q1
         return (&#91;q0, q1&#93;, &#91;&#93;, ctrls)
 mytransformer g = identity_transformer g
</pre><p>Note how Quipper syntax has been used to define the replacement
 circuit, consisting of three controlled-not gates. Also, since the
 original swap gate may have been controlled, we have added the
 additional controls with a <code>with_controls</code> operator.
</p><p>To try this out, we define some random circuit using swap gates:
</p><pre> mycirc a b c d = do
   swap_at a b
   hadamard_at b
   swap_at b c `controlled` &#91;a, d&#93;
   hadamard_at c
   swap_at c d
</pre><p>To apply the transformer to this circuit, we use the generic
 operator <code>transform_generic</code>:
</p><pre> mycirc2 = transform_generic mytransformer mycirc
</pre><p>Finally, we use a <code>main</code> function to display the original circuit
 and then the transformed one:
</p><pre> main = do
   print_simple Preview mycirc
   print_simple Preview mycirc2
</pre></div><h1 id="g:2">Bindings
</h1><div class="doc"><p>We introduce the notion of a <em>binding</em> as a low-level way to
 describe functions of varying arities. A binding assigns a value to
 a wire in a circuit (much like a &quot;valuation&quot; in logic or semantics
 assigns values to variables). 
</p><p>To iterate through a circuit, one will typically specify initial
 bindings for the input wires. This encodes the input of the function
 &#10214;<em>C</em>&#10215; mentioned in the introduction. The bindings are updated as
 one passes through each gate. When the iteration is finished, the
 final bindings assign a value to each output wire of the
 circuit. This encodes the output of the function &#10214;<em>C</em>&#10215;. Therefore,
 the interpretation of a circuit is representable as a function from
 bindings (of input wires) to bindings (of output wires), i.e., it
 has the type &#10214;<em>C</em>&#10215; :: <code><a href="Quipper-Transformer.html#t:Bindings">Bindings</a></code> <em>a</em> <em>b</em> -&gt; <code><a href="Quipper-Transformer.html#t:Bindings">Bindings</a></code> <em>a</em> <em>b</em>.
</p></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:B_Endpoint" class="def">B_Endpoint</a> a b <a href="src/Quipper/Transformer.html#line-149" class="link">Source</a></p><div class="doc"><p>An <em>endpoint</em> is either a <em>qubit</em> or a <em>bit</em>. In a transformer,
 we have &#10214;Endpoint Qubit Bit&#10215; = &#10214;Qubit&#10215; + &#10214;Bit&#10215;. The type <code>Endpoint</code>
 <em>a</em> <em>b</em> is the same as <code><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Either.html#t:Either">Either</a></code> <em>a</em> <em>b</em>, but we use more suggestive
 field names.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:Endpoint_Qubit" class="def">Endpoint_Qubit</a> a</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:Endpoint_Bit" class="def">Endpoint_Bit</a> b</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:B_Endpoint" class="caption collapser" onclick="toggleSection('i:B_Endpoint')">Instances</p><div id="section.i:B_Endpoint" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Typeable-Internal.html#t:Typeable2">Typeable2</a> <a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper-Control.html#t:ControlSource">ControlSource</a> (<a href="Quipper-Circuit.html#t:Signed">Signed</a> a), <a href="Quipper-Control.html#t:ControlSource">ControlSource</a> (<a href="Quipper-Circuit.html#t:Signed">Signed</a> b)) =&gt; <a href="Quipper-Control.html#t:ControlSource">ControlSource</a> (<a href="Quipper-Circuit.html#t:Signed">Signed</a> (<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b))</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> b) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Eq.html#t:Eq">Eq</a> (<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a> b) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Ord.html#t:Ord">Ord</a> (<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> a, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> b) =&gt; <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper-Control.html#t:ControlSource">ControlSource</a> a, <a href="Quipper-Control.html#t:ControlSource">ControlSource</a> b) =&gt; <a href="Quipper-Control.html#t:ControlSource">ControlSource</a> (<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper-QData.html#t:QCData">QCData</a> a, <a href="Quipper-QData.html#t:QCData">QCData</a> b) =&gt; <a href="Quipper-QData.html#t:QCData">QCData</a> (<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper-Labels.html#t:Labelable">Labelable</a> a <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>, <a href="Quipper-Labels.html#t:Labelable">Labelable</a> b <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>) =&gt; <a href="Quipper-Labels.html#t:Labelable">Labelable</a> (<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b) <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a></td><td class="doc empty">&nbsp;</td></tr><tr><td class="src">(<a href="Quipper-Labels.html#t:Labelable">Labelable</a> a s, <a href="Quipper-Labels.html#t:Labelable">Labelable</a> b t) =&gt; <a href="Quipper-Labels.html#t:Labelable">Labelable</a> (<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b) (<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> s t)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Bindings" class="def">Bindings</a> a b = Map <a href="Quipper-Circuit.html#t:Wire">Wire</a> (<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b)<a href="src/Quipper/Transformer.html#line-156" class="link">Source</a></p><div class="doc"><p>A binding is a map from a set of wires to the disjoint union of
 <em>a</em> and <em>b</em>.
</p></div></div><div class="top"><p class="src"><a name="v:wires_of_bindings" class="def">wires_of_bindings</a> ::  <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93;<a href="src/Quipper/Transformer.html#line-159" class="link">Source</a></p><div class="doc"><p>Return the list of bound wires from a binding.
</p></div></div><div class="top"><p class="src"><a name="v:bindings_empty" class="def">bindings_empty</a> ::  <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b<a href="src/Quipper/Transformer.html#line-163" class="link">Source</a></p><div class="doc"><p>The empty binding.
</p></div></div><div class="top"><p class="src"><a name="v:bind" class="def">bind</a> ::  <a href="Quipper-Circuit.html#t:Wire">Wire</a> -&gt; <a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b<a href="src/Quipper/Transformer.html#line-167" class="link">Source</a></p><div class="doc"><p>Bind a wire to a value, and add it to the given bindings.
</p></div></div><div class="top"><p class="src"><a name="v:bind_qubit_wire" class="def">bind_qubit_wire</a> ::  <a href="Quipper-Circuit.html#t:Wire">Wire</a> -&gt; a -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b<a href="src/Quipper/Transformer.html#line-171" class="link">Source</a></p><div class="doc"><p>Bind a qubit wire to a value, and add it to the given bindings.
</p></div></div><div class="top"><p class="src"><a name="v:bind_bit_wire" class="def">bind_bit_wire</a> ::  <a href="Quipper-Circuit.html#t:Wire">Wire</a> -&gt; b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b<a href="src/Quipper/Transformer.html#line-175" class="link">Source</a></p><div class="doc"><p>Bind a bit wire to a value, and add it to the given bindings.
</p></div></div><div class="top"><p class="src"><a name="v:unbind" class="def">unbind</a> ::  <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Circuit.html#t:Wire">Wire</a> -&gt; <a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b<a href="src/Quipper/Transformer.html#line-179" class="link">Source</a></p><div class="doc"><p>Retrieve the value of a wire from the given bindings. 
</p></div></div><div class="top"><p class="src"><a name="v:unbind_qubit_wire" class="def">unbind_qubit_wire</a> ::  <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Circuit.html#t:Wire">Wire</a> -&gt; a<a href="src/Quipper/Transformer.html#line-186" class="link">Source</a></p><div class="doc"><p>Retrieve the value of a qubit wire from the given bindings.
 Throws an error if the wire was bound to a classical bit.
</p></div></div><div class="top"><p class="src"><a name="v:unbind_bit_wire" class="def">unbind_bit_wire</a> ::  <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Circuit.html#t:Wire">Wire</a> -&gt; b<a href="src/Quipper/Transformer.html#line-194" class="link">Source</a></p><div class="doc"><p>Retrieve the value of a bit wire from the given bindings.
 Throws an error if the wire was bound to a qubit.
</p></div></div><div class="top"><p class="src"><a name="v:bind_delete" class="def">bind_delete</a> ::  <a href="Quipper-Circuit.html#t:Wire">Wire</a> -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b<a href="src/Quipper/Transformer.html#line-201" class="link">Source</a></p><div class="doc"><p>Delete a wire from the given bindings.
</p></div></div><div class="top"><p class="src"><a name="v:bind_list" class="def">bind_list</a> ::  &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b&#93; -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b<a href="src/Quipper/Transformer.html#line-206" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper-Transformer.html#v:bind">bind</a></code>, except bind a list of wires to a list of values. The
 lists must be of the same length.
</p></div></div><div class="top"><p class="src"><a name="v:bind_qubit_wire_list" class="def">bind_qubit_wire_list</a> ::  &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;a&#93; -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b<a href="src/Quipper/Transformer.html#line-212" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper-Transformer.html#v:bind_qubit_wire">bind_qubit_wire</a></code>, except bind a list of qubit wires to a list of
 values. The lists must be of the same length.
</p></div></div><div class="top"><p class="src"><a name="v:bind_bit_wire_list" class="def">bind_bit_wire_list</a> ::  &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;b&#93; -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b<a href="src/Quipper/Transformer.html#line-218" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper-Transformer.html#v:bind_bit_wire">bind_bit_wire</a></code>, except bind a list of bit wires to a list of
 values. The lists must be of the same length.
</p></div></div><div class="top"><p class="src"><a name="v:unbind_list" class="def">unbind_list</a> ::  <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b&#93;<a href="src/Quipper/Transformer.html#line-223" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper-Transformer.html#v:unbind">unbind</a></code>, except retrieve a list of values.
</p></div></div><div class="top"><p class="src"><a name="v:unbind_qubit_wire_list" class="def">unbind_qubit_wire_list</a> ::  <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;a&#93;<a href="src/Quipper/Transformer.html#line-228" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper-Transformer.html#v:unbind_qubit_wire">unbind_qubit_wire</a></code>, except retrieve a list of values.
</p></div></div><div class="top"><p class="src"><a name="v:unbind_bit_wire_list" class="def">unbind_bit_wire_list</a> ::  <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; -&gt; &#91;b&#93;<a href="src/Quipper/Transformer.html#line-233" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper-Transformer.html#v:unbind_bit_wire">unbind_bit_wire</a></code>, except retrieve a list of values.
</p></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Ctrls" class="def">Ctrls</a> a b = &#91;<a href="Quipper-Circuit.html#t:Signed">Signed</a> (<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b)&#93;<a href="src/Quipper/Transformer.html#line-239" class="link">Source</a></p><div class="doc"><p>A list of signed values of type &#10214;Endpoint&#10215;. This type is an
 abbreviation defined for convenience.
</p></div></div><div class="top"><p class="src"><a name="v:bind_controls" class="def">bind_controls</a> ::  <a href="Quipper-Circuit.html#t:Controls">Controls</a> -&gt; <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b<a href="src/Quipper/Transformer.html#line-243" class="link">Source</a></p><div class="doc"><p>Given a list of signed wires (controls), and a list of signed
 values, make a bindings from the wires to the values. Ignore the signs.
</p></div></div><div class="top"><p class="src"><a name="v:unbind_controls" class="def">unbind_controls</a> ::  <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Circuit.html#t:Controls">Controls</a> -&gt; <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b<a href="src/Quipper/Transformer.html#line-249" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper-Transformer.html#v:unbind">unbind</a></code>, but retrieve binding for all wires in a list of
 controls.
</p></div></div><div class="doc"><p><a name="Transformers"></a>
</p></div><h1 id="g:3">Transformers
</h1><div class="doc"><p>The types <code><a href="Quipper-Transformer.html#t:T_Gate">T_Gate</a></code> and <code><a href="Quipper-Transformer.html#t:Transformer">Transformer</a></code> are at the heart of the
 circuit transformer functionality. Their purpose is to give a
 concise syntax in which to express semantic functions for gates. As
 mentioned in the introduction, the programmer needs to specify two
 type <em>a</em> and <em>b</em>, a monad <em>m</em>, and a semantic function for each
 gate.  With the T_Gate' and <code><a href="Quipper-Transformer.html#t:Transformer">Transformer</a></code> types, the definition
 takes the following form:
</p><pre> my_transformer :: Transformer m a b
 my_transformer (T_Gate1 &lt;parameters&gt; f) = f $ &lt;semantic function for gate 1&gt;
 my_transformer (T_Gate2 &lt;parameters&gt; f) = f $ &lt;semantic function for gate 2&gt;
 my_transformer (T_Gate3 &lt;parameters&gt; f) = f $ &lt;semantic function for gate 3&gt;
 ...
</pre><p>The type <code><a href="Quipper-Transformer.html#t:T_Gate">T_Gate</a></code> is very higher-order, involving a function <em>f</em>
 that consumes the semantic function for each gate. The reason for
 this higher-orderness is that the semantic functions for different
 gates may have different types. 
</p><p>This higher-orderness makes the <code><a href="Quipper-Transformer.html#t:T_Gate">T_Gate</a></code> mechanism hard to read,
 but easy to use. Effectively we only have to write lengthy and
 messy code once and for all, rather than once for each transformer.
 In particular, all the required low-level bindings and unbindings
 can be handled by general-purpose code, and do not need to clutter
 each transformer. 
</p></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:T_Gate" class="def">T_Gate</a> m a b x <a href="src/Quipper/Transformer.html#line-298" class="link">Source</a></p><div class="doc"><p>The type <code><a href="Quipper-Transformer.html#t:T_Gate">T_Gate</a></code> is used to define case distinctions over gates
 in the definition of transformers. For each kind of gate <em>X</em>, it
 contains a constructor of the form <code>(T_X f)</code>. Here, <em>X</em> identifies
 the gate, and <em>f</em> is a higher-order function to pass the
 translation of <em>X</em> to.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:T_QGate" class="def">T_QGate</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="Quipper-Circuit.html#t:InverseFlag">InverseFlag</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((&#91;a&#93; -&gt; &#91;a&#93; -&gt; <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b -&gt; m (&#91;a&#93;, &#91;a&#93;, <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_QRot" class="def">T_QRot</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Int.html#t:Int">Int</a> <a href="Quipper-Circuit.html#t:InverseFlag">InverseFlag</a> <a href="Quipper-Circuit.html#t:Timestep">Timestep</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((&#91;a&#93; -&gt; &#91;a&#93; -&gt; <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b -&gt; m (&#91;a&#93;, &#91;a&#93;, <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_GPhase" class="def">T_GPhase</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Prelude.html#t:Double">Double</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((&#91;<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b&#93; -&gt; <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b -&gt; m (<a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_CNot" class="def">T_CNot</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((b -&gt; <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b -&gt; m (b, <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_CGate" class="def">T_CGate</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((&#91;b&#93; -&gt; m (b, &#91;b&#93;)) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_CGateInv" class="def">T_CGateInv</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((b -&gt; &#91;b&#93; -&gt; m &#91;b&#93;) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_CSwap" class="def">T_CSwap</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((b -&gt; b -&gt; <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b -&gt; m (b, b, <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_QPrep" class="def">T_QPrep</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((b -&gt; m a) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_QUnprep" class="def">T_QUnprep</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((a -&gt; m b) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_QInit" class="def">T_QInit</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> (m a -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_CInit" class="def">T_CInit</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> (m b -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_QTerm" class="def">T_QTerm</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((a -&gt; m ()) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_CTerm" class="def">T_CTerm</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> ((b -&gt; m ()) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_QMeas" class="def">T_QMeas</a> ((a -&gt; m b) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_QDiscard" class="def">T_QDiscard</a> ((a -&gt; m ()) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_CDiscard" class="def">T_CDiscard</a> ((b -&gt; m ()) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_DTerm" class="def">T_DTerm</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a> ((b -&gt; m ()) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_Subroutine" class="def">T_Subroutine</a> <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> <a href="Quipper-Circuit.html#t:InverseFlag">InverseFlag</a> <a href="Quipper-Circuit.html#t:NoControlFlag">NoControlFlag</a> <a href="Quipper-Circuit.html#t:ControllableFlag">ControllableFlag</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:Arity">Arity</a> &#91;<a href="Quipper-Circuit.html#t:Wire">Wire</a>&#93; <a href="Quipper-Circuit.html#t:Arity">Arity</a> <a href="Quipper-Circuit.html#t:RepeatFlag">RepeatFlag</a> ((<a href="Quipper-Circuit.html#t:Namespace">Namespace</a> -&gt; &#91;<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b&#93; -&gt; <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b -&gt; m (&#91;<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b&#93;, <a href="Quipper-Transformer.html#t:Ctrls">Ctrls</a> a b)) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr><tr><td class="src"><a name="v:T_Comment" class="def">T_Comment</a> <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a> <a href="Quipper-Circuit.html#t:InverseFlag">InverseFlag</a> ((&#91;(<a href="Quipper-Transformer.html#t:B_Endpoint">B_Endpoint</a> a b, <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-String.html#t:String">String</a>)&#93; -&gt; m ()) -&gt; x)</td><td class="doc empty">&nbsp;</td></tr></table></div><div class="subs instances"><p id="control.i:T_Gate" class="caption collapser" onclick="toggleSection('i:T_Gate')">Instances</p><div id="section.i:T_Gate" class="show"><table><tr><td class="src"><a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Text-Show.html#t:Show">Show</a> (<a href="Quipper-Transformer.html#t:T_Gate">T_Gate</a> m a b x)</td><td class="doc empty">&nbsp;</td></tr></table></div></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:Transformer" class="def">Transformer</a> m a b = <span class="keyword">forall</span> x.  <a href="Quipper-Transformer.html#t:T_Gate">T_Gate</a> m a b x -&gt; x<a href="src/Quipper/Transformer.html#line-360" class="link">Source</a></p><div class="doc"><p>A circuit transformer is specified by defining a function of type
 <code><a href="Quipper-Transformer.html#t:Transformer">Transformer</a></code> <em>m</em> <em>a</em> <em>b</em>. This involves specifying a monad <em>m</em>,
 semantic domains <em>a</em>=&#10214;Qubit&#10215; and <em>b</em>=&#10214;Bit&#10215;, and a semantic function
 for each gate, like this:
</p><pre> my_transformer :: Transformer m a b
 my_transformer (T_Gate1 &lt;parameters&gt; f) = f $ &lt;semantic function for gate 1&gt;
 my_transformer (T_Gate2 &lt;parameters&gt; f) = f $ &lt;semantic function for gate 2&gt;
 my_transformer (T_Gate3 &lt;parameters&gt; f) = f $ &lt;semantic function for gate 3&gt;
 ...
</pre></div></div><div class="top"><p class="src"><span class="keyword">type</span> <a name="t:BT" class="def">BT</a> m a b = <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; m (<a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b)<a href="src/Quipper/Transformer.html#line-368" class="link">Source</a></p><div class="doc"><p>A &quot;binding transformer&quot; is a function from bindings to
 bindings. The semantics of any gate or circuit is ultimately a
 binding transformer, for some types <em>a</em>, <em>b</em> and some monad <em>m</em>. We
 introduce an abbreviation for this type primarily as a convenience
 for the definition of <code><a href="Quipper-Transformer.html#v:bind_gate">bind_gate</a></code>, but also because this type can
 be completely hidden from user code.
</p></div></div><div class="top"><p class="src"><a name="v:bind_gate" class="def">bind_gate</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Quipper-Circuit.html#t:Namespace">Namespace</a> -&gt; <a href="Quipper-Circuit.html#t:Gate">Gate</a> -&gt; <a href="Quipper-Transformer.html#t:T_Gate">T_Gate</a> m a b (<a href="Quipper-Transformer.html#t:BT">BT</a> m a b)<a href="src/Quipper/Transformer.html#line-376" class="link">Source</a></p><div class="doc"><p>Turn a <code><a href="Quipper-Circuit.html#t:Gate">Gate</a></code> into a <code><a href="Quipper-Transformer.html#t:T_Gate">T_Gate</a></code>. This is the function that actually
 handles the explicit bindings/unbindings required for the inputs
 and outputs of each gate. Effectively it gives a way, for each
 gate, of turning a semantic function into a binding transformer.
 Additionally, this function is passed a Namespace, so that the
 semantic function for T_Subroutine can use it.
</p></div></div><h1 id="g:4">Applying transformers to circuits
</h1><div class="top"><p class="src"><a name="v:transform_circuit" class="def">transform_circuit</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Quipper-Transformer.html#t:Transformer">Transformer</a> m a b -&gt; <a href="Quipper-Circuit.html#t:Circuit">Circuit</a> -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; m (<a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b)<a href="src/Quipper/Transformer.html#line-552" class="link">Source</a></p><div class="doc"><p>Apply a <code><a href="Quipper-Transformer.html#t:Transformer">Transformer</a></code> &#10214;-&#10215; to a <code><a href="Quipper-Circuit.html#t:Circuit">Circuit</a></code> <em>C</em>, and output the
 semantic function &#10214;<em>C</em>&#10215; :: bindings -&gt; bindings.
</p></div></div><div class="top"><p class="src"><a name="v:transform_bcircuit_rec" class="def">transform_bcircuit_rec</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Quipper-Transformer.html#t:Transformer">Transformer</a> m a b -&gt; <a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a> -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; m (<a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b)<a href="src/Quipper/Transformer.html#line-570" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper-Transformer.html#v:transform_circuit">transform_circuit</a></code>, but for boxed circuits.
</p><p>The handling of subroutines will depend on the transformer. 
 For &quot;gate transformation&quot; types of applications, one typically
 would like to leave the boxed structure intact.
 For &quot;simulation&quot; types of applications, one would generally
 recurse through the boxed structure.
</p><p>The difference is specified in the definition of the transformer
 within the semantic function of the Subroutine gate, whether to
 create another boxed gate or open the box.
</p></div></div><div class="top"><p class="src"><a name="v:transform_bcircuit_id" class="def">transform_bcircuit_id</a> ::  <a href="Quipper-Transformer.html#t:Transformer">Transformer</a> <a href="Libraries-Auxiliary.html#t:Id">Id</a> a b -&gt; <a href="Quipper-Circuit.html#t:BCircuit">BCircuit</a> -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b<a href="src/Quipper/Transformer.html#line-579" class="link">Source</a></p><div class="doc"><p>Same as <code><a href="Quipper-Transformer.html#v:transform_bcircuit_rec">transform_bcircuit_rec</a></code>, but specialized to when <em>m</em> is
 the identity operation.
</p></div></div><div class="top"><p class="src"><span class="keyword">data</span>  <a name="t:DynamicTransformer" class="def">DynamicTransformer</a> m a b <a href="src/Quipper/Transformer.html#line-586" class="link">Source</a></p><div class="doc"><p>To transform Dynamic Boxed circuits, we require a Transformer to define the
 behavior on static gates, but we also require functions for what to do when
 a subroutine is defined, and for when a dynamic_lift operation occurs. This is
 all wrapped in the DynamicTransformer data type.
</p></div><div class="subs constructors"><p class="caption">Constructors</p><table><tr><td class="src"><a name="v:DT" class="def">DT</a></td><td class="doc empty">&nbsp;</td></tr><tr><td colspan="2"><div class="subs fields"><p class="caption">Fields</p><dl><dt class="src"><a name="v:transformer" class="def">transformer</a> :: <a href="Quipper-Transformer.html#t:Transformer">Transformer</a> m a b</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:define_subroutine" class="def">define_subroutine</a> :: <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> -&gt; <a href="Quipper-Circuit.html#t:TypedSubroutine">TypedSubroutine</a> -&gt; m ()</dt><dd class="doc empty">&nbsp;</dd><dt class="src"><a name="v:lifting_function" class="def">lifting_function</a> :: b -&gt; m <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Data-Bool.html#t:Bool">Bool</a></dt><dd class="doc empty">&nbsp;</dd></dl><div class="clear"></div></div></td></tr></table></div></div><div class="top"><p class="src"><a name="v:transform_dbcircuit" class="def">transform_dbcircuit</a> :: <a href="http://hackage.haskell.org/packages/archive/base/4.5.1.0/doc/html/Control-Monad.html#t:Monad">Monad</a> m =&gt; <a href="Quipper-Transformer.html#t:DynamicTransformer">DynamicTransformer</a> m a b -&gt; <a href="Quipper-Circuit.html#t:DBCircuit">DBCircuit</a> x -&gt; <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b -&gt; m (x, <a href="Quipper-Transformer.html#t:Bindings">Bindings</a> a b)<a href="src/Quipper/Transformer.html#line-598" class="link">Source</a></p><div class="doc"><p>Like <code><a href="Quipper-Transformer.html#v:transform_bcircuit_rec">transform_bcircuit_rec</a></code>, but for dynamic-boxed circuits.
</p><p>&quot;Write&quot; operations can be thought of as gates, and so they are passed to 
 the given transformer. The handling of &quot;Read&quot; operations is taken care of 
 by the &quot;lifting_function&quot; of the DynamicTransformer. &quot;Subroutine&quot; operations 
 call the <code><a href="Quipper-Transformer.html#v:define_subroutine">define_subroutine</a></code> function of the DynamicTransformer.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.11.0</p></div></body></html>
