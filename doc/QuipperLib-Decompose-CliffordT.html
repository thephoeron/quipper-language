<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>QuipperLib.Decompose.CliffordT</title><link href="ocean.css" rel="stylesheet" type="text/css" title="Ocean" /><script src="haddock-util.js" type="text/javascript"></script><script type="text/javascript">//<![CDATA[
window.onload = function () {pageLoad();setSynopsis("mini_QuipperLib-Decompose-CliffordT.html");};
//]]>
</script></head><body><div id="package-header"><ul class="links" id="page-menu"><li><a href="src/QuipperLib/Decompose/CliffordT.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul><p class="caption">The Quipper System</p></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr></table><p class="caption">QuipperLib.Decompose.CliffordT</p></div><div id="table-of-contents"><p class="caption">Contents</p><ul><li><a href="#g:1">Auxiliary functions
</a></li><li><a href="#g:2">Transformers
</a><ul><li><a href="#g:3">Control trimming
</a></li><li><a href="#g:4">Approximate Clifford+<em>T</em> decomposition
</a></li><li><a href="#g:5">Exact Clifford+<em>T</em> decomposition
</a></li><li><a href="#g:6">Decomposition into standard gate set
</a></li><li><a href="#g:7">Decomposition into strict gate set
</a></li></ul></li><li><a href="#g:8">Glue code for subroutines
</a></li><li><a href="#g:9">Generic transformers
</a></li></ul></div><div id="description"><p class="caption">Description</p><div class="doc"><p>This module provides transformers for decomposing circuits into
 the Clifford+<em>T</em> gate base.
</p><ul><li> <b>Control trimming.</b> This transformer uses doubly-controlled
 <em>iX</em>-gates to reduce the number of controls on gates. Specifically,
 it ensures that not-gates, Pauli <em>X</em>-, <em>Y</em>-, and <em>Z</em>-gates, and
 <em>iX</em>-gates have at most two controls; that phase gates of the form
 Diag(1, &#966;) have no controls; and that all other gates have at most
 one control.
</li><li> <b>Approximate Clifford+<em>T</em> decomposition.</b> This decomposes
 all rotation and phase gates into Clifford+<em>T</em> up to a given
 precision &#949;, using an approximate synthesis algorithm. Other gates
 are unchanged.
</li><li> <b>Exact Clifford+<em>T</em> decomposition.</b> This decomposes all
 gates that are exactly representable in the Clifford+<em>T</em> base into
 single-qubit Clifford gates, <em>T</em>, <em>T</em><sup>&#8224;</sup>, and singly-controlled
 not-gates (with positive or negative control). Rotation and phase
 gates are left unchanged.
</li><li> <b>Standard gate set.</b> We define the standard gate set to
 consist of the gates <em>X</em>, <em>Y</em>, <em>Z</em>, <em>H</em>, <em>S</em>, <em>S</em><sup>&#8224;</sup>, <em>T</em>,
 <em>T</em><sup>&#8224;</sup>, and <em>CNOT</em>. This transformer decomposes all gates that
 remain after applying both approximate and exact Clifford+<em>T</em>
 decomposition into the standard gate set. If the transformer
 encounters gates that are not single-qubit Clifford gates, <em>T</em>,
 <em>T</em><sup>&#8224;</sup>, or singly-controlled not-gates (with positive or
 negative control), then the output is still semantically correct,
 but may not be in the standard gate set.  This transformer
 suppresses global phases.
</li><li> <b>Strict gate set.</b> We define the strict gate set to consist
 of the gates <em>H</em>, <em>S</em>, <em>T</em>, and <em>CNOT</em>. This transformer decomposes
 all gates that remain after applying both approximate and exact
 Clifford+<em>T</em> decomposition into the strict gate set. If the
 transformer encounters gates that are not single-qubit Clifford
 gates, <em>T</em>, <em>T</em><sup>&#8224;</sup>, or singly-controlled not-gates (with
 positive or negative control), then the output is still
 semantically correct, but may not be in the strict gate set. This
 transformer suppresses global phases.
</li></ul><p>These above transformers may be applied in any order. Control
 trimming is primarily for demonstration purposes; it does not need
 to be combined with the other transformers as they do their own
 trimming. The exact and approximate Clifford+<em>T</em> decompositions can
 be applied in either order; since they each target a different set
 of gates, they must both be performed to obtain a complete
 decomposition into the Clifford+<em>T</em> gate set. The standard and
 strict transformers assume that their input has already been
 pre-processed by the exact and approximate transformers.
</p></div></div><div id="synopsis"><p id="control.syn" class="caption expander" onclick="toggleSection('syn')">Synopsis</p><ul id="section.syn" class="hide" onclick="toggleSection('syn')"><li class="src short"><a href="#v:with_combined_controls_iX">with_combined_controls_iX</a> ::  <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; &#91;<a href="Quipper-Circuit.html#t:Signed">Signed</a> <a href="Quipper-Monad.html#t:Endpoint">Endpoint</a>&#93; -&gt; (&#91;<a href="Quipper-Circuit.html#t:Signed">Signed</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a</li><li class="src short"><a href="#v:with_combined_controls_CT">with_combined_controls_CT</a> ::  <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; &#91;<a href="Quipper-Circuit.html#t:Signed">Signed</a> <a href="Quipper-Monad.html#t:Endpoint">Endpoint</a>&#93; -&gt; (&#91;<a href="Quipper-Circuit.html#t:Signed">Signed</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a</li><li class="src short"><a href="#v:with_normalized_controls">with_normalized_controls</a> ::  &#91;<a href="Quipper-Circuit.html#t:Signed">Signed</a> <a href="Quipper-Monad.html#t:Endpoint">Endpoint</a>&#93; -&gt; (&#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a</li><li class="src short"><a href="#v:with_normalized_controls_HS">with_normalized_controls_HS</a> ::  &#91;<a href="Quipper-Circuit.html#t:Signed">Signed</a> <a href="Quipper-Monad.html#t:Endpoint">Endpoint</a>&#93; -&gt; (&#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a</li><li class="src short"><a href="#v:negate_if">negate_if</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a> r =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; r -&gt; r</li><li class="src short"><a href="#v:trimcontrols_transformer">trimcontrols_transformer</a> :: <a href="Quipper-Transformer.html#t:Transformer">Transformer</a> <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:approx_ct_transformer">approx_ct_transformer</a> :: <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; g -&gt; <a href="Quipper-Transformer.html#t:Transformer">Transformer</a> <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:exact_ct_transformer">exact_ct_transformer</a> :: <a href="Quipper-Transformer.html#t:Transformer">Transformer</a> <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:standard_transformer">standard_transformer</a> :: <a href="Quipper-Transformer.html#t:Transformer">Transformer</a> <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:strict_transformer">strict_transformer</a> :: <a href="Quipper-Transformer.html#t:Transformer">Transformer</a> <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:trimcontrols_subroutine">trimcontrols_subroutine</a> :: <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> -&gt; <a href="Quipper-Circuit.html#t:TypedSubroutine">TypedSubroutine</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:trimcontrols_dtransformer">trimcontrols_dtransformer</a> :: <a href="Quipper-Transformer.html#t:DynamicTransformer">DynamicTransformer</a> <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:trimcontrols_unary">trimcontrols_unary</a> :: (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb) =&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb</li><li class="src short"><a href="#v:approx_ct_subroutine">approx_ct_subroutine</a> :: <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; g -&gt; <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> -&gt; <a href="Quipper-Circuit.html#t:TypedSubroutine">TypedSubroutine</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:approx_ct_dtransformer">approx_ct_dtransformer</a> :: <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; g -&gt; <a href="Quipper-Transformer.html#t:DynamicTransformer">DynamicTransformer</a> <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:approx_ct_unary">approx_ct_unary</a> :: (<a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb) =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; g -&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb</li><li class="src short"><a href="#v:exact_ct_subroutine">exact_ct_subroutine</a> :: <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> -&gt; <a href="Quipper-Circuit.html#t:TypedSubroutine">TypedSubroutine</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:exact_ct_dtransformer">exact_ct_dtransformer</a> :: <a href="Quipper-Transformer.html#t:DynamicTransformer">DynamicTransformer</a> <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:exact_ct_unary">exact_ct_unary</a> :: (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb) =&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb</li><li class="src short"><a href="#v:standard_subroutine">standard_subroutine</a> :: <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> -&gt; <a href="Quipper-Circuit.html#t:TypedSubroutine">TypedSubroutine</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:standard_dtransformer">standard_dtransformer</a> :: <a href="Quipper-Transformer.html#t:DynamicTransformer">DynamicTransformer</a> <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:standard_unary">standard_unary</a> :: (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb) =&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb</li><li class="src short"><a href="#v:strict_subroutine">strict_subroutine</a> :: <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> -&gt; <a href="Quipper-Circuit.html#t:TypedSubroutine">TypedSubroutine</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()</li><li class="src short"><a href="#v:strict_dtransformer">strict_dtransformer</a> :: <a href="Quipper-Transformer.html#t:DynamicTransformer">DynamicTransformer</a> <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a></li><li class="src short"><a href="#v:strict_unary">strict_unary</a> :: (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb) =&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb</li><li class="src short"><a href="#v:trimcontrols_generic">trimcontrols_generic</a> :: (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb) =&gt; qfun -&gt; qfun</li><li class="src short"><a href="#v:approx_ct_generic">approx_ct_generic</a> :: (<a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb) =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; g -&gt; qfun -&gt; qfun</li><li class="src short"><a href="#v:exact_ct_generic">exact_ct_generic</a> :: (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb) =&gt; qfun -&gt; qfun</li><li class="src short"><a href="#v:standard_generic">standard_generic</a> :: (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb) =&gt; qfun -&gt; qfun</li><li class="src short"><a href="#v:strict_generic">strict_generic</a> :: (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb) =&gt; qfun -&gt; qfun</li></ul></div><div id="interface"><h1 id="g:1">Auxiliary functions
</h1><div class="top"><p class="src"><a name="v:with_combined_controls_iX" class="def">with_combined_controls_iX</a> ::  <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; &#91;<a href="Quipper-Circuit.html#t:Signed">Signed</a> <a href="Quipper-Monad.html#t:Endpoint">Endpoint</a>&#93; -&gt; (&#91;<a href="Quipper-Circuit.html#t:Signed">Signed</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a<a href="src/QuipperLib/Decompose/CliffordT.html#line-91" class="link">Source</a></p><div class="doc"><p>A version of <code><a href="QuipperLib-GateDecompositions.html#v:with_combined_controls">with_combined_controls</a></code> that uses doubly-controlled
 <em>iX</em>-gates to do the decomposition.  For example, when <em>n</em>=2, this
 yields circuits such as the following:
</p><p><img src="images/with_combined_controls2.png">
</p><p>And for <em>n</em>=1:
</p><p><img src="images/with_combined_controls1.png">
</p></div></div><div class="top"><p class="src"><a name="v:with_combined_controls_CT" class="def">with_combined_controls_CT</a> ::  <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Int.html#t:Int">Int</a> -&gt; &#91;<a href="Quipper-Circuit.html#t:Signed">Signed</a> <a href="Quipper-Monad.html#t:Endpoint">Endpoint</a>&#93; -&gt; (&#91;<a href="Quipper-Circuit.html#t:Signed">Signed</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a<a href="src/QuipperLib/Decompose/CliffordT.html#line-96" class="link">Source</a></p><div class="doc"><p>A version of <code><a href="QuipperLib-Decompose-CliffordT.html#v:with_combined_controls_iX">with_combined_controls_iX</a></code> that further decomposes
 the doubly-controlled <em>iX</em>-gates into the Clifford+<em>T</em> gate base.
</p></div></div><div class="top"><p class="src"><a name="v:with_normalized_controls" class="def">with_normalized_controls</a> ::  &#91;<a href="Quipper-Circuit.html#t:Signed">Signed</a> <a href="Quipper-Monad.html#t:Endpoint">Endpoint</a>&#93; -&gt; (&#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a<a href="src/QuipperLib/Decompose/CliffordT.html#line-106" class="link">Source</a></p><div class="doc"><p>Turn a list of signed controls into a list of positive quantum
 controls, by applying all classical controls directly, and
 conjugating any negative quantum controls by <em>X</em>. Call the
 inner block with those quantum controls. Usage:
</p><pre> with_normalized_controls ctrls $ \qs -&gt; do
   &lt;&lt;&lt;code using qs&gt;&gt;&gt;
</pre></div></div><div class="top"><p class="src"><a name="v:with_normalized_controls_HS" class="def">with_normalized_controls_HS</a> ::  &#91;<a href="Quipper-Circuit.html#t:Signed">Signed</a> <a href="Quipper-Monad.html#t:Endpoint">Endpoint</a>&#93; -&gt; (&#91;<a href="Quipper-Monad.html#t:Qubit">Qubit</a>&#93; -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a) -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> a<a href="src/QuipperLib/Decompose/CliffordT.html#line-120" class="link">Source</a></p><div class="doc"><p>Like <code><a href="QuipperLib-Decompose-CliffordT.html#v:with_normalized_controls">with_normalized_controls</a></code>, but use <em>HSSH</em> instead of <em>X</em>,
 so as not to leave the <em>H</em>, <em>S</em>, <em>T</em>, <em>CNot</em> gate base. 
</p></div></div><div class="top"><p class="src"><a name="v:negate_if" class="def">negate_if</a> :: <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Prelude.html#t:Num">Num</a> r =&gt; <a href="http://hackage.haskell.org/package/base-4.6.0.1/docs/Data-Bool.html#t:Bool">Bool</a> -&gt; r -&gt; r<a href="src/QuipperLib/Decompose/CliffordT.html#line-145" class="link">Source</a></p><div class="doc"><p>Negate the number if the boolean is true.
</p></div></div><h1 id="g:2">Transformers
</h1><h2 id="g:3">Control trimming
</h2><div class="top"><p class="src"><a name="v:trimcontrols_transformer" class="def">trimcontrols_transformer</a> :: <a href="Quipper-Transformer.html#t:Transformer">Transformer</a> <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a><a href="src/QuipperLib/Decompose/CliffordT.html#line-159" class="link">Source</a></p><div class="doc"><p>This transformer makes sure that not-gates, Pauli <em>X</em>-, <em>Y</em>-, and
 <em>Z</em>-gates, and <em>iX</em>-gates have at most two controls; that phase
 gates of the form Diag(1, &#966;) have no controls; and that all other
 gates have at most one control.
</p></div></div><h2 id="g:4">Approximate Clifford+<em>T</em> decomposition
</h2><div class="top"><p class="src"><a name="v:approx_ct_transformer" class="def">approx_ct_transformer</a> :: <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; g -&gt; <a href="Quipper-Transformer.html#t:Transformer">Transformer</a> <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a><a href="src/QuipperLib/Decompose/CliffordT.html#line-262" class="link">Source</a></p><div class="doc"><p>This transformer decomposes rotation and phase gates into the
 Clifford+<em>T</em> basis, using the approximate synthesis algorithm of
 <a href="http://arxiv.org/abs/1212.6253">http://arxiv.org/abs/1212.6253</a>. Other gates
 are unchanged. 
</p><p>This transformer requires a precision parameter, as well as a
 source of randomness. The <code><a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a></code> flag indicates whether to
 respect global phases.
</p></div></div><h2 id="g:5">Exact Clifford+<em>T</em> decomposition
</h2><div class="top"><p class="src"><a name="v:exact_ct_transformer" class="def">exact_ct_transformer</a> :: <a href="Quipper-Transformer.html#t:Transformer">Transformer</a> <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a><a href="src/QuipperLib/Decompose/CliffordT.html#line-403" class="link">Source</a></p><div class="doc"><p>This transformer decomposes all gates that permit exact
 Clifford+<em>T</em> representations into the following concrete gate base
 for Clifford+<em>T</em>:
</p><ul><li> controlled-not (with one positive or negative control),
</li><li> any single-qubit Clifford gates,
</li><li> <em>T</em> and <em>T</em><sup>&#8224;</sup>.
</li></ul><p>Classical controls and classical gates are not subject to the gate
 base, and are left untouched.
</p><p>Rotations and phase gates are left unchanged by this transformer,
 but any controls on those gates will be decomposed. 
</p></div></div><h2 id="g:6">Decomposition into standard gate set
</h2><div class="top"><p class="src"><a name="v:standard_transformer" class="def">standard_transformer</a> :: <a href="Quipper-Transformer.html#t:Transformer">Transformer</a> <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a><a href="src/QuipperLib/Decompose/CliffordT.html#line-578" class="link">Source</a></p><div class="doc"><p>This transformer decomposes a circuit into the standard gate set,
 which we define to be:
</p><ul><li> <em>X</em>, <em>Y</em>, <em>Z</em>, <em>H</em>, <em>S</em>, <em>S</em><sup>&#8224;</sup>, <em>T</em>, <em>T</em><sup>&#8224;</sup>, and <em>CNOT</em>.
</li></ul><p>As a precondition, the input circuit must only contain the
 following gates:
</p><ul><li> controlled-not (with one positive or negative control),
</li><li> any single-qubit Clifford gates,
</li><li> <em>T</em> and <em>T</em><sup>&#8224;</sup>.
</li></ul><p>Global phases are suppressed. Classical controls and classical
 gates are not subject to the gate base, and are left untouched.
</p><p>Any gates that are not among the input gates listed above will be
 transformed to a semantically correct circuit which may, however,
 contain gates that are not in the standard gate set. The best way
 to avoid this is to apply exact and approximate Clifford+<em>T</em>
 decomposition first.
</p></div></div><h2 id="g:7">Decomposition into strict gate set
</h2><div class="top"><p class="src"><a name="v:strict_transformer" class="def">strict_transformer</a> :: <a href="Quipper-Transformer.html#t:Transformer">Transformer</a> <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a><a href="src/QuipperLib/Decompose/CliffordT.html#line-699" class="link">Source</a></p><div class="doc"><p>This transformer decomposes a circuit into the strict gate set,
 which we define to be:
</p><ul><li> <em>H</em>, <em>S</em>, <em>T</em>, and <em>CNOT</em>.
</li></ul><p>As a precondition, the input circuit must only contain the
 following gates:
</p><ul><li> controlled-not (with one positive or negative control),
</li><li> any single-qubit Clifford gates,
</li><li> <em>T</em> and <em>T</em><sup>&#8224;</sup>.
</li></ul><p>Global phases are suppressed. Classical controls and classical
 gates are not subject to the gate base, and are left untouched.
</p><p>Any gates that are not among the input gates listed above will be
 transformed to a semantically correct circuit which may, however,
 contain gates that are not in the strict gate set. The best way to
 avoid this is to apply exact and approximate Clifford+<em>T</em>
 decomposition first.
</p></div></div><h1 id="g:8">Glue code for subroutines
</h1><div class="doc"><p>The following is stuff we have to do because subroutines are not
 yet handled very abstractly. It is untested whether subroutines
 work at all.
</p></div><div class="top"><p class="src"><a name="v:trimcontrols_subroutine" class="def">trimcontrols_subroutine</a> :: <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> -&gt; <a href="Quipper-Circuit.html#t:TypedSubroutine">TypedSubroutine</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/QuipperLib/Decompose/CliffordT.html#line-870" class="link">Source</a></p><div class="doc"><p>Handle subroutines for the <code><a href="QuipperLib-Decompose-CliffordT.html#v:trimcontrols_transformer">trimcontrols_transformer</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:trimcontrols_dtransformer" class="def">trimcontrols_dtransformer</a> :: <a href="Quipper-Transformer.html#t:DynamicTransformer">DynamicTransformer</a> <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a><a href="src/QuipperLib/Decompose/CliffordT.html#line-879" class="link">Source</a></p><div class="doc"><p>Dynamic transformer for the <code><a href="QuipperLib-Decompose-CliffordT.html#v:trimcontrols_transformer">trimcontrols_transformer</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:trimcontrols_unary" class="def">trimcontrols_unary</a> :: (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb) =&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb<a href="src/QuipperLib/Decompose/CliffordT.html#line-885" class="link">Source</a></p><div class="doc"><p>Unary transformer for the <code><a href="QuipperLib-Decompose-CliffordT.html#v:trimcontrols_transformer">trimcontrols_transformer</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:approx_ct_subroutine" class="def">approx_ct_subroutine</a> :: <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; g -&gt; <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> -&gt; <a href="Quipper-Circuit.html#t:TypedSubroutine">TypedSubroutine</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/QuipperLib/Decompose/CliffordT.html#line-889" class="link">Source</a></p><div class="doc"><p>Handle subroutines for the <code><a href="QuipperLib-Decompose-CliffordT.html#v:approx_ct_transformer">approx_ct_transformer</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:approx_ct_dtransformer" class="def">approx_ct_dtransformer</a> :: <a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; g -&gt; <a href="Quipper-Transformer.html#t:DynamicTransformer">DynamicTransformer</a> <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a><a href="src/QuipperLib/Decompose/CliffordT.html#line-898" class="link">Source</a></p><div class="doc"><p>Dynamic transformer for the <code><a href="QuipperLib-Decompose-CliffordT.html#v:approx_ct_transformer">approx_ct_transformer</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:approx_ct_unary" class="def">approx_ct_unary</a> :: (<a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb) =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; g -&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb<a href="src/QuipperLib/Decompose/CliffordT.html#line-904" class="link">Source</a></p><div class="doc"><p>Unary transformer for the <code><a href="QuipperLib-Decompose-CliffordT.html#v:approx_ct_transformer">approx_ct_transformer</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:exact_ct_subroutine" class="def">exact_ct_subroutine</a> :: <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> -&gt; <a href="Quipper-Circuit.html#t:TypedSubroutine">TypedSubroutine</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/QuipperLib/Decompose/CliffordT.html#line-908" class="link">Source</a></p><div class="doc"><p>Handle subroutines for the <code><a href="QuipperLib-Decompose-CliffordT.html#v:exact_ct_transformer">exact_ct_transformer</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:exact_ct_dtransformer" class="def">exact_ct_dtransformer</a> :: <a href="Quipper-Transformer.html#t:DynamicTransformer">DynamicTransformer</a> <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a><a href="src/QuipperLib/Decompose/CliffordT.html#line-917" class="link">Source</a></p><div class="doc"><p>Dynamic transformer for the <code><a href="QuipperLib-Decompose-CliffordT.html#v:exact_ct_transformer">exact_ct_transformer</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:exact_ct_unary" class="def">exact_ct_unary</a> :: (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb) =&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb<a href="src/QuipperLib/Decompose/CliffordT.html#line-923" class="link">Source</a></p><div class="doc"><p>Unary transformer for the <code><a href="QuipperLib-Decompose-CliffordT.html#v:exact_ct_transformer">exact_ct_transformer</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:standard_subroutine" class="def">standard_subroutine</a> :: <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> -&gt; <a href="Quipper-Circuit.html#t:TypedSubroutine">TypedSubroutine</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/QuipperLib/Decompose/CliffordT.html#line-927" class="link">Source</a></p><div class="doc"><p>Handle subroutines for the <code><a href="QuipperLib-Decompose-CliffordT.html#v:standard_transformer">standard_transformer</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:standard_dtransformer" class="def">standard_dtransformer</a> :: <a href="Quipper-Transformer.html#t:DynamicTransformer">DynamicTransformer</a> <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a><a href="src/QuipperLib/Decompose/CliffordT.html#line-936" class="link">Source</a></p><div class="doc"><p>Dynamic transformer for the <code><a href="QuipperLib-Decompose-CliffordT.html#v:standard_transformer">standard_transformer</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:standard_unary" class="def">standard_unary</a> :: (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb) =&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb<a href="src/QuipperLib/Decompose/CliffordT.html#line-942" class="link">Source</a></p><div class="doc"><p>Unary transformer for the <code><a href="QuipperLib-Decompose-CliffordT.html#v:standard_transformer">standard_transformer</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:strict_subroutine" class="def">strict_subroutine</a> :: <a href="Quipper-Circuit.html#t:BoxId">BoxId</a> -&gt; <a href="Quipper-Circuit.html#t:TypedSubroutine">TypedSubroutine</a> -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> ()<a href="src/QuipperLib/Decompose/CliffordT.html#line-946" class="link">Source</a></p><div class="doc"><p>Handle subroutines for the <code><a href="QuipperLib-Decompose-CliffordT.html#v:strict_transformer">strict_transformer</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:strict_dtransformer" class="def">strict_dtransformer</a> :: <a href="Quipper-Transformer.html#t:DynamicTransformer">DynamicTransformer</a> <a href="Quipper-Monad.html#t:Circ">Circ</a> <a href="Quipper-Monad.html#t:Qubit">Qubit</a> <a href="Quipper-Monad.html#t:Bit">Bit</a><a href="src/QuipperLib/Decompose/CliffordT.html#line-955" class="link">Source</a></p><div class="doc"><p>Dynamic transformer for the <code><a href="QuipperLib-Decompose-CliffordT.html#v:strict_transformer">strict_transformer</a></code>.
</p></div></div><div class="top"><p class="src"><a name="v:strict_unary" class="def">strict_unary</a> :: (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb) =&gt; (qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb) -&gt; qa -&gt; <a href="Quipper-Monad.html#t:Circ">Circ</a> qb<a href="src/QuipperLib/Decompose/CliffordT.html#line-961" class="link">Source</a></p><div class="doc"><p>Unary transformer for the <code><a href="QuipperLib-Decompose-CliffordT.html#v:strict_transformer">strict_transformer</a></code>.
</p></div></div><h1 id="g:9">Generic transformers
</h1><div class="doc"><p>The following generic functions form the high-level interface to
 these decomposition transformers. This is how the transformers
 should be accessed by user code.
</p></div><div class="top"><p class="src"><a name="v:trimcontrols_generic" class="def">trimcontrols_generic</a> :: (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb) =&gt; qfun -&gt; qfun<a href="src/QuipperLib/Decompose/CliffordT.html#line-975" class="link">Source</a></p><div class="doc"><p>This transformer makes sure that not-gates, Pauli <em>X</em>-, <em>Y</em>-, and
 <em>Z</em>-gates, and <em>iX</em>-gates have at most two controls; that phase
 gates of the form Diag(1, &#966;) have no controls; and that all other
 gates have at most one control.
</p></div></div><div class="top"><p class="src"><a name="v:approx_ct_generic" class="def">approx_ct_generic</a> :: (<a href="http://hackage.haskell.org/package/random-1.0.1.1/docs/System-Random.html#t:RandomGen">RandomGen</a> g, <a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb) =&gt; <a href="QuipperLib-Synthesis.html#t:KeepPhase">KeepPhase</a> -&gt; <a href="QuipperLib-Synthesis.html#t:Precision">Precision</a> -&gt; g -&gt; qfun -&gt; qfun<a href="src/QuipperLib/Decompose/CliffordT.html#line-986" class="link">Source</a></p><div class="doc"><p>This transformer decomposes rotation and phase gates into the
 Clifford+<em>T</em> basis, using the approximate synthesis algorithm of
 <a href="http://arxiv.org/abs/1212.6253">http://arxiv.org/abs/1212.6253</a>.  It requires a precision
 parameter, as well as a source of randomness. Other gates
 are unchanged.
</p></div></div><div class="top"><p class="src"><a name="v:exact_ct_generic" class="def">exact_ct_generic</a> :: (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb) =&gt; qfun -&gt; qfun<a href="src/QuipperLib/Decompose/CliffordT.html#line-1007" class="link">Source</a></p><div class="doc"><p>This transformer decomposes all gates that permit exact
 Clifford+<em>T</em> representations into the following concrete gate base
 for Clifford+<em>T</em>:
</p><ul><li> controlled-not (with one positive or negative control),
</li><li> any single-qubit Clifford gates,
</li><li> <em>T</em> and <em>T</em><sup>&#8224;</sup>.
</li></ul><p>Classical controls and classical gates are not subject to the gate
 base, and are left untouched.
</p><p>Rotations and phase gates are left unchanged by this transformer,
 but any controls on those gates will be decomposed. 
</p></div></div><div class="top"><p class="src"><a name="v:standard_generic" class="def">standard_generic</a> :: (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb) =&gt; qfun -&gt; qfun<a href="src/QuipperLib/Decompose/CliffordT.html#line-1035" class="link">Source</a></p><div class="doc"><p>This transformer decomposes a circuit into the standard gate set,
 which we define to be:
</p><ul><li> <em>X</em>, <em>Y</em>, <em>Z</em>, <em>H</em>, <em>S</em>, <em>S</em><sup>&#8224;</sup>, <em>T</em>, <em>T</em><sup>&#8224;</sup>, and <em>CNOT</em>.
</li></ul><p>As a precondition, the input circuit must only contain the
 following gates:
</p><ul><li> controlled-not (with one positive or negative control),
</li><li> any single-qubit Clifford gates,
</li><li> <em>T</em> and <em>T</em><sup>&#8224;</sup>.
</li></ul><p>Global phases are suppressed. Classical controls and classical
 gates are not subject to the gate base, and are left untouched.
</p><p>Any gates that are not among the input gates listed above will be
 transformed to a semantically correct circuit which may, however,
 contain gates that are not in the standard gate set. The best way
 to avoid this is to apply exact and approximate Clifford+<em>T</em>
 decomposition first.
</p></div></div><div class="top"><p class="src"><a name="v:strict_generic" class="def">strict_generic</a> :: (<a href="Quipper-QData.html#t:QCData">QCData</a> qa, <a href="Quipper-QData.html#t:QCData">QCData</a> qb, <a href="Quipper-Generic.html#t:QCurry">QCurry</a> qfun qa qb) =&gt; qfun -&gt; qfun<a href="src/QuipperLib/Decompose/CliffordT.html#line-1063" class="link">Source</a></p><div class="doc"><p>This transformer decomposes a circuit into the strict gate set,
 which we define to be:
</p><ul><li> <em>H</em>, <em>S</em>, <em>T</em>, and <em>CNOT</em>.
</li></ul><p>As a precondition, the input circuit must only contain the
 following gates:
</p><ul><li> controlled-not (with one positive or negative control),
</li><li> any single-qubit Clifford gates,
</li><li> <em>T</em> and <em>T</em><sup>&#8224;</sup>.
</li></ul><p>Global phases are suppressed. Classical controls and classical
 gates are not subject to the gate base, and are left untouched.
</p><p>Any gates that are not among the input gates listed above will be
 transformed to a semantically correct circuit which may, however,
 contain gates that are not in the strict gate set. The best way to
 avoid this is to apply exact and approximate Clifford+<em>T</em>
 decomposition first.
</p></div></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.13.2</p></div></body></html>
